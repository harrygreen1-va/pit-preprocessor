if OBJECT_ID('dbo.sp_Blitz') is null
    exec ('CREATE PROCEDURE dbo.sp_Blitz AS RETURN 0;');
go

alter procedure [dbo].[sp_Blitz] @help tinyint = 0,
                                 @checkuserdatabaseobjects tinyint = 1,
                                 @checkprocedurecache tinyint = 0,
                                 @outputtype varchar(20) = 'TABLE',
                                 @outputprocedurecache tinyint = 0,
                                 @checkprocedurecachefilter varchar(10) = null,
                                 @checkserverinfo tinyint = 0,
                                 @skipchecksserver nvarchar(256) = null,
                                 @skipchecksdatabase nvarchar(256) = null,
                                 @skipchecksschema nvarchar(256) = null,
                                 @skipcheckstable nvarchar(256) = null,
                                 @ignoreprioritiesbelow int = null,
                                 @ignoreprioritiesabove int = null,
                                 @outputservername nvarchar(256) = null,
                                 @outputdatabasename nvarchar(256) = null,
                                 @outputschemaname nvarchar(256) = null,
                                 @outputtablename nvarchar(256) = null,
                                 @outputxmlasnvarchar tinyint = 0,
                                 @emailrecipients varchar(max) = null,
                                 @emailprofile sysname = null,
                                 @summarymode tinyint = 0,
                                 @bringthepain tinyint = 0,
                                 @usualdbowner sysname = null,
                                 @skipblockingchecks tinyint = 1,
                                 @debug tinyint = 0,
                                 @version varchar(30) = null output,
                                 @versiondate datetime = null output,
                                 @versioncheckmode bit = 0
    with recompile
as
    set nocount on;
    set transaction isolation level read uncommitted;


select @version = '7.97', @versiondate = '20200712';
    set @outputtype = UPPER(@outputtype);

    if (@versioncheckmode = 1)
        begin
            return;
        end;

    if @help = 1
        print '
	/*
	sp_Blitz from http://FirstResponderKit.org

	This script checks the health of your SQL Server and gives you a prioritized
	to-do list of the most urgent things you should consider fixing.

	To learn more, visit http://FirstResponderKit.org where you can download new
	versions for free, watch training videos on how it works, get more info on
	the findings, contribute your own code, and more.

	Known limitations of this version:
	 - Only Microsoft-supported versions of SQL Server. Sorry, 2005 and 2000.
	 - If a database name has a question mark in it, some tests will fail. Gotta
	   love that unsupported sp_MSforeachdb.
	 - If you have offline databases, sp_Blitz fails the first time you run it,
	   but does work the second time. (Hoo, boy, this will be fun to debug.)
      - @OutputServerName will output QueryPlans as NVARCHAR(MAX) since Microsoft
	    has refused to support XML columns in Linked Server queries. The bug is now
		16 years old! *~ \o/ ~*

	Unknown limitations of this version:
	 - None.  (If we knew them, they would be known. Duh.)

     Changes - for the full list of improvements and fixes in this version, see:
     https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/

	Parameter explanations:

	@CheckUserDatabaseObjects	1=review user databases for triggers, heaps, etc. Takes more time for more databases and objects.
	@CheckServerInfo			1=show server info like CPUs, memory, virtualization
	@CheckProcedureCache		1=top 20-50 resource-intensive cache plans and analyze them for common performance issues.
	@OutputProcedureCache		1=output the top 20-50 resource-intensive plans even if they did not trigger an alarm
	@CheckProcedureCacheFilter	''CPU'' | ''Reads'' | ''Duration'' | ''ExecCount''
	@OutputType					''TABLE''=table | ''COUNT''=row with number found | ''MARKDOWN''=bulleted list | ''SCHEMA''=version and field list | ''XML'' =table output as XML | ''NONE'' = none
	@IgnorePrioritiesBelow		50=ignore priorities below 50
	@IgnorePrioritiesAbove		50=ignore priorities above 50
	For the rest of the parameters, see https://www.BrentOzar.com/blitz/documentation for details.

    MIT License

	Copyright for portions of sp_Blitz are held by Microsoft as part of project
	tigertoolbox and are provided under the MIT license:
	https://github.com/Microsoft/tigertoolbox

	All other copyrights for sp_Blitz are held by Brent Ozar Unlimited, 2020.

	Copyright (c) 2020 Brent Ozar Unlimited

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

	*/';
    else
        if @outputtype = 'SCHEMA'
            begin
                select fieldlist = '[Priority] TINYINT, [FindingsGroup] VARCHAR(50), [Finding] VARCHAR(200), [DatabaseName] NVARCHAR(128), [URL] VARCHAR(200), [Details] NVARCHAR(4000), [QueryPlan] NVARCHAR(MAX), [QueryPlanFiltered] NVARCHAR(MAX), [CheckID] INT';

            end;/* IF @OutputType = 'SCHEMA' */
        else
            begin

                declare @stringtoexecute nvarchar(4000)
                    ,@curr_tracefilename nvarchar(500)
                    ,@base_tracefilename nvarchar(500)
                    ,@indx int
                    ,@query_result_separator char(1)
                    ,@emailsubject nvarchar(255)
                    ,@emailbody nvarchar(max)
                    ,@emailattachmentfilename nvarchar(255)
                    ,@productversion nvarchar(128)
                    ,@productversionmajor decimal(10, 2)
                    ,@productversionminor decimal(10, 2)
                    ,@currentname nvarchar(128)
                    ,@currentdefaultvalue nvarchar(200)
                    ,@currentcheckid int
                    ,@currentpriority int
                    ,@currentfinding varchar(200)
                    ,@currenturl varchar(200)
                    ,@currentdetails nvarchar(4000)
                    ,@mssincewaitscleared decimal(38, 0)
                    ,@cpumssincewaitscleared decimal(38, 0)
                    ,@resulttext nvarchar(max)
                    ,@crlf nvarchar(2)
                    ,@processors int
                    ,@numanodes int
                    ,@minservermemory bigint
                    ,@maxservermemory bigint
                    ,@columnstoreindexesinuse bit
                    ,@tracefileissue bit
                    -- Flag for Windows OS to help with Linux support
                    ,@iswindowsoperatingsystem bit
                    ,@daysuptime numeric(23, 2)
                    /* For First Responder Kit consistency check:*/
                    ,@spblitzfullname varchar(1024)
                    ,@blitzisoutdatedcomparedtoothers bit
                    ,@tsql nvarchar(max)
                    ,@versioncheckmodeexiststsql nvarchar(max)
                    ,@blitzprocdbname varchar(256)
                    ,@execret int
                    ,@innerexecret int
                    ,@tmpcnt int
                    ,@previouscomponentname varchar(256)
                    ,@previouscomponentfullpath varchar(1024)
                    ,@currentstatementid int
                    ,@currentcomponentschema varchar(256)
                    ,@currentcomponentname varchar(256)
                    ,@currentcomponenttype varchar(256)
                    ,@currentcomponentversiondate datetime2
                    ,@currentcomponentfullname varchar(1024)
                    ,@currentcomponentmandatory bit
                    ,@maximumversiondate datetime
                    ,@statementcheckname varchar(256)
                    ,@statementoutputscounter bit
                    ,@outputcounterexpectedvalue int
                    ,@statementoutputsexecret bit
                    ,@statementoutputsdatetime bit
                    ,@currentcomponentmandatorycheckok bit
                    ,@currentcomponentversioncheckmodeok bit
                    ,@canexitloop bit
                    ,@frkisconsistent bit
                    ,@needtoturnnumericroundabortbackon bit;

                /* End of declarations for First Responder Kit consistency check:*/
                ;

                set @crlf = NCHAR(13) + NCHAR(10);
                set @resulttext = 'sp_Blitz Results: ' + @crlf;

                /* Last startup */
                select @daysuptime = CAST(DATEDIFF(hour, create_date, GETDATE()) / 24. as numeric(23, 2))
                from sys.databases
                where database_id = 2;

                if @daysuptime = 0
                    set @daysuptime = .01;

                /*
		Set the session state of Numeric_RoundAbort to off if any databases have Numeric Round-Abort enabled.
		Stops arithmetic overflow errors during data conversion. See Github issue #2302 for more info.
		*/
                if ((8192 & @@OPTIONS) = 8192) /* Numeric RoundAbort is currently on, so we may need to turn it off temporarily */
                    begin
                        if EXISTS(select 1
                                  from sys.databases
                                  where is_numeric_roundabort_on = 1) /* A database has it turned on */
                            begin
                                set @needtoturnnumericroundabortbackon = 1;
                                set numeric_roundabort off;
                            end;
                    end;


                /*
		--TOURSTOP01--
		See https://www.BrentOzar.com/go/blitztour for a guided tour.

		We start by creating #BlitzResults. It's a temp table that will store all of
		the results from our checks. Throughout the rest of this stored procedure,
		we're running a series of checks looking for dangerous things inside the SQL
		Server. When we find a problem, we insert rows into #BlitzResults. At the
		end, we return these results to the end user.

		#BlitzResults has a CheckID field, but there's no Check table. As we do
		checks, we insert data into this table, and we manually put in the CheckID.
		For a list of checks, visit http://FirstResponderKit.org.
		*/
                if OBJECT_ID('tempdb..#BlitzResults') is not null
                    drop table #blitzresults;
                create table #blitzresults
                (
                    id int identity (1, 1),
                    checkid int,
                    databasename nvarchar(128),
                    priority tinyint,
                    findingsgroup varchar(50),
                    finding varchar(200),
                    url varchar(200),
                    details nvarchar(4000),
                    queryplan [XML] null,
                    queryplanfiltered [NVARCHAR](max) null
                );

                if OBJECT_ID('tempdb..#TemporaryDatabaseResults') is not null
                    drop table #temporarydatabaseresults;
                create table #temporarydatabaseresults
                (
                    databasename nvarchar(128),
                    finding nvarchar(128)
                );

                /* First Responder Kit consistency (temporary tables) */

                if (OBJECT_ID('tempdb..#FRKObjects') is not null)
                    begin
                        exec sp_executesql N'DROP TABLE #FRKObjects;';
                    end;

                -- this one represents FRK objects
                create table #frkobjects
                (
                    databasename varchar(256) not null,
                    objectschemaname varchar(256) null,
                    objectname varchar(256) not null,
                    objecttype varchar(256) not null,
                    mandatorycomponent bit not null
                );


                if (OBJECT_ID('tempdb..#StatementsToRun4FRKVersionCheck') is not null)
                    begin
                        exec sp_executesql N'DROP TABLE #StatementsToRun4FRKVersionCheck;';
                    end;


                -- This one will contain the statements to be executed
                -- order: 1- Mandatory, 2- VersionCheckMode, 3- VersionCheck

                create table #statementstorun4frkversioncheck
                (
                    statementid int identity (1,1),
                    checkname varchar(256),
                    subjectname varchar(256),
                    subjectfullpath varchar(1024),
                    statementtext nvarchar(max),
                    statementoutputscounter bit,
                    outputcounterexpectedvalue int,
                    statementoutputsexecret bit,
                    statementoutputsdatetime bit
                );

                /* End of First Responder Kit consistency (temporary tables) */


                /*
		You can build your own table with a list of checks to skip. For example, you
		might have some databases that you don't care about, or some checks you don't
		want to run. Then, when you run sp_Blitz, you can specify these parameters:
		@SkipChecksDatabase = 'DBAtools',
		@SkipChecksSchema = 'dbo',
		@SkipChecksTable = 'BlitzChecksToSkip'
		Pass in the database, schema, and table that contains the list of checks you
		want to skip. This part of the code checks those parameters, gets the list,
		and then saves those in a temp table. As we run each check, we'll see if we
		need to skip it.

		Really anal-retentive users will note that the @SkipChecksServer parameter is
		not used. YET. We added that parameter in so that we could avoid changing the
		stored proc's surface area (interface) later.
		*/
                /* --TOURSTOP07-- */
                if OBJECT_ID('tempdb..#SkipChecks') is not null
                    drop table #skipchecks;
                create table #skipchecks
                (
                    databasename nvarchar(128),
                    checkid int,
                    servername nvarchar(128)
                );
                create clustered index ix_checkid_databasename on #skipchecks (checkid, databasename);

                if (OBJECT_ID('tempdb..#InvalidLogins') is not null)
                    begin
                        exec sp_executesql N'DROP TABLE #InvalidLogins;';
                    end;

                create table #invalidlogins
                (
                    loginsid varbinary(85),
                    loginname varchar(256)
                );

                if @skipcheckstable is not null
                    and @skipchecksschema is not null
                    and @skipchecksdatabase is not null
                    begin

                        if @debug in (1, 2) raiserror ('Inserting SkipChecks', 0, 1) with nowait;

                        set @stringtoexecute = 'INSERT INTO #SkipChecks(DatabaseName, CheckID, ServerName )
				SELECT DISTINCT DatabaseName, CheckID, ServerName
				FROM ' + QUOTENAME(@skipchecksdatabase) + '.' + QUOTENAME(@skipchecksschema) + '.' +
                                               QUOTENAME(@skipcheckstable)
                            +
                                               ' WHERE ServerName IS NULL OR ServerName = SERVERPROPERTY(''ServerName'') OPTION (RECOMPILE);';
                        exec (@stringtoexecute);
                    end;

                -- Flag for Windows OS to help with Linux support
                if EXISTS(select 1
                          from sys.all_objects
                          where name = 'dm_os_host_info')
                    begin
                        select @iswindowsoperatingsystem = case when host_platform = 'Windows' then 1 else 0 end
                        from sys.dm_os_host_info;
                    end;
                else
                    begin
                        select @iswindowsoperatingsystem = 1 ;
                    end;

                if not EXISTS(select 1
                              from #skipchecks
                              where databasename is null
                                and checkid = 106)
                    and
                   (select convert(int, value_in_use) from sys.configurations where name = 'default trace enabled') = 1
                    begin

                        select @curr_tracefilename = [path] from sys.traces where is_default = 1;
                        set @curr_tracefilename = reverse(@curr_tracefilename);

                        -- Set the trace file path separator based on underlying OS
                        if (@iswindowsoperatingsystem = 1) and @curr_tracefilename is not null
                            begin
                                select @indx = patindex('%\%', @curr_tracefilename);
                                set @curr_tracefilename = reverse(@curr_tracefilename);
                                set @base_tracefilename = left(@curr_tracefilename, len(@curr_tracefilename) - @indx) +
                                                          '\log.trc';
                            end;
                        else
                            begin
                                select @indx = patindex('%/%', @curr_tracefilename);
                                set @curr_tracefilename = reverse(@curr_tracefilename);
                                set @base_tracefilename = left(@curr_tracefilename, len(@curr_tracefilename) - @indx) +
                                                          '/log.trc';
                            end;

                    end;

                /* If the server has any databases on Antiques Roadshow, skip the checks that would break due to CTEs. */
                if @checkuserdatabaseobjects = 1 and EXISTS(select * from sys.databases where compatibility_level < 90)
                    begin
                        set @checkuserdatabaseobjects = 0;
                        print 'Databases with compatibility level < 90 found, so setting @CheckUserDatabaseObjects = 0.';
                        print 'The database-level checks rely on CTEs, which are not supported in SQL 2000 compat level databases.';
                        print 'Get with the cool kids and switch to a current compatibility level, Grandpa. To find the problems, run:';
                        print 'SELECT * FROM sys.databases WHERE compatibility_level < 90;';
                        insert into #blitzresults
                        (checkid,
                         priority,
                         findingsgroup,
                         finding,
                         url,
                         details)
                        select 204                                                                                                                                                                             as checkid,
                               0                                                                                                                                                                               as priority,
                               'Informational'                                                                                                                                                                 as findingsgroup,
                               '@CheckUserDatabaseObjects Disabled'                                                                                                                                            as finding,
                               'https://www.BrentOzar.com/blitz/'                                                                                                                                              as url,
                               'Since you have databases with compatibility_level < 90, we can''t run @CheckUserDatabaseObjects = 1. To find them: SELECT * FROM sys.databases WHERE compatibility_level < 90' as details;
                    end;

                /* --TOURSTOP08-- */
                /* If the server is Amazon RDS, skip checks that it doesn't allow */
                if LEFT(CAST(SERVERPROPERTY('ComputerNamePhysicalNetBIOS') as varchar(8000)), 8) = 'EC2AMAZ-'
                    and LEFT(CAST(SERVERPROPERTY('MachineName') as varchar(8000)), 8) = 'EC2AMAZ-'
                    and LEFT(CAST(SERVERPROPERTY('ServerName') as varchar(8000)), 8) = 'EC2AMAZ-'
                    and db_id('rdsadmin') is not null
                    and EXISTS(select *
                               from master.sys.all_objects
                               where name in ('rds_startup_tasks', 'rds_help_revlogin', 'rds_hexadecimal',
                                              'rds_failover_tracking', 'rds_database_tracking', 'rds_track_change'))
                    begin
                        insert into #skipchecks (checkid) values (6);
                        insert into #skipchecks (checkid) values (29);
                        insert into #skipchecks (checkid) values (30);
                        insert into #skipchecks (checkid) values (31);
                        insert into #skipchecks (checkid) values (40); /* TempDB only has one data file */
                        insert into #skipchecks (checkid) values (57);
                        insert into #skipchecks (checkid) values (59);
                        insert into #skipchecks (checkid) values (61);
                        insert into #skipchecks (checkid) values (62);
                        insert into #skipchecks (checkid) values (68);
                        insert into #skipchecks (checkid) values (69);
                        insert into #skipchecks (checkid) values (73);
                        insert into #skipchecks (checkid) values (79);
                        insert into #skipchecks (checkid) values (92);
                        insert into #skipchecks (checkid) values (94);
                        insert into #skipchecks (checkid) values (96);
                        insert into #skipchecks (checkid) values (98);
                        insert into #skipchecks (checkid) values (100); /* Remote DAC disabled */
                        insert into #skipchecks (checkid) values (123);
                        insert into #skipchecks (checkid) values (177);
                        insert into #skipchecks (checkid) values (180); /* 180/181 are maintenance plans */
                        insert into #skipchecks (checkid) values (181);
                        insert into #skipchecks (checkid) values (184); /* xp_readerrorlog checking for IFI */
                        insert into #skipchecks (checkid) values (211); /* xp_regread checking for power saving */
                        insert into #skipchecks (checkid) values (212); /* xp_regread */
                        insert into #skipchecks (checkid) values (219);
                        insert into #blitzresults
                        (checkid,
                         priority,
                         findingsgroup,
                         finding,
                         url,
                         details)
                        select 223                                                                                                             as checkid,
                               0                                                                                                               as priority,
                               'Informational'                                                                                                 as findingsgroup,
                               'Some Checks Skipped'                                                                                           as finding,
                               'https://aws.amazon.com/rds/sqlserver/'                                                                         as url,
                               'Amazon RDS detected, so we skipped some checks that are not currently possible, relevant, or practical there.' as details;
                    end;
                /* Amazon RDS skipped checks */

                /* If the server is ExpressEdition, skip checks that it doesn't allow */
                if CAST(SERVERPROPERTY('Edition') as nvarchar(1000)) like N'%Express%'
                    begin
                        insert into #skipchecks (checkid) values (30); /* Alerts not configured */
                        insert into #skipchecks (checkid) values (31); /* Operators not configured */
                        insert into #skipchecks (checkid) values (61); /* Agent alerts 19-25 */
                        insert into #skipchecks (checkid) values (73); /* Failsafe operator */
                        insert into #skipchecks (checkid) values (96); /* Agent alerts for corruption */
                        insert into #blitzresults
                        (checkid,
                         priority,
                         findingsgroup,
                         finding,
                         url,
                         details)
                        select 223                                                                                                                  as checkid,
                               0                                                                                                                    as priority,
                               'Informational'                                                                                                      as findingsgroup,
                               'Some Checks Skipped'                                                                                                as finding,
                               'https://stackoverflow.com/questions/1169634/limitations-of-sql-server-express'                                      as url,
                               'Express Edition detected, so we skipped some checks that are not currently possible, relevant, or practical there.' as details;
                    end;
                /* Express Edition skipped checks */

                /* If the server is an Azure Managed Instance, skip checks that it doesn't allow */
                if SERVERPROPERTY('EngineEdition') = 8
                    begin
                        insert into #skipchecks (checkid) values (1); /* Full backups - because of the MI GUID name bug mentioned here: https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/1481 */
                        insert into #skipchecks (checkid) values (2); /* Log backups - because of the MI GUID name bug mentioned here: https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/1481 */
                        insert into #skipchecks (checkid) values (6); /* Security - Jobs Owned By Users per https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/1919 */
                        insert into #skipchecks (checkid) values (21); /* Informational - Database Encrypted per https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/1919 */
                        insert into #skipchecks (checkid) values (24); /* File Configuration - System Database on C Drive per https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/1919 */
                        insert into #skipchecks (checkid) values (50); /* Max Server Memory Set Too High - because they max it out */
                        insert into #skipchecks (checkid) values (55); /* Security - Database Owner <> sa per https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/1919 */
                        insert into #skipchecks (checkid) values (74); /* TraceFlag On - because Azure Managed Instances go wild and crazy with the trace flags */
                        insert into #skipchecks (checkid) values (97); /* Unusual SQL Server Edition */
                        insert into #skipchecks (checkid) values (100); /* Remote DAC disabled - but it's working anyway, details here: https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/1481 */
                        insert into #skipchecks (checkid) values (186); /* MSDB Backup History Purged Too Frequently */
                        insert into #skipchecks (checkid) values (199); /* Default trace, details here: https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/1481 */
                        insert into #skipchecks (checkid) values (211); /*Power Plan */
                        insert into #skipchecks (checkid, databasename) values (80, 'master'); /* Max file size set */
                        insert into #skipchecks (checkid, databasename) values (80, 'model'); /* Max file size set */
                        insert into #skipchecks (checkid, databasename) values (80, 'msdb'); /* Max file size set */
                        insert into #skipchecks (checkid, databasename) values (80, 'tempdb'); /* Max file size set */
                        insert into #blitzresults
                        (checkid,
                         priority,
                         findingsgroup,
                         finding,
                         url,
                         details)
                        select 223                                                                                                                   as checkid,
                               0                                                                                                                     as priority,
                               'Informational'                                                                                                       as findingsgroup,
                               'Some Checks Skipped'                                                                                                 as finding,
                               'https://docs.microsoft.com/en-us/azure/sql-database/sql-database-managed-instance-index'                             as url,
                               'Managed Instance detected, so we skipped some checks that are not currently possible, relevant, or practical there.' as details;
                    end;
                /* Azure Managed Instance skipped checks */

                /*
		That's the end of the SkipChecks stuff.
		The next several tables are used by various checks later.
		*/
                if OBJECT_ID('tempdb..#ConfigurationDefaults') is not null
                    drop table #configurationdefaults;
                create table #configurationdefaults
                (
                    name nvarchar(128),
                    defaultvalue bigint,
                    checkid int
                );

                if OBJECT_ID('tempdb..#Recompile') is not null
                    drop table #recompile;
                create table #recompile
                (
                    dbname varchar(200),
                    procname varchar(300),
                    recompileflag varchar(1),
                    spschema varchar(50)
                );

                if OBJECT_ID('tempdb..#DatabaseDefaults') is not null
                    drop table #databasedefaults;
                create table #databasedefaults
                (
                    name nvarchar(128),
                    defaultvalue nvarchar(200),
                    checkid int,
                    priority int,
                    finding varchar(200),
                    url varchar(200),
                    details nvarchar(4000)
                );

                if OBJECT_ID('tempdb..#DatabaseScopedConfigurationDefaults') is not null
                    drop table #databasescopedconfigurationdefaults;
                create table #databasescopedconfigurationdefaults
                (
                    id int identity (1,1),
                    configuration_id int,
                    [name] nvarchar(60),
                    default_value sql_variant,
                    default_value_for_secondary sql_variant,
                    checkid int,
                );

                if OBJECT_ID('tempdb..#DBCCs') is not null
                    drop table #dbccs;
                create table #dbccs
                (
                    id int identity (1, 1)
                        primary key,
                    parentobject varchar(255),
                    object varchar(255),
                    field varchar(255),
                    value varchar(255),
                    dbname nvarchar(128) null
                );

                if OBJECT_ID('tempdb..#LogInfo2012') is not null
                    drop table #loginfo2012;
                create table #loginfo2012
                (
                    recoveryunitid int,
                    fileid smallint,
                    filesize bigint,
                    startoffset bigint,
                    fseqno bigint,
                    [Status] tinyint,
                    parity tinyint,
                    createlsn numeric(38)
                );

                if OBJECT_ID('tempdb..#LogInfo') is not null
                    drop table #loginfo;
                create table #loginfo
                (
                    fileid smallint,
                    filesize bigint,
                    startoffset bigint,
                    fseqno bigint,
                    [Status] tinyint,
                    parity tinyint,
                    createlsn numeric(38)
                );

                if OBJECT_ID('tempdb..#partdb') is not null
                    drop table #partdb;
                create table #partdb
                (
                    dbname nvarchar(128),
                    objectname nvarchar(200),
                    type_desc nvarchar(128)
                );

                if OBJECT_ID('tempdb..#TraceStatus') is not null
                    drop table #tracestatus;
                create table #tracestatus
                (
                    traceflag varchar(10),
                    status bit,
                    global bit,
                    session bit
                );

                if OBJECT_ID('tempdb..#driveInfo') is not null
                    drop table #driveinfo;
                create table #driveinfo
                (
                    drive nvarchar,
                    size decimal(18, 2)
                );

                if OBJECT_ID('tempdb..#dm_exec_query_stats') is not null
                    drop table #dm_exec_query_stats;
                create table #dm_exec_query_stats
                (
                    [id] [int] not null
                        identity (1, 1),
                    [sql_handle] [varbinary](64) not null,
                    [statement_start_offset] [int] not null,
                    [statement_end_offset] [int] not null,
                    [plan_generation_num] [bigint] not null,
                    [plan_handle] [varbinary](64) not null,
                    [creation_time] [datetime] not null,
                    [last_execution_time] [datetime] not null,
                    [execution_count] [bigint] not null,
                    [total_worker_time] [bigint] not null,
                    [last_worker_time] [bigint] not null,
                    [min_worker_time] [bigint] not null,
                    [max_worker_time] [bigint] not null,
                    [total_physical_reads] [bigint] not null,
                    [last_physical_reads] [bigint] not null,
                    [min_physical_reads] [bigint] not null,
                    [max_physical_reads] [bigint] not null,
                    [total_logical_writes] [bigint] not null,
                    [last_logical_writes] [bigint] not null,
                    [min_logical_writes] [bigint] not null,
                    [max_logical_writes] [bigint] not null,
                    [total_logical_reads] [bigint] not null,
                    [last_logical_reads] [bigint] not null,
                    [min_logical_reads] [bigint] not null,
                    [max_logical_reads] [bigint] not null,
                    [total_clr_time] [bigint] not null,
                    [last_clr_time] [bigint] not null,
                    [min_clr_time] [bigint] not null,
                    [max_clr_time] [bigint] not null,
                    [total_elapsed_time] [bigint] not null,
                    [last_elapsed_time] [bigint] not null,
                    [min_elapsed_time] [bigint] not null,
                    [max_elapsed_time] [bigint] not null,
                    [query_hash] [binary](8) null,
                    [query_plan_hash] [binary](8) null,
                    [query_plan] [xml] null,
                    [query_plan_filtered] [nvarchar](max) null,
                    [text] [nvarchar](max) collate sql_latin1_general_cp1_ci_as
                        null,
                    [text_filtered] [nvarchar](max) collate sql_latin1_general_cp1_ci_as
                        null
                );

                if OBJECT_ID('tempdb..#ErrorLog') is not null
                    drop table #errorlog;
                create table #errorlog
                (
                    logdate datetime,
                    processinfo nvarchar(20),
                    [Text] nvarchar(1000)
                );

                if OBJECT_ID('tempdb..#fnTraceGettable') is not null
                    drop table #fntracegettable;
                create table #fntracegettable
                (
                    textdata nvarchar(4000),
                    databasename nvarchar(256),
                    eventclass int,
                    severity int,
                    starttime datetime,
                    endtime datetime,
                    duration bigint,
                    ntusername nvarchar(256),
                    ntdomainname nvarchar(256),
                    hostname nvarchar(256),
                    applicationname nvarchar(256),
                    loginname nvarchar(256),
                    dbusername nvarchar(256)
                );

                if OBJECT_ID('tempdb..#Instances') is not null
                    drop table #instances;
                create table #instances
                (
                    instance_number nvarchar(max),
                    instance_name nvarchar(max),
                    data_field nvarchar(max)
                );

                if OBJECT_ID('tempdb..#IgnorableWaits') is not null
                    drop table #ignorablewaits;
                create table #ignorablewaits
                (
                    wait_type nvarchar(60)
                );
                insert into #ignorablewaits values ('BROKER_EVENTHANDLER');
                insert into #ignorablewaits values ('BROKER_RECEIVE_WAITFOR');
                insert into #ignorablewaits values ('BROKER_TASK_STOP');
                insert into #ignorablewaits values ('BROKER_TO_FLUSH');
                insert into #ignorablewaits values ('BROKER_TRANSMITTER');
                insert into #ignorablewaits values ('CHECKPOINT_QUEUE');
                insert into #ignorablewaits values ('CLR_AUTO_EVENT');
                insert into #ignorablewaits values ('CLR_MANUAL_EVENT');
                insert into #ignorablewaits values ('CLR_SEMAPHORE');
                insert into #ignorablewaits values ('DBMIRROR_DBM_EVENT');
                insert into #ignorablewaits values ('DBMIRROR_DBM_MUTEX');
                insert into #ignorablewaits values ('DBMIRROR_EVENTS_QUEUE');
                insert into #ignorablewaits values ('DBMIRROR_WORKER_QUEUE');
                insert into #ignorablewaits values ('DBMIRRORING_CMD');
                insert into #ignorablewaits values ('DIRTY_PAGE_POLL');
                insert into #ignorablewaits values ('DISPATCHER_QUEUE_SEMAPHORE');
                insert into #ignorablewaits values ('FT_IFTS_SCHEDULER_IDLE_WAIT');
                insert into #ignorablewaits values ('FT_IFTSHC_MUTEX');
                insert into #ignorablewaits values ('HADR_CLUSAPI_CALL');
                insert into #ignorablewaits values ('HADR_FABRIC_CALLBACK');
                insert into #ignorablewaits values ('HADR_FILESTREAM_IOMGR_IOCOMPLETION');
                insert into #ignorablewaits values ('HADR_LOGCAPTURE_WAIT');
                insert into #ignorablewaits values ('HADR_NOTIFICATION_DEQUEUE');
                insert into #ignorablewaits values ('HADR_TIMER_TASK');
                insert into #ignorablewaits values ('HADR_WORK_QUEUE');
                insert into #ignorablewaits values ('LAZYWRITER_SLEEP');
                insert into #ignorablewaits values ('LOGMGR_QUEUE');
                insert into #ignorablewaits values ('ONDEMAND_TASK_QUEUE');
                insert into #ignorablewaits values ('PARALLEL_REDO_DRAIN_WORKER');
                insert into #ignorablewaits values ('PARALLEL_REDO_LOG_CACHE');
                insert into #ignorablewaits values ('PARALLEL_REDO_TRAN_LIST');
                insert into #ignorablewaits values ('PARALLEL_REDO_WORKER_SYNC');
                insert into #ignorablewaits values ('PARALLEL_REDO_WORKER_WAIT_WORK');
                insert into #ignorablewaits values ('PREEMPTIVE_HADR_LEASE_MECHANISM');
                insert into #ignorablewaits values ('PREEMPTIVE_SP_SERVER_DIAGNOSTICS');
                insert into #ignorablewaits values ('QDS_ASYNC_QUEUE');
                insert into #ignorablewaits values ('QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP');
                insert into #ignorablewaits values ('QDS_PERSIST_TASK_MAIN_LOOP_SLEEP');
                insert into #ignorablewaits values ('QDS_SHUTDOWN_QUEUE');
                insert into #ignorablewaits values ('REDO_THREAD_PENDING_WORK');
                insert into #ignorablewaits values ('REQUEST_FOR_DEADLOCK_SEARCH');
                insert into #ignorablewaits values ('SLEEP_SYSTEMTASK');
                insert into #ignorablewaits values ('SLEEP_TASK');
                insert into #ignorablewaits values ('SOS_WORK_DISPATCHER');
                insert into #ignorablewaits values ('SP_SERVER_DIAGNOSTICS_SLEEP');
                insert into #ignorablewaits values ('SQLTRACE_BUFFER_FLUSH');
                insert into #ignorablewaits values ('SQLTRACE_INCREMENTAL_FLUSH_SLEEP');
                insert into #ignorablewaits values ('UCS_SESSION_REGISTRATION');
                insert into #ignorablewaits values ('WAIT_XTP_OFFLINE_CKPT_NEW_LOG');
                insert into #ignorablewaits values ('WAITFOR');
                insert into #ignorablewaits values ('XE_DISPATCHER_WAIT');
                insert into #ignorablewaits values ('XE_LIVE_TARGET_TVF');
                insert into #ignorablewaits values ('XE_TIMER_EVENT');

                if @debug in (1, 2) raiserror ('Setting @MsSinceWaitsCleared', 0, 1) with nowait;

                select @mssincewaitscleared = DATEDIFF(minute, create_date, CURRENT_TIMESTAMP) * 60000.0
                from sys.databases
                where name = 'tempdb';

                /* Have they cleared wait stats? Using a 10% fudge factor */
                if @mssincewaitscleared * .9 > (select MAX(wait_time_ms)
                                                from sys.dm_os_wait_stats
                                                where wait_type in ('SP_SERVER_DIAGNOSTICS_SLEEP',
                                                                    'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
                                                                    'REQUEST_FOR_DEADLOCK_SEARCH',
                                                                    'HADR_FILESTREAM_IOMGR_IOCOMPLETION',
                                                                    'LAZYWRITER_SLEEP',
                                                                    'SQLTRACE_INCREMENTAL_FLUSH_SLEEP',
                                                                    'DIRTY_PAGE_POLL', 'LOGMGR_QUEUE'))
                    begin

                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 185) with nowait;

                        set @mssincewaitscleared = (select MAX(wait_time_ms)
                                                    from sys.dm_os_wait_stats
                                                    where wait_type in ('SP_SERVER_DIAGNOSTICS_SLEEP',
                                                                        'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
                                                                        'REQUEST_FOR_DEADLOCK_SEARCH',
                                                                        'HADR_FILESTREAM_IOMGR_IOCOMPLETION',
                                                                        'LAZYWRITER_SLEEP',
                                                                        'SQLTRACE_INCREMENTAL_FLUSH_SLEEP',
                                                                        'DIRTY_PAGE_POLL', 'LOGMGR_QUEUE'));
                        if @mssincewaitscleared = 0 set @mssincewaitscleared = 1;
                        insert into #blitzresults
                        (checkid,
                         priority,
                         findingsgroup,
                         finding,
                         url,
                         details)
                        values (185,
                                240,
                                'Wait Stats',
                                'Wait Stats Have Been Cleared',
                                'https://BrentOzar.com/go/waits',
                                'Someone ran DBCC SQLPERF to clear sys.dm_os_wait_stats at approximately: '
                                    + CONVERT(nvarchar(100),
                                        DATEADD(minute, (-1. * (@mssincewaitscleared) / 1000. / 60.), GETDATE()), 120));
                    end;

                /* @CpuMsSinceWaitsCleared is used for waits stats calculations */

                if @debug in (1, 2) raiserror ('Setting @CpuMsSinceWaitsCleared', 0, 1) with nowait;

                select @cpumssincewaitscleared = @mssincewaitscleared * scheduler_count
                from sys.dm_os_sys_info;

                /* If we're outputting CSV or Markdown, don't bother checking the plan cache because we cannot export plans. */
                if @outputtype = 'CSV' or @outputtype = 'MARKDOWN'
                    set @checkprocedurecache = 0;

                /* If we're posting a question on Stack, include background info on the server */
                if @outputtype = 'MARKDOWN'
                    set @checkserverinfo = 1;

                /* Only run CheckUserDatabaseObjects if there are less than 50 databases. */
                if @bringthepain = 0 and 50 <= (select COUNT(*) from sys.databases) and @checkuserdatabaseobjects = 1
                    begin
                        set @checkuserdatabaseobjects = 0;
                        print 'Running sp_Blitz @CheckUserDatabaseObjects = 1 on a server with 50+ databases may cause temporary insanity for the server and/or user.';
                        print 'If you''re sure you want to do this, run again with the parameter @BringThePain = 1.';
                        insert into #blitzresults
                        (checkid,
                         priority,
                         findingsgroup,
                         finding,
                         url,
                         details)
                        select 201                                                                           as checkid,
                               0                                                                             as priority,
                               'Informational'                                                               as findingsgroup,
                               '@CheckUserDatabaseObjects Disabled'                                          as finding,
                               'https://www.BrentOzar.com/blitz/'                                            as url,
                               'If you want to check 50+ databases, you have to also use @BringThePain = 1.' as details;
                    end;

                /* Sanitize our inputs */
                select @outputservername = QUOTENAME(@outputservername),
                       @outputdatabasename = QUOTENAME(@outputdatabasename),
                       @outputschemaname = QUOTENAME(@outputschemaname),
                       @outputtablename = QUOTENAME(@outputtablename);

                /* Get the major and minor build numbers */

                if @debug in (1, 2) raiserror ('Getting version information.', 0, 1) with nowait;

                set @productversion = CAST(SERVERPROPERTY('ProductVersion') as nvarchar(128));
                select @productversionmajor = SUBSTRING(@productversion, 1, CHARINDEX('.', @productversion) + 1),
                       @productversionminor = PARSENAME(CONVERT(varchar(32), @productversion), 2);

                /*
		Whew! we're finally done with the setup, and we can start doing checks.
		First, let's make sure we're actually supposed to do checks on this server.
		The user could have passed in a SkipChecks table that specified to skip ALL
		checks on this server, so let's check for that:
		*/
                if ((SERVERPROPERTY('ServerName') not in (select servername
                                                          from #skipchecks
                                                          where databasename is null
                                                            and checkid is null))
                    or (@skipcheckstable is null)
                    )
                    begin

                        /*
				Our very first check! We'll put more comments in this one just to
				explain exactly how it works. First, we check to see if we're
				supposed to skip CheckID 1 (that's the check we're working on.)
				*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 1)
                            begin

                                /*
						Below, we check master.sys.databases looking for databases
						that haven't had a backup in the last week. If we find any,
						we insert them into #BlitzResults, the temp table that
						tracks our server's problems. Note that if the check does
						NOT find any problems, we don't save that. We're only
						saving the problems, not the successful checks.
						*/

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 1) with nowait;

                                if SERVERPROPERTY('EngineEdition') <> 8 /* Azure Managed Instances need a special query */
                                    begin
                                        insert into #blitzresults
                                        (checkid,
                                         databasename,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 1                                                                 as checkid,
                                               d.[name]                                                          as databasename,
                                               1                                                                 as priority,
                                               'Backup'                                                          as findingsgroup,
                                               'Backups Not Performed Recently'                                  as finding,
                                               'https://BrentOzar.com/go/nobak'                                  as url,
                                               'Last backed up: '
                                                   + COALESCE(CAST(MAX(b.backup_finish_date) as varchar(25)),
                                                              'never')                                           as details
                                        from master.sys.databases d
                                                 left outer join msdb.dbo.backupset b
                                                                 on d.name collate sql_latin1_general_cp1_ci_as =
                                                                    b.database_name collate sql_latin1_general_cp1_ci_as
                                                                     and b.type = 'D'
                                                                     and
                                                                    b.server_name = SERVERPROPERTY('ServerName') /*Backupset ran on current server  */
                                        where d.database_id <> 2 /* Bonus points if you know what that means */
                                          and d.state not in (1, 6, 10) /* Not currently offline or restoring, like log shipping databases */
                                          and d.is_in_standby = 0 /* Not a log shipping target database */
                                          and d.source_database_id is null /* Excludes database snapshots */
                                          and d.name not in (select distinct databasename
                                                             from #skipchecks
                                                             where checkid is null
                                                                or checkid = 1)
                                            /*
										    The above NOT IN filters out the databases we're not supposed to check.
										    */
                                        group by d.name
                                        having MAX(b.backup_finish_date) <= DATEADD(dd,
                                                                                    -7, GETDATE())
                                            or MAX(b.backup_finish_date) is null;
                                    end;

                                else /* SERVERPROPERTY('EngineName') must be 8, Azure Managed Instances */
                                    begin
                                        insert into #blitzresults
                                        (checkid,
                                         databasename,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 1                                                                 as checkid,
                                               d.[name]                                                          as databasename,
                                               1                                                                 as priority,
                                               'Backup'                                                          as findingsgroup,
                                               'Backups Not Performed Recently'                                  as finding,
                                               'https://BrentOzar.com/go/nobak'                                  as url,
                                               'Last backed up: '
                                                   + COALESCE(CAST(MAX(b.backup_finish_date) as varchar(25)),
                                                              'never')                                           as details
                                        from master.sys.databases d
                                                 left outer join msdb.dbo.backupset b
                                                                 on d.name collate sql_latin1_general_cp1_ci_as =
                                                                    b.database_name collate sql_latin1_general_cp1_ci_as
                                                                     and b.type = 'D'
                                        where d.database_id <> 2 /* Bonus points if you know what that means */
                                          and d.state not in (1, 6, 10) /* Not currently offline or restoring, like log shipping databases */
                                          and d.is_in_standby = 0 /* Not a log shipping target database */
                                          and d.source_database_id is null /* Excludes database snapshots */
                                          and d.name not in (select distinct databasename
                                                             from #skipchecks
                                                             where checkid is null
                                                                or checkid = 1)
                                            /*
										    The above NOT IN filters out the databases we're not supposed to check.
										    */
                                        group by d.name
                                        having MAX(b.backup_finish_date) <= DATEADD(dd,
                                                                                    -7, GETDATE())
                                            or MAX(b.backup_finish_date) is null;
                                    end;


                                /*
						And there you have it. The rest of this stored procedure works the same
						way: it asks:
						- Should I skip this check?
						- If not, do I find problems?
						- Insert the results into #BlitzResults
						*/

                            end;

                        /*
				And that's the end of CheckID #1.

				CheckID #2 is a little simpler because it only involves one query, and it's
				more typical for queries that people contribute. But keep reading, because
				the next check gets more complex again.
				*/

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 2)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 2) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select distinct 2                                                        as checkid,
                                                d.name                                                   as databasename,
                                                1                                                        as priority,
                                                'Backup'                                                 as findingsgroup,
                                                'Full Recovery Model w/o Log Backups'                    as finding,
                                                'https://BrentOzar.com/go/biglogs'                       as url,
                                                ('The ' + CAST(CAST((select ((SUM([mf].[size]) * 8.) / 1024.)
                                                                     from sys.[master_files] as [mf]
                                                                     where [mf].[database_id] = d.[database_id]
                                                                       and [mf].[type_desc] = 'LOG') as decimal(18, 2)) as varchar(30)) +
                                                 'MB log file has not been backed up in the last week.') as details
                                from master.sys.databases d
                                where d.recovery_model in (1, 2)
                                  and d.database_id not in (2, 3)
                                  and d.source_database_id is null
                                  and d.state not in (1, 6, 10) /* Not currently offline or restoring, like log shipping databases */
                                  and d.is_in_standby = 0 /* Not a log shipping target database */
                                  and d.source_database_id is null /* Excludes database snapshots */
                                  and d.name not in (select distinct databasename
                                                     from #skipchecks
                                                     where checkid is null
                                                        or checkid = 2)
                                  and not EXISTS(select *
                                                 from msdb.dbo.backupset b
                                                 where d.name collate sql_latin1_general_cp1_ci_as =
                                                       b.database_name collate sql_latin1_general_cp1_ci_as
                                                   and b.type = 'L'
                                                   and b.backup_finish_date >= DATEADD(dd,
                                                                                       -7, GETDATE()));
                            end;

                        /*
				Next up, we've got CheckID 8. (These don't have to go in order.) This one
				won't work on SQL Server 2005 because it relies on a new DMV that didn't
				exist prior to SQL Server 2008. This means we have to check the SQL Server
				version first, then build a dynamic string with the query we want to run:
				*/

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 8)
                            begin
                                if @@VERSION not like '%Microsoft SQL Server 2000%'
                                    and @@VERSION not like '%Microsoft SQL Server 2005%'
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 8) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults
							(CheckID, Priority,
							FindingsGroup,
							Finding, URL,
							Details)
					  SELECT 8 AS CheckID,
					  230 AS Priority,
					  ''Security'' AS FindingsGroup,
					  ''Server Audits Running'' AS Finding,
					  ''https://BrentOzar.com/go/audits'' AS URL,
					  (''SQL Server built-in audit functionality is being used by server audit: '' + [name]) AS Details FROM sys.dm_server_audit_status  OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;
                            end;

                        /*
				But what if you need to run a query in every individual database?
				Hop down to the @CheckUserDatabaseObjects section.

				And that's the basic idea! You can read through the rest of the
				checks if you like - some more exciting stuff happens closer to the
				end of the stored proc, where we start doing things like checking
				the plan cache, but those aren't as cleanly commented.

				If you'd like to contribute your own check, use one of the check
				formats shown above and email it to Help@BrentOzar.com. You don't
				have to pick a CheckID or a link - we'll take care of that when we
				test and publish the code. Thanks!
				*/

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 93)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 93) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 93                                                as                                                          checkid,
                                       1                                                 as                                                          priority,
                                       'Backup'                                          as                                                          findingsgroup,
                                       'Backing Up to Same Drive Where Databases Reside' as                                                          finding,
                                       'https://BrentOzar.com/go/backup'                 as                                                          url,
                                       CAST(COUNT(1) as varchar(50)) + ' backups done on drive '
                                           + UPPER(LEFT(bmf.physical_device_name, 3))
                                           +
                                       ' in the last two weeks, where database files also live. This represents a serious risk if that array fails.' details
                                from msdb.dbo.backupmediafamily as bmf
                                         inner join msdb.dbo.backupset as bs on bmf.media_set_id = bs.media_set_id
                                    and bs.backup_start_date >= (DATEADD(dd,
                                                                         -14, GETDATE()))
                                    /* Filter out databases that were recently restored: */
                                         left outer join msdb.dbo.restorehistory rh
                                                         on bs.database_name = rh.destination_database_name and
                                                            rh.restore_date > DATEADD(dd, -14, GETDATE())
                                where UPPER(LEFT(bmf.physical_device_name, 3)) <> 'HTT'
                                  and bmf.physical_device_name not like '\\%'
                                  and -- GitHub Issue #2141
                                    @iswindowsoperatingsystem = 1
                                  and -- GitHub Issue #1995
                                        UPPER(LEFT(bmf.physical_device_name collate sql_latin1_general_cp1_ci_as, 3)) in
                                        (
                                            select distinct UPPER(
                                                                    LEFT(mf.physical_name collate sql_latin1_general_cp1_ci_as, 3))
                                            from sys.master_files as mf
                                            where mf.database_id <> 2)
                                  and rh.destination_database_name is null
                                group by UPPER(LEFT(bmf.physical_device_name, 3));
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 119)
                            and EXISTS(select *
                                       from sys.all_objects o
                                       where o.name = 'dm_database_encryption_keys')
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 119) with nowait;

                                set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, DatabaseName, URL, Details)
								SELECT 119 AS CheckID,
								1 AS Priority,
								''Backup'' AS FindingsGroup,
								''TDE Certificate Not Backed Up Recently'' AS Finding,
								db_name(dek.database_id) AS DatabaseName,
								''https://BrentOzar.com/go/tde'' AS URL,
								''The certificate '' + c.name + '' is used to encrypt database '' + db_name(dek.database_id) + ''. Last backup date: '' + COALESCE(CAST(c.pvt_key_last_backup_date AS VARCHAR(100)), ''Never'') AS Details
								FROM sys.certificates c INNER JOIN sys.dm_database_encryption_keys dek ON c.thumbprint = dek.encryptor_thumbprint
								WHERE pvt_key_last_backup_date IS NULL OR pvt_key_last_backup_date <= DATEADD(dd, -30, GETDATE())  OPTION (RECOMPILE);';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 202)
                            and EXISTS(select *
                                       from sys.all_columns c
                                       where c.name = 'pvt_key_last_backup_date')
                            and EXISTS(select *
                                       from msdb.information_schema.columns c
                                       where c.table_name = 'backupset'
                                         and c.column_name = 'encryptor_thumbprint')
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 202) with nowait;

                                set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
								SELECT DISTINCT 202 AS CheckID,
								1 AS Priority,
								''Backup'' AS FindingsGroup,
								''Encryption Certificate Not Backed Up Recently'' AS Finding,
								''https://BrentOzar.com/go/tde'' AS URL,
								''The certificate '' + c.name + '' is used to encrypt database backups. Last backup date: '' + COALESCE(CAST(c.pvt_key_last_backup_date AS VARCHAR(100)), ''Never'') AS Details
								FROM sys.certificates c
                                INNER JOIN msdb.dbo.backupset bs ON c.thumbprint = bs.encryptor_thumbprint
                                WHERE pvt_key_last_backup_date IS NULL OR pvt_key_last_backup_date <= DATEADD(dd, -30, GETDATE()) OPTION (RECOMPILE);';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 3)
                            begin
                                if DATEADD(dd, -60, GETDATE()) >
                                   (select top 1 backup_start_date from msdb.dbo.backupset order by backup_start_date)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 3) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         databasename,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select top 1 3                                                as checkid,
                                                     'msdb',
                                                     200                                              as priority,
                                                     'Backup'                                         as findingsgroup,
                                                     'MSDB Backup History Not Purged'                 as finding,
                                                     'https://BrentOzar.com/go/history'               as url,
                                                     ('Database backup history retained back to '
                                                         + CAST(bs.backup_start_date as varchar(20))) as details
                                        from msdb.dbo.backupset bs
                                                 left outer join msdb.dbo.restorehistory rh
                                                                 on bs.database_name = rh.destination_database_name
                                        where rh.destination_database_name is null
                                        order by bs.backup_start_date asc;
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 186)
                            begin
                                if DATEADD(dd, -2, GETDATE()) <
                                   (select top 1 backup_start_date from msdb.dbo.backupset order by backup_start_date)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 186) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         databasename,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select top 1 186                                              as checkid,
                                                     'msdb',
                                                     200                                              as priority,
                                                     'Backup'                                         as findingsgroup,
                                                     'MSDB Backup History Purged Too Frequently'      as finding,
                                                     'https://BrentOzar.com/go/history'               as url,
                                                     ('Database backup history only retained back to '
                                                         + CAST(bs.backup_start_date as varchar(20))) as details
                                        from msdb.dbo.backupset bs
                                        order by backup_start_date asc;
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 178)
                            and EXISTS(select *
                                       from msdb.dbo.backupset bs
                                       where bs.type = 'D'
                                         and bs.backup_size >= 50000000000 /* At least 50GB */
                                         and DATEDIFF(second, bs.backup_start_date, bs.backup_finish_date) <= 60 /* Backup took less than 60 seconds */
                                         and bs.backup_finish_date >= DATEADD(day, -14, GETDATE()) /* In the last 2 weeks */)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 178) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 178                                                                                                       as checkid,
                                       200                                                                                                       as priority,
                                       'Performance'                                                                                             as findingsgroup,
                                       'Snapshot Backups Occurring'                                                                              as finding,
                                       'https://BrentOzar.com/go/snaps'                                                                          as url,
                                       (CAST(COUNT(*) as varchar(20)) +
                                        ' snapshot-looking backups have occurred in the last two weeks, indicating that IO may be freezing up.') as details
                                from msdb.dbo.backupset bs
                                where bs.type = 'D'
                                  and bs.backup_size >= 50000000000 /* At least 50GB */
                                  and DATEDIFF(second, bs.backup_start_date, bs.backup_finish_date) <= 60 /* Backup took less than 60 seconds */
                                  and bs.backup_finish_date >= DATEADD(day, -14, GETDATE()); /* In the last 2 weeks */
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 4)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 4) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 4                                                                                                                                 as checkid,
                                       230                                                                                                                               as priority,
                                       'Security'                                                                                                                        as findingsgroup,
                                       'Sysadmins'                                                                                                                       as finding,
                                       'https://BrentOzar.com/go/sa'                                                                                                     as url,
                                       ('Login [' + l.name
                                           +
                                        '] is a sysadmin - meaning they can do absolutely anything in SQL Server, including dropping databases or hiding their tracks.') as details
                                from master.sys.syslogins l
                                where l.sysadmin = 1
                                  and l.name <> SUSER_SNAME(0x01)
                                  and l.denylogin = 0
                                  and l.name not like 'NT SERVICE\%'
                                  and l.name <> 'l_certSignSmDetach'; /* Added in SQL 2016 */
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where checkid = 2301)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 2301) with nowait;

                                insert into #invalidlogins
                                    exec sp_validatelogins;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 2301                                                                                                                as checkid,
                                       230                                                                                                                 as priority,
                                       'Security'                                                                                                          as findingsgroup,
                                       'Invalid login defined with Windows Authentication'                                                                 as finding,
                                       'https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-validatelogins-transact-sql' as url,
                                       ('Windows user or group ' + QUOTENAME(loginname) +
                                        ' is mapped to a SQL Server principal but no longer exists in the Windows environment.')                           as details
                                from #invalidlogins;
                            end;
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 5)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 5) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 5                                                                                                                                                                     as checkid,
                                       230                                                                                                                                                                   as priority,
                                       'Security'                                                                                                                                                            as findingsgroup,
                                       'Security Admins'                                                                                                                                                     as finding,
                                       'https://BrentOzar.com/go/sa'                                                                                                                                         as url,
                                       ('Login [' + l.name
                                           +
                                        '] is a security admin - meaning they can give themselves permission to do absolutely anything in SQL Server, including dropping databases or hiding their tracks.') as details
                                from master.sys.syslogins l
                                where l.securityadmin = 1
                                  and l.name <> SUSER_SNAME(0x01)
                                  and l.denylogin = 0;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 104)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 104) with nowait;

                                insert into #blitzresults
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])
                                select 104                                                                                                                                                 as [CheckID],
                                       230                                                                                                                                                 as [Priority],
                                       'Security'                                                                                                                                          as [FindingsGroup],
                                       'Login Can Control Server'                                                                                                                          as [Finding],
                                       'https://BrentOzar.com/go/sa'                                                                                                                       as [URL],
                                       'Login [' + pri.[name]
                                           +
                                       '] has the CONTROL SERVER permission - meaning they can do absolutely anything in SQL Server, including dropping databases or hiding their tracks.' as [Details]
                                from sys.server_principals as pri
                                where pri.[principal_id] in (
                                    select p.[grantee_principal_id]
                                    from sys.server_permissions as p
                                    where p.[state] in ('G', 'W')
                                      and p.[class] = 100
                                      and p.[type] = 'CL')
                                  and pri.[name] not like '##%##';
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 6)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 6) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 6                                                                                                                        as checkid,
                                       230                                                                                                                      as priority,
                                       'Security'                                                                                                               as findingsgroup,
                                       'Jobs Owned By Users'                                                                                                    as finding,
                                       'https://BrentOzar.com/go/owners'                                                                                        as url,
                                       ('Job [' + j.name + '] is owned by ['
                                           + SUSER_SNAME(j.owner_sid)
                                           +
                                        '] - meaning if their login is disabled or not available due to Active Directory problems, the job will stop working.') as details
                                from msdb.dbo.sysjobs j
                                where j.enabled = 1
                                  and SUSER_SNAME(j.owner_sid) <> SUSER_SNAME(0x01);
                            end;

                        /* --TOURSTOP06-- */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 7)
                            begin
                                /* --TOURSTOP02-- */

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 7) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 7                                                                                                                                                           as checkid,
                                       230                                                                                                                                                         as priority,
                                       'Security'                                                                                                                                                  as findingsgroup,
                                       'Stored Procedure Runs at Startup'                                                                                                                          as finding,
                                       'https://BrentOzar.com/go/startup'                                                                                                                          as url,
                                       ('Stored procedure [master].['
                                           + r.specific_schema + '].['
                                           + r.specific_name
                                           +
                                        '] runs automatically when SQL Server starts up.  Make sure you know exactly what this stored procedure is doing, because it could pose a security risk.') as details
                                from master.information_schema.routines r
                                where OBJECTPROPERTY(OBJECT_ID(routine_name),
                                                     'ExecIsStartup') = 1;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 10)
                            begin
                                if @@VERSION not like '%Microsoft SQL Server 2000%'
                                    and @@VERSION not like '%Microsoft SQL Server 2005%'
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 10) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults
							(CheckID,
							Priority,
							FindingsGroup,
							Finding,
							URL,
							Details)
					  SELECT 10 AS CheckID,
					  100 AS Priority,
					  ''Performance'' AS FindingsGroup,
					  ''Resource Governor Enabled'' AS Finding,
					  ''https://BrentOzar.com/go/rg'' AS URL,
					  (''Resource Governor is enabled.  Queries may be throttled.  Make sure you understand how the Classifier Function is configured.'') AS Details FROM sys.resource_governor_configuration WHERE is_enabled = 1 OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 11)
                            begin
                                if @@VERSION not like '%Microsoft SQL Server 2000%'
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 11) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults
							(CheckID,
							Priority,
							FindingsGroup,
							Finding,
							URL,
							Details)
					  SELECT 11 AS CheckID,
					  100 AS Priority,
					  ''Performance'' AS FindingsGroup,
					  ''Server Triggers Enabled'' AS Finding,
					  ''https://BrentOzar.com/go/logontriggers/'' AS URL,
					  (''Server Trigger ['' + [name] ++ ''] is enabled.  Make sure you understand what that trigger is doing - the less work it does, the better.'') AS Details FROM sys.server_triggers WHERE is_disabled = 0 AND is_ms_shipped = 0  OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 12)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 12) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 12                                                                                 as checkid,
                                       [name]                                                                             as databasename,
                                       10                                                                                 as priority,
                                       'Performance'                                                                      as findingsgroup,
                                       'Auto-Close Enabled'                                                               as finding,
                                       'https://BrentOzar.com/go/autoclose'                                               as url,
                                       ('Database [' + [name]
                                           +
                                        '] has auto-close enabled.  This setting can dramatically decrease performance.') as details
                                from sys.databases
                                where is_auto_close_on = 1
                                  and name not in (select distinct databasename
                                                   from #skipchecks
                                                   where checkid is null
                                                      or checkid = 12);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 13)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 13) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 13                                                                                  as checkid,
                                       [name]                                                                              as databasename,
                                       10                                                                                  as priority,
                                       'Performance'                                                                       as findingsgroup,
                                       'Auto-Shrink Enabled'                                                               as finding,
                                       'https://BrentOzar.com/go/autoshrink'                                               as url,
                                       ('Database [' + [name]
                                           +
                                        '] has auto-shrink enabled.  This setting can dramatically decrease performance.') as details
                                from sys.databases
                                where is_auto_shrink_on = 1
                                  and name not in (select distinct databasename
                                                   from #skipchecks
                                                   where checkid is null
                                                      or checkid = 13);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 14)
                            begin
                                if @@VERSION not like '%Microsoft SQL Server 2000%'
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 14) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults
							(CheckID,
							DatabaseName,
							Priority,
							FindingsGroup,
							Finding,
							URL,
							Details)
					  SELECT 14 AS CheckID,
					  [name] as DatabaseName,
					  50 AS Priority,
					  ''Reliability'' AS FindingsGroup,
					  ''Page Verification Not Optimal'' AS Finding,
					  ''https://BrentOzar.com/go/torn'' AS URL,
					  (''Database ['' + [name] + ''] has '' + [page_verify_option_desc] + '' for page verification.  SQL Server may have a harder time recognizing and recovering from storage corruption.  Consider using CHECKSUM instead.'') COLLATE database_default AS Details
					  FROM sys.databases
					  WHERE page_verify_option < 2
					  AND name <> ''tempdb''
					  AND state <> 1 /* Restoring */
					  and name not in (select distinct DatabaseName from #SkipChecks WHERE CheckID IS NULL OR CheckID = 14) OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 15)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 15) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 15                                                                                                                                                                               as checkid,
                                       [name]                                                                                                                                                                           as databasename,
                                       110                                                                                                                                                                              as priority,
                                       'Performance'                                                                                                                                                                    as findingsgroup,
                                       'Auto-Create Stats Disabled'                                                                                                                                                     as finding,
                                       'https://BrentOzar.com/go/acs'                                                                                                                                                   as url,
                                       ('Database [' + [name]
                                           +
                                        '] has auto-create-stats disabled.  SQL Server uses statistics to build better execution plans, and without the ability to automatically create more, performance may suffer.') as details
                                from sys.databases
                                where is_auto_create_stats_on = 0
                                  and name not in (select distinct databasename
                                                   from #skipchecks
                                                   where checkid is null
                                                      or checkid = 15);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 16)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 16) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 16                                                                                                                                                                               as checkid,
                                       [name]                                                                                                                                                                           as databasename,
                                       110                                                                                                                                                                              as priority,
                                       'Performance'                                                                                                                                                                    as findingsgroup,
                                       'Auto-Update Stats Disabled'                                                                                                                                                     as finding,
                                       'https://BrentOzar.com/go/aus'                                                                                                                                                   as url,
                                       ('Database [' + [name]
                                           +
                                        '] has auto-update-stats disabled.  SQL Server uses statistics to build better execution plans, and without the ability to automatically update them, performance may suffer.') as details
                                from sys.databases
                                where is_auto_update_stats_on = 0
                                  and name not in (select distinct databasename
                                                   from #skipchecks
                                                   where checkid is null
                                                      or checkid = 16);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 17)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 17) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 17                                                                                                                                                                                                                                                                  as checkid,
                                       [name]                                                                                                                                                                                                                                                              as databasename,
                                       150                                                                                                                                                                                                                                                                 as priority,
                                       'Performance'                                                                                                                                                                                                                                                       as findingsgroup,
                                       'Stats Updated Asynchronously'                                                                                                                                                                                                                                      as finding,
                                       'https://BrentOzar.com/go/asyncstats'                                                                                                                                                                                                                               as url,
                                       ('Database [' + [name]
                                           +
                                        '] has auto-update-stats-async enabled.  When SQL Server gets a query for a table with out-of-date statistics, it will run the query with the stats it has - while updating stats to make later queries better. The initial run of the query may suffer, though.') as details
                                from sys.databases
                                where is_auto_update_stats_async_on = 1
                                  and name not in (select distinct databasename
                                                   from #skipchecks
                                                   where checkid is null
                                                      or checkid = 17);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 20)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 20) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 20                                                                                                                                                                                                                                    as checkid,
                                       [name]                                                                                                                                                                                                                                as databasename,
                                       200                                                                                                                                                                                                                                   as priority,
                                       'Informational'                                                                                                                                                                                                                       as findingsgroup,
                                       'Date Correlation On'                                                                                                                                                                                                                 as finding,
                                       'https://BrentOzar.com/go/corr'                                                                                                                                                                                                       as url,
                                       ('Database [' + [name]
                                           +
                                        '] has date correlation enabled.  This is not a default setting, and it has some performance overhead.  It tells SQL Server that date fields in two tables are related, and SQL Server maintains statistics showing that relation.') as details
                                from sys.databases
                                where is_date_correlation_on = 1
                                  and name not in (select distinct databasename
                                                   from #skipchecks
                                                   where checkid is null
                                                      or checkid = 20);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 21)
                            begin
                                /* --TOURSTOP04-- */
                                if @@VERSION not like '%Microsoft SQL Server 2000%'
                                    and @@VERSION not like '%Microsoft SQL Server 2005%'
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 21) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults
							(CheckID,
							DatabaseName,
							Priority,
							FindingsGroup,
							Finding,
							URL,
							Details)
					  SELECT 21 AS CheckID,
					  [name] as DatabaseName,
					  200 AS Priority,
					  ''Informational'' AS FindingsGroup,
					  ''Database Encrypted'' AS Finding,
					  ''https://BrentOzar.com/go/tde'' AS URL,
					  (''Database ['' + [name] + ''] has Transparent Data Encryption enabled.  Make absolutely sure you have backed up the certificate and private key, or else you will not be able to restore this database.'') AS Details
					  FROM sys.databases
					  WHERE is_encrypted = 1
					  and name not in (select distinct DatabaseName from #SkipChecks WHERE CheckID IS NULL OR CheckID = 21) OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;
                            end;

                        /*
				Believe it or not, SQL Server doesn't track the default values
				for sp_configure options! We'll make our own list here.
				*/

                        if @debug in (1, 2) raiserror ('Generating default configuration values', 0, 1) with nowait;

                        insert into #configurationdefaults
                        values ('access check cache bucket count', 0, 1001);
                        insert into #configurationdefaults
                        values ('access check cache quota', 0, 1002);
                        insert into #configurationdefaults
                        values ('Ad Hoc Distributed Queries', 0, 1003);
                        insert into #configurationdefaults
                        values ('affinity I/O mask', 0, 1004);
                        insert into #configurationdefaults
                        values ('affinity mask', 0, 1005);
                        insert into #configurationdefaults
                        values ('affinity64 mask', 0, 1066);
                        insert into #configurationdefaults
                        values ('affinity64 I/O mask', 0, 1067);
                        insert into #configurationdefaults
                        values ('Agent XPs', 0, 1071);
                        insert into #configurationdefaults
                        values ('allow updates', 0, 1007);
                        insert into #configurationdefaults
                        values ('awe enabled', 0, 1008);
                        insert into #configurationdefaults
                        values ('backup checksum default', 0, 1070);
                        insert into #configurationdefaults
                        values ('backup compression default', 0, 1073);
                        insert into #configurationdefaults
                        values ('blocked process threshold', 0, 1009);
                        insert into #configurationdefaults
                        values ('blocked process threshold (s)', 0, 1009);
                        insert into #configurationdefaults
                        values ('c2 audit mode', 0, 1010);
                        insert into #configurationdefaults
                        values ('clr enabled', 0, 1011);
                        insert into #configurationdefaults
                        values ('common criteria compliance enabled', 0, 1074);
                        insert into #configurationdefaults
                        values ('contained database authentication', 0, 1068);
                        insert into #configurationdefaults
                        values ('cost threshold for parallelism', 5, 1012);
                        insert into #configurationdefaults
                        values ('cross db ownership chaining', 0, 1013);
                        insert into #configurationdefaults
                        values ('cursor threshold', -1, 1014);
                        insert into #configurationdefaults
                        values ('Database Mail XPs', 0, 1072);
                        insert into #configurationdefaults
                        values ('default full-text language', 1033, 1016);
                        insert into #configurationdefaults
                        values ('default language', 0, 1017);
                        insert into #configurationdefaults
                        values ('default trace enabled', 1, 1018);
                        insert into #configurationdefaults
                        values ('disallow results from triggers', 0, 1019);
                        insert into #configurationdefaults
                        values ('EKM provider enabled', 0, 1075);
                        insert into #configurationdefaults
                        values ('filestream access level', 0, 1076);
                        insert into #configurationdefaults
                        values ('fill factor (%)', 0, 1020);
                        insert into #configurationdefaults
                        values ('ft crawl bandwidth (max)', 100, 1021);
                        insert into #configurationdefaults
                        values ('ft crawl bandwidth (min)', 0, 1022);
                        insert into #configurationdefaults
                        values ('ft notify bandwidth (max)', 100, 1023);
                        insert into #configurationdefaults
                        values ('ft notify bandwidth (min)', 0, 1024);
                        insert into #configurationdefaults
                        values ('index create memory (KB)', 0, 1025);
                        insert into #configurationdefaults
                        values ('in-doubt xact resolution', 0, 1026);
                        insert into #configurationdefaults
                        values ('lightweight pooling', 0, 1027);
                        insert into #configurationdefaults
                        values ('locks', 0, 1028);
                        insert into #configurationdefaults
                        values ('max degree of parallelism', 0, 1029);
                        insert into #configurationdefaults
                        values ('max full-text crawl range', 4, 1030);
                        insert into #configurationdefaults
                        values ('max server memory (MB)', 2147483647, 1031);
                        insert into #configurationdefaults
                        values ('max text repl size (B)', 65536, 1032);
                        insert into #configurationdefaults
                        values ('max worker threads', 0, 1033);
                        insert into #configurationdefaults
                        values ('media retention', 0, 1034);
                        insert into #configurationdefaults
                        values ('min memory per query (KB)', 1024, 1035);
                        /* Accepting both 0 and 16 below because both have been seen in the wild as defaults. */
                        if EXISTS(select *
                                  from sys.configurations
                                  where name = 'min server memory (MB)'
                                    and value_in_use in (0, 16))
                            insert into #configurationdefaults
                            select 'min server memory (MB)',
                                   CAST(value_in_use as bigint),
                                   1036
                            from sys.configurations
                            where name = 'min server memory (MB)';
                        else
                            insert into #configurationdefaults
                            values ('min server memory (MB)', 0, 1036);
                        insert into #configurationdefaults
                        values ('nested triggers', 1, 1037);
                        insert into #configurationdefaults
                        values ('network packet size (B)', 4096, 1038);
                        insert into #configurationdefaults
                        values ('Ole Automation Procedures', 0, 1039);
                        insert into #configurationdefaults
                        values ('open objects', 0, 1040);
                        insert into #configurationdefaults
                        values ('optimize for ad hoc workloads', 0, 1041);
                        insert into #configurationdefaults
                        values ('PH timeout (s)', 60, 1042);
                        insert into #configurationdefaults
                        values ('precompute rank', 0, 1043);
                        insert into #configurationdefaults
                        values ('priority boost', 0, 1044);
                        insert into #configurationdefaults
                        values ('query governor cost limit', 0, 1045);
                        insert into #configurationdefaults
                        values ('query wait (s)', -1, 1046);
                        insert into #configurationdefaults
                        values ('recovery interval (min)', 0, 1047);
                        insert into #configurationdefaults
                        values ('remote access', 1, 1048);
                        insert into #configurationdefaults
                        values ('remote admin connections', 0, 1049);
                        /* SQL Server 2012 changes a configuration default */
                        if @@VERSION like '%Microsoft SQL Server 2005%'
                            or @@VERSION like '%Microsoft SQL Server 2008%'
                            begin
                                insert into #configurationdefaults
                                values ('remote login timeout (s)', 20, 1069);
                            end;
                        else
                            begin
                                insert into #configurationdefaults
                                values ('remote login timeout (s)', 10, 1069);
                            end;
                        insert into #configurationdefaults
                        values ('remote proc trans', 0, 1050);
                        insert into #configurationdefaults
                        values ('remote query timeout (s)', 600, 1051);
                        insert into #configurationdefaults
                        values ('Replication XPs', 0, 1052);
                        insert into #configurationdefaults
                        values ('RPC parameter data validation', 0, 1053);
                        insert into #configurationdefaults
                        values ('scan for startup procs', 0, 1054);
                        insert into #configurationdefaults
                        values ('server trigger recursion', 1, 1055);
                        insert into #configurationdefaults
                        values ('set working set size', 0, 1056);
                        insert into #configurationdefaults
                        values ('show advanced options', 0, 1057);
                        insert into #configurationdefaults
                        values ('SMO and DMO XPs', 1, 1058);
                        insert into #configurationdefaults
                        values ('SQL Mail XPs', 0, 1059);
                        insert into #configurationdefaults
                        values ('transform noise words', 0, 1060);
                        insert into #configurationdefaults
                        values ('two digit year cutoff', 2049, 1061);
                        insert into #configurationdefaults
                        values ('user connections', 0, 1062);
                        insert into #configurationdefaults
                        values ('user options', 0, 1063);
                        insert into #configurationdefaults
                        values ('Web Assistant Procedures', 0, 1064);
                        insert into #configurationdefaults
                        values ('xp_cmdshell', 0, 1065);

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 22)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 22) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select cd.checkid,
                                       200                             as priority,
                                       'Non-Default Server Config'     as findingsgroup,
                                       cr.name                         as finding,
                                       'https://BrentOzar.com/go/conf' as url,
                                       ('This sp_configure option has been changed.  Its default value is '
                                           + COALESCE(CAST(cd.[DefaultValue] as varchar(100)),
                                                      '(unknown)')
                                           + ' and it has been set to '
                                           + CAST(cr.value_in_use as varchar(100))
                                           + '.')                      as details
                                from sys.configurations cr
                                         inner join #configurationdefaults cd on cd.name = cr.name
                                         left outer join #configurationdefaults cdused on cdused.name = cr.name
                                    and cdused.defaultvalue = cr.value_in_use
                                where cdused.name is null;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 190)
                            begin

                                if @debug in (1, 2)
                                    raiserror ('Setting @MinServerMemory and @MaxServerMemory', 0, 1) with nowait;

                                select @minservermemory = CAST(value_in_use as bigint)
                                from sys.configurations
                                where name = 'min server memory (MB)';
                                select @maxservermemory = CAST(value_in_use as bigint)
                                from sys.configurations
                                where name = 'max server memory (MB)';

                                if (@minservermemory = @maxservermemory)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 190) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        values (190,
                                                200,
                                                'Performance',
                                                'Non-Dynamic Memory',
                                                'https://BrentOzar.com/go/memory',
                                                'Minimum Server Memory setting is the same as the Maximum (both set to ' +
                                                CAST(@minservermemory as nvarchar(50)) +
                                                '). This will not allow dynamic memory. Please revise memory settings');
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 188)
                            begin

                                /* Let's set variables so that our query is still SARGable */

                                if @debug in (1, 2) raiserror ('Setting @Processors.', 0, 1) with nowait;

                                set @processors = (select cpu_count from sys.dm_os_sys_info);

                                if @debug in (1, 2) raiserror ('Setting @NUMANodes', 0, 1) with nowait;

                                set @numanodes = (select COUNT(1)
                                                  from sys.dm_os_performance_counters pc
                                                  where pc.object_name like '%Buffer Node%'
                                                    and counter_name = 'Page life expectancy');
                                /* If Cost Threshold for Parallelism is default then flag as a potential issue */
                                /* If MAXDOP is default and processors > 8 or NUMA nodes > 1 then flag as potential issue */

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 188) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 188                                 as checkid,
                                       200                                 as priority,
                                       'Performance'                       as findingsgroup,
                                       cr.name                             as finding,
                                       'https://BrentOzar.com/go/cxpacket' as url,
                                       ('Set to ' + CAST(cr.value_in_use as nvarchar(50)) +
                                        ', its default value. Changing this sp_configure setting may reduce CXPACKET waits.')
                                from sys.configurations cr
                                         inner join #configurationdefaults cd on cd.name = cr.name
                                    and cr.value_in_use = cd.defaultvalue
                                where cr.name = 'cost threshold for parallelism'
                                   or (cr.name = 'max degree of parallelism' and (@numanodes > 1 or @processors > 8));
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 24)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 24) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select distinct 24                                                                                                                                                as checkid,
                                                DB_NAME(database_id)                                                                                                                              as databasename,
                                                170                                                                                                                                               as priority,
                                                'File Configuration'                                                                                                                              as findingsgroup,
                                                'System Database on C Drive'                                                                                                                      as finding,
                                                'https://BrentOzar.com/go/cdrive'                                                                                                                 as url,
                                                ('The ' + DB_NAME(database_id)
                                                    +
                                                 ' database has a file on the C drive.  Putting system databases on the C drive runs the risk of crashing the server when it runs out of space.') as details
                                from sys.master_files
                                where UPPER(LEFT(physical_name, 1)) = 'C'
                                  and DB_NAME(database_id) in ('master',
                                                               'model', 'msdb');
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 25)
                            and SERVERPROPERTY('EngineEdition') <> 8 /* Azure Managed Instances */
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 25) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select top 1 25                                as checkid,
                                             'tempdb',
                                             20                                as priority,
                                             'File Configuration'              as findingsgroup,
                                             'TempDB on C Drive'               as finding,
                                             'https://BrentOzar.com/go/cdrive' as url,
                                             case
                                                 when growth > 0
                                                     then ('The tempdb database has files on the C drive.  TempDB frequently grows unpredictably, putting your server at risk of running out of C drive space and crashing hard.  C is also often much slower than other drives, so performance may be suffering.')
                                                 else ('The tempdb database has files on the C drive.  TempDB is not set to Autogrow, hopefully it is big enough.  C is also often much slower than other drives, so performance may be suffering.')
                                                 end                           as details
                                from sys.master_files
                                where UPPER(LEFT(physical_name, 1)) = 'C'
                                  and DB_NAME(database_id) = 'tempdb';
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 26)
                            and SERVERPROPERTY('EngineEdition') <> 8 /* Azure Managed Instances */
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 26) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select distinct 26                                                                                                                                         as checkid,
                                                DB_NAME(database_id)                                                                                                                       as databasename,
                                                20                                                                                                                                         as priority,
                                                'Reliability'                                                                                                                              as findingsgroup,
                                                'User Databases on C Drive'                                                                                                                as finding,
                                                'https://BrentOzar.com/go/cdrive'                                                                                                          as url,
                                                ('The ' + DB_NAME(database_id)
                                                    +
                                                 ' database has a file on the C drive.  Putting databases on the C drive runs the risk of crashing the server when it runs out of space.') as details
                                from sys.master_files
                                where UPPER(LEFT(physical_name, 1)) = 'C'
                                  and DB_NAME(database_id) not in ('master',
                                                                   'model', 'msdb',
                                                                   'tempdb')
                                  and DB_NAME(database_id) not in (
                                    select distinct databasename
                                    from #skipchecks
                                    where checkid is null
                                       or checkid = 26);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 27)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 27) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 27                                                                                  as checkid,
                                       'master'                                                                            as databasename,
                                       200                                                                                 as priority,
                                       'Informational'                                                                     as findingsgroup,
                                       'Tables in the Master Database'                                                     as finding,
                                       'https://BrentOzar.com/go/mastuser'                                                 as url,
                                       ('The ' + name
                                           + ' table in the master database was created by end users on '
                                           + CAST(create_date as varchar(20))
                                           +
                                        '. Tables in the master database may not be restored in the event of a disaster.') as details
                                from master.sys.tables
                                where is_ms_shipped = 0
                                  and name not in ('CommandLog', 'SqlServerVersions', '$ndo$srvproperty');
                                /* That last one is the Dynamics NAV licensing table: https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/2426 */
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 28)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 28) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 28                                                                                as checkid,
                                       'msdb'                                                                            as databasename,
                                       200                                                                               as priority,
                                       'Informational'                                                                   as findingsgroup,
                                       'Tables in the MSDB Database'                                                     as finding,
                                       'https://BrentOzar.com/go/msdbuser'                                               as url,
                                       ('The ' + name
                                           + ' table in the msdb database was created by end users on '
                                           + CAST(create_date as varchar(20))
                                           +
                                        '. Tables in the msdb database may not be restored in the event of a disaster.') as details
                                from msdb.sys.tables
                                where is_ms_shipped = 0
                                  and name not like '%DTA_%';
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 29)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 29) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 29                                                                                  as checkid,
                                       'model'                                                                             as databasename,
                                       200                                                                                 as priority,
                                       'Informational'                                                                     as findingsgroup,
                                       'Tables in the Model Database'                                                      as finding,
                                       'https://BrentOzar.com/go/model'                                                    as url,
                                       ('The ' + name
                                           + ' table in the model database was created by end users on '
                                           + CAST(create_date as varchar(20))
                                           +
                                        '. Tables in the model database are automatically copied into all new databases.') as details
                                from model.sys.tables
                                where is_ms_shipped = 0;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 30)
                            begin
                                if (select COUNT(*)
                                    from msdb.dbo.sysalerts
                                    where severity between 19 and 25
                                   ) < 7
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 30) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 30                                                                                                                                                                                           as checkid,
                                               200                                                                                                                                                                                          as priority,
                                               'Monitoring'                                                                                                                                                                                 as findingsgroup,
                                               'Not All Alerts Configured'                                                                                                                                                                  as finding,
                                               'https://BrentOzar.com/go/alert'                                                                                                                                                             as url,
                                               ('Not all SQL Server Agent alerts have been configured.  This is a free, easy way to get notified of corruption, job failures, or major outages even before monitoring systems pick it up.') as details;
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 59)
                            begin
                                if EXISTS(select *
                                          from msdb.dbo.sysalerts
                                          where enabled = 1
                                            and COALESCE(has_notification, 0) = 0
                                            and (job_id is null or job_id = 0 x))
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 59) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 59                                                                                                                                                                                                                                                            as checkid,
                                               200                                                                                                                                                                                                                                                           as priority,
                                               'Monitoring'                                                                                                                                                                                                                                                  as findingsgroup,
                                               'Alerts Configured without Follow Up'                                                                                                                                                                                                                         as finding,
                                               'https://BrentOzar.com/go/alert'                                                                                                                                                                                                                              as url,
                                               ('SQL Server Agent alerts have been configured but they either do not notify anyone or else they do not take any action.  This is a free, easy way to get notified of corruption, job failures, or major outages even before monitoring systems pick it up.') as details;

                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 96)
                            begin
                                if not EXISTS(select *
                                              from msdb.dbo.sysalerts
                                              where message_id in (823, 824, 825))
                                    begin
                                        ;

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 96) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 96                                                                                                                                                                                                    as checkid,
                                               200                                                                                                                                                                                                   as priority,
                                               'Monitoring'                                                                                                                                                                                          as findingsgroup,
                                               'No Alerts for Corruption'                                                                                                                                                                            as finding,
                                               'https://BrentOzar.com/go/alert'                                                                                                                                                                      as url,
                                               ('SQL Server Agent alerts do not exist for errors 823, 824, and 825.  These three errors can give you notification about early hardware failure. Enabling them can prevent you a lot of heartbreak.') as details;

                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 61)
                            begin
                                if not EXISTS(select *
                                              from msdb.dbo.sysalerts
                                              where severity between 19 and 25)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 61) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 61                                                                                                                                                                                                  as checkid,
                                               200                                                                                                                                                                                                 as priority,
                                               'Monitoring'                                                                                                                                                                                        as findingsgroup,
                                               'No Alerts for Sev 19-25'                                                                                                                                                                           as finding,
                                               'https://BrentOzar.com/go/alert'                                                                                                                                                                    as url,
                                               ('SQL Server Agent alerts do not exist for severity levels 19 through 25.  These are some very severe SQL Server errors. Knowing that these are happening may let you recover from errors faster.') as details;

                                    end;

                            end;

                        --check for disabled alerts
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 98)
                            begin
                                if EXISTS(select name
                                          from msdb.dbo.sysalerts
                                          where enabled = 0)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 98) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 98                               as checkid,
                                               200                              as priority,
                                               'Monitoring'                     as findingsgroup,
                                               'Alerts Disabled'                as finding,
                                               'https://BrentOzar.com/go/alert' as url,
                                               ('The following Alert is disabled, please review and enable if desired: '
                                                   + name)                      as details
                                        from msdb.dbo.sysalerts
                                        where enabled = 0;
                                    end;
                            end;

                        --check for alerts that do NOT include event descriptions in their outputs via email/pager/net-send
                        if not EXISTS(
                                select 1
                                from #skipchecks
                                where databasename is null
                                  and checkid = 219
                            )
                            begin
                                ;
                                if @debug in (1, 2)
                                    begin
                                        ;
                                        raiserror ('Running CheckId [%d].', 0, 1, 219) with nowait;
                                    end;

                                insert into #blitzresults ( checkid
                                                          , [Priority]
                                                          , findingsgroup
                                                          , finding
                                                          , [URL]
                                                          , details)
                                select 219                                                                                    as checkid
                                     , 200                                                                                    as [Priority]
                                     , 'Monitoring'                                                                           as findingsgroup
                                     , 'Alerts Without Event Descriptions'                                                    as finding
                                     , 'https://BrentOzar.com/go/alert'                                                       as [URL]
                                     , ('The following Alert is not including detailed event descriptions in its output messages: ' +
                                        QUOTENAME([name])
                                    +
                                        '. You can fix it by ticking the relevant boxes in its Properties --> Options page.') as details
                                from msdb.dbo.sysalerts
                                where [enabled] = 1
                                  and include_event_description = 0 --bitmask: 1 = email, 2 = pager, 4 = net send
                                ;
                            end;

                        --check whether we have NO ENABLED operators!
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 31)
                            begin
                                ;
                                if not EXISTS(select *
                                              from msdb.dbo.sysoperators
                                              where enabled = 1)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 31) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 31                                                                                                                                                                                                  as checkid,
                                               200                                                                                                                                                                                                 as priority,
                                               'Monitoring'                                                                                                                                                                                        as findingsgroup,
                                               'No Operators Configured/Enabled'                                                                                                                                                                   as finding,
                                               'https://BrentOzar.com/go/op'                                                                                                                                                                       as url,
                                               ('No SQL Server Agent operators (emails) have been configured.  This is a free, easy way to get notified of corruption, job failures, or major outages even before monitoring systems pick it up.') as details;

                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 34)
                            begin
                                if EXISTS(select *
                                          from sys.all_objects
                                          where name = 'dm_db_mirroring_auto_page_repair')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 34) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT DISTINCT
		  34 AS CheckID ,
		  db.name ,
		  1 AS Priority ,
		  ''Corruption'' AS FindingsGroup ,
		  ''Database Corruption Detected'' AS Finding ,
		  ''https://BrentOzar.com/go/repair'' AS URL ,
		  ( ''Database mirroring has automatically repaired at least one corrupt page in the last 30 days. For more information, query the DMV sys.dm_db_mirroring_auto_page_repair.'' ) AS Details
		  FROM (SELECT rp2.database_id, rp2.modification_time
			FROM sys.dm_db_mirroring_auto_page_repair rp2
			WHERE rp2.[database_id] not in (
			SELECT db2.[database_id]
			FROM sys.databases as db2
			WHERE db2.[state] = 1
			) ) as rp
		  INNER JOIN master.sys.databases db ON rp.database_id = db.database_id
		  WHERE   rp.modification_time >= DATEADD(dd, -30, GETDATE())  OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 89)
                            begin
                                if EXISTS(select *
                                          from sys.all_objects
                                          where name = 'dm_hadr_auto_page_repair')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 89) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT DISTINCT
		  89 AS CheckID ,
		  db.name ,
		  1 AS Priority ,
		  ''Corruption'' AS FindingsGroup ,
		  ''Database Corruption Detected'' AS Finding ,
		  ''https://BrentOzar.com/go/repair'' AS URL ,
		  ( ''Availability Groups has automatically repaired at least one corrupt page in the last 30 days. For more information, query the DMV sys.dm_hadr_auto_page_repair.'' ) AS Details
		  FROM    sys.dm_hadr_auto_page_repair rp
		  INNER JOIN master.sys.databases db ON rp.database_id = db.database_id
		  WHERE   rp.modification_time >= DATEADD(dd, -30, GETDATE()) OPTION (RECOMPILE) ;';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 90)
                            begin
                                if EXISTS(select *
                                          from msdb.sys.all_objects
                                          where name = 'suspect_pages')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 90) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT DISTINCT
		  90 AS CheckID ,
		  db.name ,
		  1 AS Priority ,
		  ''Corruption'' AS FindingsGroup ,
		  ''Database Corruption Detected'' AS Finding ,
		  ''https://BrentOzar.com/go/repair'' AS URL ,
		  ( ''SQL Server has detected at least one corrupt page in the last 30 days. For more information, query the system table msdb.dbo.suspect_pages.'' ) AS Details
		  FROM    msdb.dbo.suspect_pages sp
		  INNER JOIN master.sys.databases db ON sp.database_id = db.database_id
		  WHERE   sp.last_update_date >= DATEADD(dd, -30, GETDATE())  OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 36)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 36) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select distinct 36                                                                                                                                                            as checkid,
                                                150                                                                                                                                                           as priority,
                                                'Performance'                                                                                                                                                 as findingsgroup,
                                                'Slow Storage Reads on Drive '
                                                    +
                                                UPPER(LEFT(mf.physical_name, 1))                                                                                                                              as finding,
                                                'https://BrentOzar.com/go/slow'                                                                                                                               as url,
                                                'Reads are averaging longer than 200ms for at least one database on this drive.  For specific database file speeds, run the query from the information link.' as details
                                from sys.dm_io_virtual_file_stats(null, null)
                                         as fs
                                         inner join sys.master_files as mf on fs.database_id = mf.database_id
                                    and fs.[file_id] = mf.[file_id]
                                where (io_stall_read_ms / (1.0 + num_of_reads)) > 200
                                  and num_of_reads > 100000;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 37)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 37) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select distinct 37                                                                                                                                                             as checkid,
                                                150                                                                                                                                                            as priority,
                                                'Performance'                                                                                                                                                  as findingsgroup,
                                                'Slow Storage Writes on Drive '
                                                    +
                                                UPPER(LEFT(mf.physical_name, 1))                                                                                                                               as finding,
                                                'https://BrentOzar.com/go/slow'                                                                                                                                as url,
                                                'Writes are averaging longer than 100ms for at least one database on this drive.  For specific database file speeds, run the query from the information link.' as details
                                from sys.dm_io_virtual_file_stats(null, null)
                                         as fs
                                         inner join sys.master_files as mf on fs.database_id = mf.database_id
                                    and fs.[file_id] = mf.[file_id]
                                where (io_stall_write_ms / (1.0
                                    + num_of_writes)) > 100
                                  and num_of_writes > 100000;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 40)
                            begin
                                if (select COUNT(*)
                                    from tempdb.sys.database_files
                                    where type_desc = 'ROWS'
                                   ) = 1
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 40) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         databasename,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        values (40,
                                                'tempdb',
                                                170,
                                                'File Configuration',
                                                'TempDB Only Has 1 Data File',
                                                'https://BrentOzar.com/go/tempdb',
                                                'TempDB is only configured with one data file.  More data files are usually required to alleviate SGAM contention.');
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 183)
                            begin

                                if (select COUNT(distinct [size])
                                    from tempdb.sys.database_files
                                    where type_desc = 'ROWS'
                                    having MAX((size * 8) / (1024. * 1024)) - MIN((size * 8) / (1024. * 1024)) > 1.
                                   ) <> 1
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 183) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         databasename,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        values (183,
                                                'tempdb',
                                                170,
                                                'File Configuration',
                                                'TempDB Unevenly Sized Data Files',
                                                'https://BrentOzar.com/go/tempdb',
                                                'TempDB data files are not configured with the same size.  Unevenly sized tempdb data files will result in unevenly sized workloads.');
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 44)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 44) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 44                                                                                                                                                                                                                                                                               as checkid,
                                       150                                                                                                                                                                                                                                                                              as priority,
                                       'Performance'                                                                                                                                                                                                                                                                    as findingsgroup,
                                       'Queries Forcing Order Hints'                                                                                                                                                                                                                                                    as finding,
                                       'https://BrentOzar.com/go/hints'                                                                                                                                                                                                                                                 as url,
                                       CAST(occurrence as varchar(10))
                                           +
                                       ' instances of order hinting have been recorded since restart.  This means queries are bossing the SQL Server optimizer around, and if they don''t know what they''re doing, this can cause more harm than good.  This can also explain why DBA tuning efforts aren''t working.' as details
                                from sys.dm_exec_query_optimizer_info
                                where counter = 'order hint'
                                  and occurrence > 1000;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 45)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 45) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 45                                                                                                                                                                                                                                                                              as checkid,
                                       150                                                                                                                                                                                                                                                                             as priority,
                                       'Performance'                                                                                                                                                                                                                                                                   as findingsgroup,
                                       'Queries Forcing Join Hints'                                                                                                                                                                                                                                                    as finding,
                                       'https://BrentOzar.com/go/hints'                                                                                                                                                                                                                                                as url,
                                       CAST(occurrence as varchar(10))
                                           +
                                       ' instances of join hinting have been recorded since restart.  This means queries are bossing the SQL Server optimizer around, and if they don''t know what they''re doing, this can cause more harm than good.  This can also explain why DBA tuning efforts aren''t working.' as details
                                from sys.dm_exec_query_optimizer_info
                                where counter = 'join hint'
                                  and occurrence > 1000;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 49)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 49) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select distinct 49                              as checkid,
                                                200                             as priority,
                                                'Informational'                 as findingsgroup,
                                                'Linked Server Configured'      as finding,
                                                'https://BrentOzar.com/go/link' as url,
                                                +case
                                                     when l.remote_name = 'sa'
                                                         then COALESCE(s.data_source, s.provider)
                                                         +
                                                              ' is configured as a linked server. Check its security configuration as it is connecting with sa, because any user who queries it will get admin-level permissions.'
                                                     else COALESCE(s.data_source, s.provider)
                                                         +
                                                          ' is configured as a linked server. Check its security configuration to make sure it isn''t connecting with SA or some other bone-headed administrative login, because any user who queries it might get admin-level permissions.'
                                                    end                         as details
                                from sys.servers s
                                         inner join sys.linked_logins l on s.server_id = l.server_id
                                where s.is_linked = 1;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 50)
                            begin
                                if @@VERSION not like '%Microsoft SQL Server 2000%'
                                    and @@VERSION not like '%Microsoft SQL Server 2005%'
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 50) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
		  SELECT  50 AS CheckID ,
		  100 AS Priority ,
		  ''Performance'' AS FindingsGroup ,
		  ''Max Memory Set Too High'' AS Finding ,
		  ''https://BrentOzar.com/go/max'' AS URL ,
		  ''SQL Server max memory is set to ''
			+ CAST(c.value_in_use AS VARCHAR(20))
			+ '' megabytes, but the server only has ''
			+ CAST(( CAST(m.total_physical_memory_kb AS BIGINT) / 1024 ) AS VARCHAR(20))
			+ '' megabytes.  SQL Server may drain the system dry of memory, and under certain conditions, this can cause Windows to swap to disk.'' AS Details
		  FROM    sys.dm_os_sys_memory m
		  INNER JOIN sys.configurations c ON c.name = ''max server memory (MB)''
		  WHERE   CAST(m.total_physical_memory_kb AS BIGINT) < ( CAST(c.value_in_use AS BIGINT) * 1024 ) OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 51)
                            begin
                                if @@VERSION not like '%Microsoft SQL Server 2000%'
                                    and @@VERSION not like '%Microsoft SQL Server 2005%'
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 51) with nowait

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
		  SELECT  51 AS CheckID ,
		  1 AS Priority ,
		  ''Performance'' AS FindingsGroup ,
		  ''Memory Dangerously Low'' AS Finding ,
		  ''https://BrentOzar.com/go/max'' AS URL ,
		  ''The server has '' + CAST(( CAST(m.total_physical_memory_kb AS BIGINT) / 1024 ) AS VARCHAR(20)) + '' megabytes of physical memory, but only '' + CAST(( CAST(m.available_physical_memory_kb AS BIGINT) / 1024 ) AS VARCHAR(20))
			+ '' megabytes are available.  As the server runs out of memory, there is danger of swapping to disk, which will kill performance.'' AS Details
		  FROM    sys.dm_os_sys_memory m
		  WHERE   CAST(m.available_physical_memory_kb AS BIGINT) < 262144 OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 159)
                            begin
                                if @@VERSION not like '%Microsoft SQL Server 2000%'
                                    and @@VERSION not like '%Microsoft SQL Server 2005%'
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 159) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
		  SELECT DISTINCT 159 AS CheckID ,
		  1 AS Priority ,
		  ''Performance'' AS FindingsGroup ,
		  ''Memory Dangerously Low in NUMA Nodes'' AS Finding ,
		  ''https://BrentOzar.com/go/max'' AS URL ,
		  ''At least one NUMA node is reporting THREAD_RESOURCES_LOW in sys.dm_os_nodes and can no longer create threads.'' AS Details
		  FROM    sys.dm_os_nodes m
		  WHERE   node_state_desc LIKE ''%THREAD_RESOURCES_LOW%'' OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 53)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 53) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select top 1 53                              as checkid,
                                             200                             as priority,
                                             'Informational'                 as findingsgroup,
                                             'Cluster Node'                  as finding,
                                             'https://BrentOzar.com/go/node' as url,
                                             'This is a node in a cluster.'  as details
                                from sys.dm_os_cluster_nodes;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 55)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 55) with nowait;

                                if @usualdbowner is null
                                    set @usualdbowner = SUSER_SNAME(0x01);

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 55                                             as checkid,
                                       [name]                                         as databasename,
                                       230                                            as priority,
                                       'Security'                                     as findingsgroup,
                                       'Database Owner <> ' + @usualdbowner           as finding,
                                       'https://BrentOzar.com/go/owndb'               as url,
                                       ('Database name: ' + [name] + '   '
                                           + 'Owner name: ' + SUSER_SNAME(owner_sid)) as details
                                from sys.databases
                                where (((SUSER_SNAME(owner_sid) <> SUSER_SNAME(0x01)) and
                                        (name in (N'master', N'model', N'msdb', N'tempdb')))
                                    or ((SUSER_SNAME(owner_sid) <> @usualdbowner) and
                                        (name not in (N'master', N'model', N'msdb', N'tempdb')))
                                    )
                                  and name not in (select distinct databasename
                                                   from #skipchecks
                                                   where checkid is null
                                                      or checkid = 55);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 213)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 213) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 213                                                                     as checkid,
                                       [name]                                                                  as databasename,
                                       230                                                                     as priority,
                                       'Security'                                                              as findingsgroup,
                                       'Database Owner is Unknown'                                             as finding,
                                       ''                                                                      as url,
                                       ('Database name: ' + [name] + '   '
                                           + 'Owner name: ' +
                                        ISNULL(SUSER_SNAME(owner_sid), '~~ UNKNOWN ~~'))                       as details
                                from sys.databases
                                where SUSER_SNAME(owner_sid) is null
                                  and name not in (select distinct databasename
                                                   from #skipchecks
                                                   where checkid is null
                                                      or checkid = 213);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 57)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 57) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 57                                                                                                                                                   as checkid,
                                       230                                                                                                                                                  as priority,
                                       'Security'                                                                                                                                           as findingsgroup,
                                       'SQL Agent Job Runs at Startup'                                                                                                                      as finding,
                                       'https://BrentOzar.com/go/startup'                                                                                                                   as url,
                                       ('Job [' + j.name
                                           +
                                        '] runs automatically when SQL Server Agent starts up.  Make sure you know exactly what this job is doing, because it could pose a security risk.') as details
                                from msdb.dbo.sysschedules sched
                                         join msdb.dbo.sysjobschedules jsched on sched.schedule_id = jsched.schedule_id
                                         join msdb.dbo.sysjobs j on jsched.job_id = j.job_id
                                where sched.freq_type = 64
                                  and sched.enabled = 1;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 97)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 97) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 97                                                           as checkid,
                                       100                                                          as priority,
                                       'Performance'                                                as findingsgroup,
                                       'Unusual SQL Server Edition'                                 as finding,
                                       'https://BrentOzar.com/go/workgroup'                         as url,
                                       ('This server is using '
                                           + CAST(SERVERPROPERTY('edition') as varchar(100))
                                           + ', which is capped at low amounts of CPU and memory.') as details
                                where CAST(SERVERPROPERTY('edition') as varchar(100)) not like '%Standard%'
                                  and CAST(SERVERPROPERTY('edition') as varchar(100)) not like '%Enterprise%'
                                  and CAST(SERVERPROPERTY('edition') as varchar(100)) not like '%Data Center%'
                                  and CAST(SERVERPROPERTY('edition') as varchar(100)) not like '%Developer%'
                                  and CAST(SERVERPROPERTY('edition') as varchar(100)) not like
                                      '%Business Intelligence%';
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 154)
                            and SERVERPROPERTY('EngineEdition') <> 8
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 154) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 154                                                                                                                                                                                        as checkid,
                                       10                                                                                                                                                                                         as priority,
                                       'Performance'                                                                                                                                                                              as findingsgroup,
                                       '32-bit SQL Server Installed'                                                                                                                                                              as finding,
                                       'https://BrentOzar.com/go/32bit'                                                                                                                                                           as url,
                                       ('This server uses the 32-bit x86 binaries for SQL Server instead of the 64-bit x64 binaries. The amount of memory available for query workspace and execution plans is heavily limited.') as details
                                where CAST(SERVERPROPERTY('edition') as varchar(100)) not like '%64%';
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 62)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 62) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 62                                                                                                as checkid,
                                       [name]                                                                                            as databasename,
                                       200                                                                                               as priority,
                                       'Performance'                                                                                     as findingsgroup,
                                       'Old Compatibility Level'                                                                         as finding,
                                       'https://BrentOzar.com/go/compatlevel'                                                            as url,
                                       ('Database ' + [name]
                                           + ' is compatibility level '
                                           + CAST(compatibility_level as varchar(20))
                                           +
                                        ', which may cause unwanted results when trying to run queries that have newer T-SQL features.') as details
                                from sys.databases
                                where name not in (select distinct databasename
                                                   from #skipchecks
                                                   where checkid is null
                                                      or checkid = 62)
                                  and compatibility_level <= 90;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 94)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 94) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 94                                                              as checkid,
                                       200                                                             as [Priority],
                                       'Monitoring'                                                    as findingsgroup,
                                       'Agent Jobs Without Failure Emails'                             as finding,
                                       'https://BrentOzar.com/go/alerts'                               as url,
                                       'The job ' + [name]
                                           + ' has not been set up to notify an operator if it fails.' as details
                                from msdb.[dbo].[sysjobs] j
                                         inner join (select distinct [job_id]
                                                     from [msdb].[dbo].[sysjobschedules]
                                                     where next_run_date > 0
                                ) s on j.job_id = s.job_id
                                where j.enabled = 1
                                  and j.notify_email_operator_id = 0
                                  and j.notify_netsend_operator_id = 0
                                  and j.notify_page_operator_id = 0
                                  and j.category_id <> 100; /* Exclude SSRS category */
                            end;

                        if EXISTS(select 1
                                  from sys.configurations
                                  where name = 'remote admin connections'
                                    and value_in_use = 0)
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 100)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 100) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 100                            as checkid,
                                       50                             as priority,
                                       'Reliability'                  as findinggroup,
                                       'Remote DAC Disabled'          as finding,
                                       'https://BrentOzar.com/go/dac' as url,
                                       'Remote access to the Dedicated Admin Connection (DAC) is not enabled. The DAC can make remote troubleshooting much easier when SQL Server is unresponsive.';
                            end;

                        if EXISTS(select *
                                  from sys.dm_os_schedulers
                                  where is_online = 0)
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 101)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 101) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 101                                   as checkid,
                                       50                                    as priority,
                                       'Performance'                         as findinggroup,
                                       'CPU Schedulers Offline'              as finding,
                                       'https://BrentOzar.com/go/schedulers' as url,
                                       'Some CPU cores are not accessible to SQL Server due to affinity masking or licensing problems.';
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 110)
                            and EXISTS(select * from master.sys.all_objects where name = 'dm_os_memory_nodes')
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 110) with nowait;

                                set @stringtoexecute = 'IF EXISTS (SELECT  *
												FROM sys.dm_os_nodes n
												INNER JOIN sys.dm_os_memory_nodes m ON n.memory_node_id = m.memory_node_id
												WHERE n.node_state_desc = ''OFFLINE'')
												INSERT  INTO #BlitzResults
														( CheckID ,
														  Priority ,
														  FindingsGroup ,
														  Finding ,
														  URL ,
														  Details
														)
														SELECT  110 AS CheckID ,
																50 AS Priority ,
																''Performance'' AS FindingGroup ,
																''Memory Nodes Offline'' AS Finding ,
																''https://BrentOzar.com/go/schedulers'' AS URL ,
																''Due to affinity masking or licensing problems, some of the memory may not be available.'' OPTION (RECOMPILE)';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);
                            end;

                        if EXISTS(select *
                                  from sys.databases
                                  where state > 1)
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 102)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 102) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 102                                       as checkid,
                                       [name],
                                       20                                        as priority,
                                       'Reliability'                             as findinggroup,
                                       'Unusual Database State: ' + [state_desc] as finding,
                                       'https://BrentOzar.com/go/repair'         as url,
                                       'This database may not be online.'
                                from sys.databases
                                where state > 1;
                            end;

                        if EXISTS(select *
                                  from master.sys.extended_procedures)
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 105)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 105) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 105                                    as checkid,
                                       'master',
                                       200                                    as priority,
                                       'Reliability'                          as findinggroup,
                                       'Extended Stored Procedures in Master' as finding,
                                       'https://BrentOzar.com/go/clr'         as url,
                                       'The [' + name
                                           +
                                       '] extended stored procedure is in the master database. CLR may be in use, and the master database now needs to be part of your backup/recovery planning.'
                                from master.sys.extended_procedures;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 107)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 107) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 107                                             as checkid,
                                       50                                              as priority,
                                       'Performance'                                   as findinggroup,
                                       'Poison Wait Detected: ' + wait_type            as finding,
                                       'https://BrentOzar.com/go/poison/#' + wait_type as url,
                                       CONVERT(varchar(10), (SUM([wait_time_ms]) / 1000) / 86400) + ':' +
                                       CONVERT(varchar(20), DATEADD(s, (SUM([wait_time_ms]) / 1000), 0), 108) +
                                       ' of this wait have been recorded. This wait often indicates killer performance problems.'
                                from sys.[dm_os_wait_stats]
                                where wait_type in
                                      ('IO_QUEUE_LIMIT', 'IO_RETRY', 'LOG_RATE_GOVERNOR', 'POOL_LOG_RATE_GOVERNOR',
                                       'PREEMPTIVE_DEBUG', 'RESMGR_THROTTLED', 'RESOURCE_SEMAPHORE',
                                       'RESOURCE_SEMAPHORE_QUERY_COMPILE', 'SE_REPL_CATCHUP_THROTTLE',
                                       'SE_REPL_COMMIT_ACK', 'SE_REPL_COMMIT_TURN', 'SE_REPL_ROLLBACK_ACK',
                                       'SE_REPL_SLOW_SECONDARY_THROTTLE', 'THREADPOOL')
                                group by wait_type
                                having SUM([wait_time_ms]) >
                                       (select 5000 * datediff(hh, create_date, CURRENT_TIMESTAMP) as hours_since_startup
                                        from sys.databases
                                        where name = 'tempdb')
                                   and SUM([wait_time_ms]) > 60000;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 121)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 121) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 121                                          as checkid,
                                       50                                           as priority,
                                       'Performance'                                as findinggroup,
                                       'Poison Wait Detected: Serializable Locking' as finding,
                                       'https://BrentOzar.com/go/serializable'      as url,
                                       CONVERT(varchar(10), (SUM([wait_time_ms]) / 1000) / 86400) + ':' +
                                       CONVERT(varchar(20), DATEADD(s, (SUM([wait_time_ms]) / 1000), 0), 108) +
                                       ' of LCK_M_R% waits have been recorded. This wait often indicates killer performance problems.'
                                from sys.[dm_os_wait_stats]
                                where wait_type in
                                      ('LCK_M_RS_S', 'LCK_M_RS_U', 'LCK_M_RIn_NL', 'LCK_M_RIn_S', 'LCK_M_RIn_U',
                                       'LCK_M_RIn_X', 'LCK_M_RX_S', 'LCK_M_RX_U', 'LCK_M_RX_X')
                                having SUM([wait_time_ms]) >
                                       (select 5000 * datediff(hh, create_date, CURRENT_TIMESTAMP) as hours_since_startup
                                        from sys.databases
                                        where name = 'tempdb')
                                   and SUM([wait_time_ms]) > 60000;
                            end;


                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 111)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 111) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 databasename,
                                 url,
                                 details)
                                select 111                                 as checkid,
                                       50                                  as priority,
                                       'Reliability'                       as findinggroup,
                                       'Possibly Broken Log Shipping'      as finding,
                                       d.[name],
                                       'https://BrentOzar.com/go/shipping' as url,
                                       d.[name] +
                                       ' is in a restoring state, but has not had a backup applied in the last two days. This is a possible indication of a broken transaction log shipping setup.'
                                from [master].sys.databases d
                                         inner join [master].sys.database_mirroring dm on d.database_id = dm.database_id
                                    and dm.mirroring_role is null
                                where (d.[state] = 1
                                    or (d.[state] = 0 and d.[is_in_standby] = 1))
                                  and not EXISTS(select *
                                                 from msdb.dbo.restorehistory rh
                                                          inner join msdb.dbo.backupset bs on rh.backup_set_id = bs.backup_set_id
                                                 where d.[name] collate sql_latin1_general_cp1_ci_as =
                                                       rh.destination_database_name collate sql_latin1_general_cp1_ci_as
                                                   and rh.restore_date >= DATEADD(dd, -2, GETDATE()));

                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 112)
                            and EXISTS(select * from master.sys.all_objects where name = 'change_tracking_databases')
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 112) with nowait;

                                set @stringtoexecute = 'INSERT INTO #BlitzResults
									(CheckID,
									Priority,
									FindingsGroup,
									Finding,
									DatabaseName,
									URL,
									Details)
							  SELECT 112 AS CheckID,
							  100 AS Priority,
							  ''Performance'' AS FindingsGroup,
							  ''Change Tracking Enabled'' AS Finding,
							  d.[name],
							  ''https://BrentOzar.com/go/tracking'' AS URL,
							  ( d.[name] + '' has change tracking enabled. This is not a default setting, and it has some performance overhead. It keeps track of changes to rows in tables that have change tracking turned on.'' ) AS Details FROM sys.change_tracking_databases AS ctd INNER JOIN sys.databases AS d ON ctd.database_id = d.database_id OPTION (RECOMPILE)';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 116)
                            and EXISTS(select * from msdb.sys.all_columns where name = 'compressed_backup_size')
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 116) with nowait

                                set @stringtoexecute = 'INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  116 AS CheckID ,
											200 AS Priority ,
											''Informational'' AS FindingGroup ,
											''Backup Compression Default Off''  AS Finding ,
											''https://BrentOzar.com/go/backup'' AS URL ,
											''Uncompressed full backups have happened recently, and backup compression is not turned on at the server level. Backup compression is included with SQL Server 2008R2 & newer, even in Standard Edition. We recommend turning backup compression on by default so that ad-hoc backups will get compressed.''
											FROM sys.configurations
											WHERE configuration_id = 1579 AND CAST(value_in_use AS INT) = 0
                                            AND EXISTS (SELECT * FROM msdb.dbo.backupset WHERE backup_size = compressed_backup_size AND type = ''D'' AND backup_finish_date >= DATEADD(DD, -14, GETDATE())) OPTION (RECOMPILE);';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 117)
                            and
                           EXISTS(select * from master.sys.all_objects where name = 'dm_exec_query_resource_semaphores')
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 117) with nowait;

                                set @stringtoexecute = 'IF 0 < (SELECT SUM([forced_grant_count]) FROM sys.dm_exec_query_resource_semaphores WHERE [forced_grant_count] IS NOT NULL)
								INSERT INTO #BlitzResults
									(CheckID,
									Priority,
									FindingsGroup,
									Finding,
									URL,
									Details)
							  SELECT 117 AS CheckID,
							  100 AS Priority,
							  ''Performance'' AS FindingsGroup,
							  ''Memory Pressure Affecting Queries'' AS Finding,
							  ''https://BrentOzar.com/go/grants'' AS URL,
							  CAST(SUM(forced_grant_count) AS NVARCHAR(100)) + '' forced grants reported in the DMV sys.dm_exec_query_resource_semaphores, indicating memory pressure has affected query runtimes.''
							  FROM sys.dm_exec_query_resource_semaphores WHERE [forced_grant_count] IS NOT NULL OPTION (RECOMPILE);';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 124)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 124) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 124,
                                       150,
                                       'Performance',
                                       'Deadlocks Happening Daily',
                                       'https://BrentOzar.com/go/deadlocks',
                                       CAST(CAST(p.cntr_value / @daysuptime as bigint) as nvarchar(100)) +
                                       ' average deadlocks per day. To find them, run sp_BlitzLock.' as details
                                from sys.dm_os_performance_counters p
                                         inner join sys.databases d on d.name = 'tempdb'
                                where RTRIM(p.counter_name) = 'Number of Deadlocks/sec'
                                  and RTRIM(p.instance_name) = '_Total'
                                  and p.cntr_value > 0
                                  and (1.0 * p.cntr_value / NULLIF(datediff(dd, create_date, CURRENT_TIMESTAMP), 0)) >
                                      10;
                            end;

                        if DATEADD(mi, -15, GETDATE()) <
                           (select top 1 creation_time from sys.dm_exec_query_stats order by creation_time)
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 125)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 125) with nowait;

                                declare @user_perm_sql nvarchar(max) = N'';
                                declare @user_perm_gb_out decimal(38, 2);

                                if @productversionmajor >= 11
                                    begin

                                        set @user_perm_sql += N'
									SELECT @user_perm_gb = CASE WHEN (pages_kb / 128.0 / 1024.) >= 2.
											THEN CONVERT(DECIMAL(38, 2), (pages_kb / 128.0 / 1024.))
											ELSE NULL
										   END
									FROM sys.dm_os_memory_clerks
									WHERE type = ''USERSTORE_TOKENPERM''
									AND    name = ''TokenAndPermUserStore''
								';

                                    end

                                if @productversionmajor < 11
                                    begin
                                        set @user_perm_sql += N'
									SELECT @user_perm_gb = CASE WHEN ((single_pages_kb + multi_pages_kb) / 1024.0 / 1024.) >= 2.
											THEN CONVERT(DECIMAL(38, 2), ((single_pages_kb + multi_pages_kb)  / 1024.0 / 1024.))
											ELSE NULL
										   END
									FROM sys.dm_os_memory_clerks
									WHERE type = ''USERSTORE_TOKENPERM''
									AND    name = ''TokenAndPermUserStore''
								';

                                    end

                                exec sys.sp_executesql @user_perm_sql,
                                     N'@user_perm_gb DECIMAL(38,2) OUTPUT',
                                     @user_perm_gb = @user_perm_gb_out output

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select top 1 125,
                                             10,
                                             'Performance',
                                             'Plan Cache Erased Recently',
                                             'https://BrentOzar.com/askbrent/plan-cache-erased-recently/',
                                             'The oldest query in the plan cache was created at ' +
                                             CAST(creation_time as nvarchar(50))
                                                 + case
                                                       when @user_perm_gb_out is null
                                                           then '. Someone ran DBCC FREEPROCCACHE, restarted SQL Server, or it is under horrific memory pressure.'
                                                       else '. You also have ' +
                                                            CONVERT(nvarchar(20), @user_perm_gb_out) +
                                                            ' GB of USERSTORE_TOKENPERM, which could indicate unusual memory consumption.'
                                                 end
                                from sys.dm_exec_query_stats with (nolock)
                                order by creation_time;
                            end;

                        if EXISTS(select * from sys.configurations where name = 'priority boost'
                                                                     and (value = 1 or value_in_use = 1))
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 126)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 126) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                values (126, 5, 'Reliability', 'Priority Boost Enabled',
                                        'https://BrentOzar.com/go/priorityboost/',
                                        'Priority Boost sounds awesome, but it can actually cause your SQL Server to crash.');
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 128)
                            and SERVERPROPERTY('EngineEdition') <> 8 /* Azure Managed Instances */
                            begin

                                if (@productversionmajor = 15 and @productversionminor < 2000) or
                                   (@productversionmajor = 14 and @productversionminor < 1000) or
                                   (@productversionmajor = 13 and @productversionminor < 5026) or
                                   (@productversionmajor = 12 and @productversionminor < 6024) or
                                   (@productversionmajor = 11 and @productversionminor < 7001) or
                                   (@productversionmajor = 10.5 /*AND @ProductVersionMinor < 6000*/) or
                                   (@productversionmajor = 10 /*AND @ProductVersionMinor < 6000*/) or
                                   (@productversionmajor = 9 /*AND @ProductVersionMinor <= 5000*/)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 128) with nowait;

                                        insert into #blitzresults(checkid, priority, findingsgroup, finding, url, details)
                                        values (128, 20, 'Reliability', 'Unsupported Build of SQL Server',
                                                'https://BrentOzar.com/go/unsupported',
                                                'Version ' + CAST(@productversionmajor as varchar(100)) +
                                                case
                                                    when @productversionmajor >= 11 then
                                                            '.' + CAST(@productversionminor as varchar(100)) +
                                                            ' is no longer supported by Microsoft. You need to apply a service pack.'
                                                    else ' is no longer supported by Microsoft. You should be making plans to upgrade to a modern version of SQL Server.' end);
                                    end;

                            end;

                        /* Reliability - Dangerous Build of SQL Server (Corruption) */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 129)
                            and SERVERPROPERTY('EngineEdition') <> 8 /* Azure Managed Instances */
                            begin
                                if (@productversionmajor = 11 and @productversionminor >= 3000 and
                                    @productversionminor <= 3436) or
                                   (@productversionmajor = 11 and @productversionminor = 5058) or
                                   (@productversionmajor = 12 and @productversionminor >= 2000 and
                                    @productversionminor <= 2342)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 129) with nowait;

                                        insert into #blitzresults(checkid, priority, findingsgroup, finding, url, details)
                                        values (129, 20, 'Reliability', 'Dangerous Build of SQL Server (Corruption)',
                                                'http://sqlperformance.com/2014/06/sql-indexes/hotfix-sql-2012-rebuilds',
                                                'There are dangerous known bugs with version ' +
                                                CAST(@productversionmajor as varchar(100)) + '.' +
                                                CAST(@productversionminor as varchar(100)) +
                                                '. Check the URL for details and apply the right service pack or hotfix.');
                                    end;

                            end;

                        /* Reliability - Dangerous Build of SQL Server (Security) */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 157)
                            and SERVERPROPERTY('EngineEdition') <> 8 /* Azure Managed Instances */
                            begin
                                if (@productversionmajor = 10 and @productversionminor >= 5500 and
                                    @productversionminor <= 5512) or
                                   (@productversionmajor = 10 and @productversionminor >= 5750 and
                                    @productversionminor <= 5867) or
                                   (@productversionmajor = 10.5 and @productversionminor >= 4000 and
                                    @productversionminor <= 4017) or
                                   (@productversionmajor = 10.5 and @productversionminor >= 4251 and
                                    @productversionminor <= 4319) or
                                   (@productversionmajor = 11 and @productversionminor >= 3000 and
                                    @productversionminor <= 3129) or
                                   (@productversionmajor = 11 and @productversionminor >= 3300 and
                                    @productversionminor <= 3447) or
                                   (@productversionmajor = 12 and @productversionminor >= 2000 and
                                    @productversionminor <= 2253) or
                                   (@productversionmajor = 12 and @productversionminor >= 2300 and
                                    @productversionminor <= 2370)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 157) with nowait;

                                        insert into #blitzresults(checkid, priority, findingsgroup, finding, url, details)
                                        values (157, 20, 'Reliability', 'Dangerous Build of SQL Server (Security)',
                                                'https://technet.microsoft.com/en-us/library/security/MS14-044',
                                                'There are dangerous known bugs with version ' +
                                                CAST(@productversionmajor as varchar(100)) + '.' +
                                                CAST(@productversionminor as varchar(100)) +
                                                '. Check the URL for details and apply the right service pack or hotfix.');
                                    end;

                            end;

                        /* Check if SQL 2016 Standard Edition but not SP1 */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 189)
                            and SERVERPROPERTY('EngineEdition') <> 8 /* Azure Managed Instances */
                            begin
                                if (@productversionmajor = 13 and @productversionminor < 4001 and
                                    @@VERSION like '%Standard Edition%')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 189) with nowait;

                                        insert into #blitzresults(checkid, priority, findingsgroup, finding, url, details)
                                        values (189, 100, 'Features', 'Missing Features',
                                                'https://blogs.msdn.microsoft.com/sqlreleaseservices/sql-server-2016-service-pack-1-sp1-released/',
                                                'SQL 2016 Standard Edition is being used but not Service Pack 1. Check the URL for a list of Enterprise Features that are included in Standard Edition as of SP1.');
                                    end;

                            end;

                        /* Check if SQL 2017 but not CU3 */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 216)
                            and SERVERPROPERTY('EngineEdition') <> 8 /* Azure Managed Instances */
                            begin
                                if (@productversionmajor = 14 and @productversionminor < 3015)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 216) with nowait;

                                        insert into #blitzresults(checkid, priority, findingsgroup, finding, url, details)
                                        values (216, 100, 'Features', 'Missing Features',
                                                'https://support.microsoft.com/en-us/help/4041814',
                                                'SQL 2017 is being used but not Cumulative Update 3. We''d recommend patching to take advantage of increased analytics when running BlitzCache.');
                                    end;

                            end;

                        /* Cumulative Update Available */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 217)
                            and
                           SERVERPROPERTY('EngineEdition') not in (5, 8) /* Azure Managed Instances and Azure SQL DB*/
                            and EXISTS(select * from information_schema.tables where table_name = 'SqlServerVersions'
                                                                                 and table_type = 'BASE TABLE')
                            and not EXISTS(
                                    select * from #blitzresults where checkid in (128, 129, 157, 189, 216)) /* Other version checks */
                            begin
                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 217) with nowait;

                                insert into #blitzresults(checkid, priority, findingsgroup, finding, url, details)
                                select top 1 217,
                                             100,
                                             'Reliability',
                                             'Cumulative Update Available',
                                             COALESCE(v.url, 'https://SQLServerUpdates.com/'),
                                             v.minorversionname + ' was released on ' +
                                             CAST(CONVERT(datetime, v.releasedate, 112) as varchar(100))
                                from dbo.sqlserverversions v
                                where v.majorversionnumber = @productversionmajor
                                  and v.minorversionnumber > @productversionminor
                                order by v.minorversionnumber desc;
                            end;

                        /* Performance - High Memory Use for In-Memory OLTP (Hekaton) */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 145)
                            and EXISTS(select *
                                       from sys.all_objects o
                                       where o.name = 'dm_db_xtp_table_memory_stats')
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 145) with nowait;

                                set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT 145 AS CheckID,
			                        10 AS Priority,
			                        ''Performance'' AS FindingsGroup,
			                        ''High Memory Use for In-Memory OLTP (Hekaton)'' AS Finding,
			                        ''https://BrentOzar.com/go/hekaton'' AS URL,
			                        CAST(CAST((SUM(mem.pages_kb / 1024.0) / CAST(value_in_use AS INT) * 100) AS INT) AS NVARCHAR(100)) + ''% of your '' + CAST(CAST((CAST(value_in_use AS DECIMAL(38,1)) / 1024) AS MONEY) AS NVARCHAR(100)) + ''GB of your max server memory is being used for in-memory OLTP tables (Hekaton). Microsoft recommends having 2X your Hekaton table space available in memory just for Hekaton, with a max of 250GB of in-memory data regardless of your server memory capacity.'' AS Details
			                        FROM sys.configurations c INNER JOIN sys.dm_os_memory_clerks mem ON mem.type = ''MEMORYCLERK_XTP''
                                    WHERE c.name = ''max server memory (MB)''
                                    GROUP BY c.value_in_use
                                    HAVING CAST(value_in_use AS DECIMAL(38,2)) * .25 < SUM(mem.pages_kb / 1024.0)
                                      OR SUM(mem.pages_kb / 1024.0) > 250000 OPTION (RECOMPILE)';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);
                            end;

                        /* Performance - In-Memory OLTP (Hekaton) In Use */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 146)
                            and EXISTS(select *
                                       from sys.all_objects o
                                       where o.name = 'dm_db_xtp_table_memory_stats')
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 146) with nowait;

                                set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT 146 AS CheckID,
			                        200 AS Priority,
			                        ''Performance'' AS FindingsGroup,
			                        ''In-Memory OLTP (Hekaton) In Use'' AS Finding,
			                        ''https://BrentOzar.com/go/hekaton'' AS URL,
			                        CAST(CAST((SUM(mem.pages_kb / 1024.0) / CAST(value_in_use AS INT) * 100) AS INT) AS NVARCHAR(100)) + ''% of your '' + CAST(CAST((CAST(value_in_use AS DECIMAL(38,1)) / 1024) AS MONEY) AS NVARCHAR(100)) + ''GB of your max server memory is being used for in-memory OLTP tables (Hekaton).'' AS Details
			                        FROM sys.configurations c INNER JOIN sys.dm_os_memory_clerks mem ON mem.type = ''MEMORYCLERK_XTP''
                                    WHERE c.name = ''max server memory (MB)''
                                    GROUP BY c.value_in_use
                                    HAVING SUM(mem.pages_kb / 1024.0) > 10 OPTION (RECOMPILE)';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);
                            end;

                        /* In-Memory OLTP (Hekaton) - Transaction Errors */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 147)
                            and EXISTS(select *
                                       from sys.all_objects o
                                       where o.name = 'dm_xtp_transaction_stats')
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 147) with nowait

                                set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT 147 AS CheckID,
			                        100 AS Priority,
			                        ''In-Memory OLTP (Hekaton)'' AS FindingsGroup,
			                        ''Transaction Errors'' AS Finding,
			                        ''https://BrentOzar.com/go/hekaton'' AS URL,
			                        ''Since restart: '' + CAST(validation_failures AS NVARCHAR(100)) + '' validation failures, '' + CAST(dependencies_failed AS NVARCHAR(100)) + '' dependency failures, '' + CAST(write_conflicts AS NVARCHAR(100)) + '' write conflicts, '' + CAST(unique_constraint_violations AS NVARCHAR(100)) + '' unique constraint violations.'' AS Details
			                        FROM sys.dm_xtp_transaction_stats
                                    WHERE validation_failures <> 0
                                            OR dependencies_failed <> 0
                                            OR write_conflicts <> 0
                                            OR unique_constraint_violations <> 0 OPTION (RECOMPILE);';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);
                            end;

                        /* Reliability - Database Files on Network File Shares */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 148)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 148) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select distinct 148                                                               as checkid,
                                                d.[name]                                                          as databasename,
                                                170                                                               as priority,
                                                'Reliability'                                                     as findingsgroup,
                                                'Database Files on Network File Shares'                           as finding,
                                                'https://BrentOzar.com/go/nas'                                    as url,
                                                ('Files for this database are on: ' + LEFT(mf.physical_name, 30)) as details
                                from sys.databases d
                                         inner join sys.master_files mf on d.database_id = mf.database_id
                                where mf.physical_name like '\\%'
                                  and d.name not in (select distinct databasename
                                                     from #skipchecks
                                                     where checkid is null
                                                        or checkid = 148);
                            end;

                        /* Reliability - Database Files Stored in Azure */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 149)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 149) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select distinct 149                                                               as checkid,
                                                d.[name]                                                          as databasename,
                                                170                                                               as priority,
                                                'Reliability'                                                     as findingsgroup,
                                                'Database Files Stored in Azure'                                  as finding,
                                                'https://BrentOzar.com/go/azurefiles'                             as url,
                                                ('Files for this database are on: ' + LEFT(mf.physical_name, 30)) as details
                                from sys.databases d
                                         inner join sys.master_files mf on d.database_id = mf.database_id
                                where mf.physical_name like 'http://%'
                                  and d.name not in (select distinct databasename
                                                     from #skipchecks
                                                     where checkid is null
                                                        or checkid = 149);
                            end;

                        /* Reliability - Errors Logged Recently in the Default Trace */

                        /* First, let's check that there aren't any issues with the trace files */
                        begin try

                            insert into #fntracegettable
                            (textdata,
                             databasename,
                             eventclass,
                             severity,
                             starttime,
                             endtime,
                             duration,
                             ntusername,
                             ntdomainname,
                             hostname,
                             applicationname,
                             loginname,
                             dbusername)
                            select top 20000 CONVERT(nvarchar(4000), t.textdata),
                                             t.databasename,
                                             t.eventclass,
                                             t.severity,
                                             t.starttime,
                                             t.endtime,
                                             t.duration,
                                             t.ntusername,
                                             t.ntdomainname,
                                             t.hostname,
                                             t.applicationname,
                                             t.loginname,
                                             t.dbusername
                            from sys.fn_trace_gettable(@base_tracefilename, DEFAULT) t
                            where (
                                    t.eventclass = 22
                                    and t.severity >= 17
                                    and t.starttime > DATEADD(dd, -30, GETDATE())
                                )
                               or (
                                    t.eventclass in (92, 93)
                                    and t.starttime > DATEADD(dd, -30, GETDATE())
                                    and t.duration > 15000000
                                )
                               or (
                                t.eventclass in (94, 95, 116)
                                )

                            set @tracefileissue = 0

                        end try
                        begin catch

                            set @tracefileissue = 1

                        end catch

                        if @tracefileissue = 1
                            begin
                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 199)
                                    insert into #blitzresults
                                    (checkid,
                                     databasename,
                                     priority,
                                     findingsgroup,
                                     finding,
                                     url,
                                     details)
                                    select '199'                                      as checkid,
                                           ''                                         as databasename,
                                           50                                         as priority,
                                           'Reliability'                              as findingsgroup,
                                           'There Is An Error With The Default Trace' as finding,
                                           'https://BrentOzar.com/go/defaulttrace'    as url,
                                           'Somebody has been messing with your trace files. Check the files are present at ' +
                                           @base_tracefilename                        as details
                            end

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 150)
                            and @base_tracefilename is not null
                            and @tracefileissue = 0
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 150) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select distinct 150                                           as checkid,
                                                t.databasename,
                                                50                                            as priority,
                                                'Reliability'                                 as findingsgroup,
                                                'Errors Logged Recently in the Default Trace' as finding,
                                                'https://BrentOzar.com/go/defaulttrace'       as url,
                                                CAST(t.textdata as nvarchar(4000))            as details
                                from #fntracegettable t
                                where t.eventclass = 22
                                /* Removed these as they're unnecessary, we filter this when inserting data into #fnTraceGettable */
                                --AND t.Severity >= 17
                                --AND t.StartTime > DATEADD(dd, -30, GETDATE());
                            end;

                        /* Performance - File Growths Slow */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 151)
                            and @base_tracefilename is not null
                            and @tracefileissue = 0
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 151) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select distinct 151                                                                                                 as checkid,
                                                t.databasename,
                                                50                                                                                                  as priority,
                                                'Performance'                                                                                       as findingsgroup,
                                                'File Growths Slow'                                                                                 as finding,
                                                'https://BrentOzar.com/go/filegrowth'                                                               as url,
                                                CAST(COUNT(*) as nvarchar(100)) +
                                                ' growths took more than 15 seconds each. Consider setting file autogrowth to a smaller increment.' as details
                                from #fntracegettable t
                                where t.eventclass in (92, 93)
                                    /* Removed these as they're unnecessary, we filter this when inserting data into #fnTraceGettable */
                                      --AND t.StartTime > DATEADD(dd, -30, GETDATE())
                                      --AND t.Duration > 15000000
                                group by t.databasename
                                having COUNT(*) > 1;
                            end;

                        /* Performance - Many Plans for One Query */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 160)
                            and EXISTS(select * from sys.all_columns where name = 'query_hash')
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 160) with nowait;

                                set @stringtoexecute = N'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT TOP 1 160 AS CheckID,
			                        100 AS Priority,
			                        ''Performance'' AS FindingsGroup,
			                        ''Many Plans for One Query'' AS Finding,
			                        ''https://BrentOzar.com/go/parameterization'' AS URL,
			                        CAST(COUNT(DISTINCT plan_handle) AS NVARCHAR(50)) + '' plans are present for a single query in the plan cache - meaning we probably have parameterization issues.'' AS Details
			                        FROM sys.dm_exec_query_stats qs
                                    CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) pa
                                    WHERE pa.attribute = ''dbid''
                                    GROUP BY qs.query_hash, pa.value
                                    HAVING COUNT(DISTINCT plan_handle) > ';

                                if 50 > (select COUNT(*) from sys.databases)
                                    set @stringtoexecute = @stringtoexecute + N' 50 ';
                                else
                                    select @stringtoexecute = @stringtoexecute + CAST(COUNT(*) * 2 as nvarchar(50))
                                    from sys.databases;

                                set @stringtoexecute = @stringtoexecute +
                                                       N' ORDER BY COUNT(DISTINCT plan_handle) DESC OPTION (RECOMPILE);';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);
                            end;

                        /* Performance - High Number of Cached Plans */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 161)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 161) with nowait;

                                set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT TOP 1 161 AS CheckID,
			                        100 AS Priority,
			                        ''Performance'' AS FindingsGroup,
			                        ''High Number of Cached Plans'' AS Finding,
			                        ''https://BrentOzar.com/go/planlimits'' AS URL,
			                        ''Your server configuration is limited to '' + CAST(ht.buckets_count * 4 AS VARCHAR(20)) + '' '' + ht.name + '', and you are currently caching '' + CAST(cc.entries_count AS VARCHAR(20)) + ''.'' AS Details
			                        FROM sys.dm_os_memory_cache_hash_tables ht
			                        INNER JOIN sys.dm_os_memory_cache_counters cc ON ht.name = cc.name AND ht.type = cc.type
			                        where ht.name IN ( ''SQL Plans'' , ''Object Plans'' , ''Bound Trees'' )
			                        AND cc.entries_count >= (3 * ht.buckets_count) OPTION (RECOMPILE)';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);
                            end;

                        /* Performance - Too Much Free Memory */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 165)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 165) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 165,
                                       50,
                                       'Performance',
                                       'Too Much Free Memory',
                                       'https://BrentOzar.com/go/freememory',
                                       CAST((CAST(cfree.cntr_value as bigint) / 1024 / 1024) as nvarchar(100)) +
                                       N'GB of free memory inside SQL Server''s buffer pool, which is ' +
                                       CAST((CAST(ctotal.cntr_value as bigint) / 1024 / 1024) as nvarchar(100)) +
                                       N'GB. You would think lots of free memory would be good, but check out the URL for more information.' as details
                                from sys.dm_os_performance_counters cfree
                                         inner join sys.dm_os_performance_counters ctotal
                                                    on ctotal.object_name like N'%Memory Manager%'
                                                        and ctotal.counter_name =
                                                            N'Total Server Memory (KB)                                                                                                        '
                                where cfree.object_name like N'%Memory Manager%'
                                  and cfree.counter_name =
                                      N'Free Memory (KB)                                                                                                                '
                                  and CAST(ctotal.cntr_value as bigint) > 20480000000
                                  and CAST(ctotal.cntr_value as bigint) * .3 <= CAST(cfree.cntr_value as bigint)
                                  and CAST(SERVERPROPERTY('edition') as varchar(100)) not like '%Standard%';

                            end;

                        /* Outdated sp_Blitz - sp_Blitz is Over 6 Months Old */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 155)
                            and DATEDIFF(mm, @versiondate, GETDATE()) > 6
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 155) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 155                                                                                                                                                   as checkid,
                                       0                                                                                                                                                     as priority,
                                       'Outdated sp_Blitz'                                                                                                                                   as findingsgroup,
                                       'sp_Blitz is Over 6 Months Old'                                                                                                                       as finding,
                                       'http://FirstResponderKit.org/'                                                                                                                       as url,
                                       'Some things get better with age, like fine wine and your T-SQL. However, sp_Blitz is not one of those things - time to go download the current one.' as details;
                            end;

                        /* Populate a list of database defaults. I'm doing this kind of oddly -
						    it reads like a lot of work, but this way it compiles & runs on all
						    versions of SQL Server.
						*/

                        if @debug in (1, 2) raiserror ('Generating database defaults.', 0, 1) with nowait;

                        insert into #databasedefaults
                        select 'is_supplemental_logging_enabled',
                               0,
                               131,
                               210,
                               'Supplemental Logging Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'is_supplemental_logging_enabled'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'snapshot_isolation_state',
                               0,
                               132,
                               210,
                               'Snapshot Isolation Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'snapshot_isolation_state'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'is_read_committed_snapshot_on',
                               case when SERVERPROPERTY('EngineEdition') = 5 then 1 else 0 end, /* RCSI is always enabled in Azure SQL DB per https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/1919 */
                               133,
                               210,
                               case
                                   when SERVERPROPERTY('EngineEdition') = 5
                                       then 'Read Committed Snapshot Isolation Disabled'
                                   else 'Read Committed Snapshot Isolation Enabled' end,
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'is_read_committed_snapshot_on'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'is_auto_create_stats_incremental_on',
                               0,
                               134,
                               210,
                               'Auto Create Stats Incremental Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'is_auto_create_stats_incremental_on'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'is_ansi_null_default_on',
                               0,
                               135,
                               210,
                               'ANSI NULL Default Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'is_ansi_null_default_on'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'is_recursive_triggers_on',
                               0,
                               136,
                               210,
                               'Recursive Triggers Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'is_recursive_triggers_on'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'is_trustworthy_on',
                               0,
                               137,
                               210,
                               'Trustworthy Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'is_trustworthy_on'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'is_broker_enabled',
                               0,
                               230,
                               210,
                               'Broker Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'is_broker_enabled'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'is_honor_broker_priority_on',
                               0,
                               231,
                               210,
                               'Honor Broker Priority Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'is_honor_broker_priority_on'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'is_parameterization_forced',
                               0,
                               138,
                               210,
                               'Forced Parameterization Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'is_parameterization_forced'
                          and object_id = OBJECT_ID('sys.databases');
                        /* Not alerting for this since we actually want it and we have a separate check for it:
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_query_store_on', 0, 139, 210, 'Query Store Enabled', 'https://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns
						  WHERE name = 'is_query_store_on' AND object_id = OBJECT_ID('sys.databases');
						*/
                        insert into #databasedefaults
                        select 'is_cdc_enabled',
                               0,
                               140,
                               210,
                               'Change Data Capture Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'is_cdc_enabled'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'containment',
                               0,
                               141,
                               210,
                               'Containment Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'containment'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'target_recovery_time_in_seconds',
                               0,
                               142,
                               210,
                               'Target Recovery Time Changed',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'target_recovery_time_in_seconds'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'delayed_durability',
                               0,
                               143,
                               210,
                               'Delayed Durability Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'delayed_durability'
                          and object_id = OBJECT_ID('sys.databases');
                        insert into #databasedefaults
                        select 'is_memory_optimized_elevate_to_snapshot_on',
                               0,
                               144,
                               210,
                               'Memory Optimized Enabled',
                               'https://BrentOzar.com/go/dbdefaults',
                               null
                        from sys.all_columns
                        where name = 'is_memory_optimized_elevate_to_snapshot_on'
                          and object_id = OBJECT_ID('sys.databases')
                          and SERVERPROPERTY('EngineEdition') <> 8; /* Hekaton is always enabled in Managed Instances per https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/1919 */

                        declare databasedefaultsloop cursor for
                            select name, defaultvalue, checkid, priority, finding, url, details
                            from #databasedefaults;

                        open databasedefaultsloop;
                        fetch next from databasedefaultsloop into @currentname, @currentdefaultvalue, @currentcheckid, @currentpriority, @currentfinding, @currenturl, @currentdetails;
                        while @@FETCH_STATUS = 0
                            begin

                                if @debug in (1, 2)
                                    raiserror ('Running CheckId [%d].', 0, 1, @currentcheckid) with nowait;

                                /* Target Recovery Time (142) can be either 0 or 60 due to a number of bugs */
                                if @currentcheckid = 142
                                    set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details)
								   SELECT ' + CAST(@currentcheckid as nvarchar(200)) + ', d.[name], ' +
                                                           CAST(@currentpriority as nvarchar(200)) +
                                                           ', ''Non-Default Database Config'', ''' + @currentfinding +
                                                           ''',''' + @currenturl + ''',''' +
                                                           COALESCE(@currentdetails, 'This database setting is not the default.') + '''
									FROM sys.databases d
									WHERE d.database_id > 4 AND d.state <> 1 AND (d.[' + @currentname +
                                                           '] NOT IN (0, 60) OR d.[' + @currentname +
                                                           '] IS NULL) OPTION (RECOMPILE);';
                                else
                                    set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details)
								   SELECT ' + CAST(@currentcheckid as nvarchar(200)) + ', d.[name], ' +
                                                           CAST(@currentpriority as nvarchar(200)) +
                                                           ', ''Non-Default Database Config'', ''' + @currentfinding +
                                                           ''',''' + @currenturl + ''',''' +
                                                           COALESCE(@currentdetails, 'This database setting is not the default.') + '''
									FROM sys.databases d
									WHERE d.database_id > 4 AND d.state <> 1 AND (d.[' + @currentname + '] <> ' +
                                                           @currentdefaultvalue + ' OR d.[' + @currentname +
                                                           '] IS NULL) OPTION (RECOMPILE);';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                exec (@stringtoexecute);

                                fetch next from databasedefaultsloop into @currentname, @currentdefaultvalue, @currentcheckid, @currentpriority, @currentfinding, @currenturl, @currentdetails;
                            end;

                        close databasedefaultsloop;
                        deallocate databasedefaultsloop;


/*This checks to see if Agent is Offline*/
                        if @productversionmajor >= 10
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 167)
                            begin
                                if EXISTS(select 1
                                          from sys.all_objects
                                          where name = 'dm_server_services')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 167) with nowait;

                                        insert into [#BlitzResults]
                                        ([CheckID],
                                         [Priority],
                                         [FindingsGroup],
                                         [Finding],
                                         [URL],
                                         [Details])

                                        select 167                          as [CheckID],
                                               250                          as [Priority],
                                               'Server Info'                as [FindingsGroup],
                                               'Agent is Currently Offline' as [Finding],
                                               ''                           as [URL],
                                               ('Oops! It looks like the ' + [servicename] + ' service is ' +
                                                [status_desc] + '. The startup type is ' + [startup_type_desc] + '.'
                                                   )                        as [Details]
                                        from [sys].[dm_server_services]
                                        where [status_desc] <> 'Running'
                                          and [servicename] like 'SQL Server Agent%'
                                          and CAST(SERVERPROPERTY('Edition') as varchar(1000)) not like '%xpress%';

                                    end;
                            end;

/*This checks to see if the Full Text thingy is offline*/
                        if @productversionmajor >= 10
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 168)
                            begin
                                if EXISTS(select 1
                                          from sys.all_objects
                                          where name = 'dm_server_services')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 168) with nowait;

                                        insert into [#BlitzResults]
                                        ([CheckID],
                                         [Priority],
                                         [FindingsGroup],
                                         [Finding],
                                         [URL],
                                         [Details])

                                        select 168                                                     as [CheckID],
                                               250                                                     as [Priority],
                                               'Server Info'                                           as [FindingsGroup],
                                               'Full-text Filter Daemon Launcher is Currently Offline' as [Finding],
                                               ''                                                      as [URL],
                                               ('Oops! It looks like the ' + [servicename] + ' service is ' +
                                                [status_desc] + '. The startup type is ' + [startup_type_desc] + '.'
                                                   )                                                   as [Details]
                                        from [sys].[dm_server_services]
                                        where [status_desc] <> 'Running'
                                          and [servicename] like 'SQL Full-text Filter Daemon Launcher%';

                                    end;
                            end;

/*This checks which service account SQL Server is running as.*/
                        if @productversionmajor >= 10
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 169)
                            begin
                                if EXISTS(select 1
                                          from sys.all_objects
                                          where name = 'dm_server_services')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 169) with nowait;

                                        insert into [#BlitzResults]
                                        ([CheckID],
                                         [Priority],
                                         [FindingsGroup],
                                         [Finding],
                                         [URL],
                                         [Details])

                                        select 169                                                 as [CheckID],
                                               250                                                 as [Priority],
                                               'Informational'                                     as [FindingsGroup],
                                               'SQL Server is running under an NT Service account' as [Finding],
                                               'https://BrentOzar.com/go/setup'                    as [URL],
                                               ('I''m running as ' + [service_account] +
                                                '. I wish I had an Active Directory service account instead.'
                                                   )                                               as [Details]
                                        from [sys].[dm_server_services]
                                        where [service_account] like 'NT Service%'
                                          and [servicename] like 'SQL Server%'
                                          and [servicename] not like 'SQL Server Agent%';

                                    end;
                            end;

/*This checks which service account SQL Agent is running as.*/
                        if @productversionmajor >= 10
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 170)
                            begin
                                if EXISTS(select 1
                                          from sys.all_objects
                                          where name = 'dm_server_services')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 170) with nowait;

                                        insert into [#BlitzResults]
                                        ([CheckID],
                                         [Priority],
                                         [FindingsGroup],
                                         [Finding],
                                         [URL],
                                         [Details])

                                        select 170                                                       as [CheckID],
                                               250                                                       as [Priority],
                                               'Informational'                                           as [FindingsGroup],
                                               'SQL Server Agent is running under an NT Service account' as [Finding],
                                               'https://BrentOzar.com/go/setup'                          as [URL],
                                               ('I''m running as ' + [service_account] +
                                                '. I wish I had an Active Directory service account instead.'
                                                   )                                                     as [Details]
                                        from [sys].[dm_server_services]
                                        where [service_account] like 'NT Service%'
                                          and [servicename] like 'SQL Server Agent%';

                                    end;
                            end;

/*This checks that First Responder Kit is consistent.
It assumes that all the objects of the kit resides in the same database, the one in which this SP is stored
It also is ready to check for installation in another schema.
*/
                        if (
                            not EXISTS(
                                    select 1
                                    from #skipchecks
                                    where databasename is null
                                      and checkid = 226
                                )
                            )
                            begin

                                if @debug in (1, 2) raiserror ('Running check with id %d',0,1,2000);

                                set @spblitzfullname = QUOTENAME(DB_NAME()) + '.' +
                                                       QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + '.' +
                                                       QUOTENAME(OBJECT_NAME(@@PROCID));
                                set @blitzisoutdatedcomparedtoothers = 0;
                                set @tsql = null;
                                set @versioncheckmodeexiststsql = null;
                                set @blitzprocdbname = DB_NAME();
                                set @execret = null;
                                set @innerexecret = null;
                                set @tmpcnt = null;

                                set @previouscomponentname = null;
                                set @previouscomponentfullpath = null;
                                set @currentstatementid = null;
                                set @currentcomponentschema = null;
                                set @currentcomponentname = null;
                                set @currentcomponenttype = null;
                                set @currentcomponentversiondate = null;
                                set @currentcomponentfullname = null;
                                set @currentcomponentmandatory = null;
                                set @maximumversiondate = null;

                                set @statementcheckname = null;
                                set @statementoutputscounter = null;
                                set @outputcounterexpectedvalue = null;
                                set @statementoutputsexecret = null;
                                set @statementoutputsdatetime = null;

                                set @currentcomponentmandatorycheckok = null;
                                set @currentcomponentversioncheckmodeok = null;

                                set @canexitloop = 0;
                                set @frkisconsistent = 0;


                                set @tsql = 'USE ' + QUOTENAME(@blitzprocdbname) + ';' + @crlf +
                                            'WITH FRKComponents (' + @crlf +
                                            '    ObjectName,' + @crlf +
                                            '    ObjectType,' + @crlf +
                                            '    MandatoryComponent' + @crlf +
                                            ')' + @crlf +
                                            'AS (' + @crlf +
                                            '    SELECT ''sp_AllNightLog'',''P'' ,0' + @crlf +
                                            '    UNION ALL' + @crlf +
                                            '    SELECT ''sp_AllNightLog_Setup'', ''P'',0' + @crlf +
                                            '    UNION ALL ' + @crlf +
                                            '    SELECT ''sp_Blitz'',''P'',0' + @crlf +
                                            '    UNION ALL ' + @crlf +
                                            '    SELECT ''sp_BlitzBackups'',''P'',0' + @crlf +
                                            '    UNION ALL ' + @crlf +
                                            '    SELECT ''sp_BlitzCache'',''P'',0' + @crlf +
                                            '    UNION ALL ' + @crlf +
                                            '    SELECT ''sp_BlitzFirst'',''P'',0' + @crlf +
                                            '    UNION ALL' + @crlf +
                                            '    SELECT ''sp_BlitzIndex'',''P'',0' + @crlf +
                                            '    UNION ALL ' + @crlf +
                                            '    SELECT ''sp_BlitzLock'',''P'',0' + @crlf +
                                            '    UNION ALL ' + @crlf +
                                            '    SELECT ''sp_BlitzQueryStore'',''P'',0' + @crlf +
                                            '    UNION ALL ' + @crlf +
                                            '    SELECT ''sp_BlitzWho'',''P'',0' + @crlf +
                                            '    UNION ALL ' + @crlf +
                                            '    SELECT ''sp_DatabaseRestore'',''P'',0' + @crlf +
                                            '    UNION ALL ' + @crlf +
                                            '    SELECT ''sp_ineachdb'',''P'',0' + @crlf +
                                            '    UNION ALL' + @crlf +
                                            '    SELECT ''SqlServerVersions'',''U'',0' + @crlf +
                                            ')' + @crlf +
                                            'INSERT INTO #FRKObjects (' + @crlf +
                                            '    DatabaseName,ObjectSchemaName,ObjectName, ObjectType,MandatoryComponent' +
                                            @crlf +
                                            ')' + @crlf +
                                            'SELECT DB_NAME(),SCHEMA_NAME(o.schema_id), c.ObjectName,c.ObjectType,c.MandatoryComponent' +
                                            @crlf +
                                            'FROM ' + @crlf +
                                            '    FRKComponents c' + @crlf +
                                            'LEFT JOIN ' + @crlf +
                                            '    sys.objects o' + @crlf +
                                            'ON c.ObjectName  = o.[name]' + @crlf +
                                            'AND c.ObjectType = o.[type]' + @crlf +
                                    --'WHERE o.schema_id IS NOT NULL' + @crlf +
                                            ';';

                                exec @execret = sp_executesql @tsql;

                                -- TODO: add check for statement success

                                -- TODO: based on SP requirements and presence (SchemaName is not null) ==> update MandatoryComponent column

                                -- Filling #StatementsToRun4FRKVersionCheck
                                insert into #statementstorun4frkversioncheck (checkname, statementtext, subjectname,
                                                                              subjectfullpath, statementoutputscounter,
                                                                              outputcounterexpectedvalue,
                                                                              statementoutputsexecret,
                                                                              statementoutputsdatetime)
                                select 'Mandatory',
                                       'SELECT @cnt = COUNT(*) FROM #FRKObjects WHERE ObjectSchemaName IS NULL AND ObjectName = ''' +
                                       objectname + ''' AND MandatoryComponent = 1;',
                                       objectname,
                                       QUOTENAME(databasename) + '.' + QUOTENAME(objectschemaname) + '.' +
                                       QUOTENAME(objectname),
                                       1,
                                       0,
                                       0,
                                       0
                                from #frkobjects
                                union all
                                select 'VersionCheckMode',
                                       'SELECT @cnt = COUNT(*) FROM ' +
                                       QUOTENAME(databasename) + '.sys.all_parameters ' +
                                       'where object_id = OBJECT_ID(''' + QUOTENAME(databasename) + '.' +
                                       QUOTENAME(objectschemaname) + '.' + QUOTENAME(objectname) +
                                       ''') AND [name] = ''@VersionCheckMode'';',
                                       objectname,
                                       QUOTENAME(databasename) + '.' + QUOTENAME(objectschemaname) + '.' +
                                       QUOTENAME(objectname),
                                       1,
                                       1,
                                       0,
                                       0
                                from #frkobjects
                                where objecttype = 'P'
                                  and objectschemaname is not null
                                union all
                                select 'VersionCheck',
                                       'EXEC @ExecRet = ' + QUOTENAME(databasename) + '.' +
                                       QUOTENAME(objectschemaname) + '.' + QUOTENAME(objectname) +
                                       ' @VersionCheckMode = 1 , @VersionDate = @ObjDate OUTPUT;',
                                       objectname,
                                       QUOTENAME(databasename) + '.' + QUOTENAME(objectschemaname) + '.' +
                                       QUOTENAME(objectname),
                                       0,
                                       0,
                                       1,
                                       1
                                from #frkobjects
                                where objecttype = 'P'
                                  and objectschemaname is not null;
                                if (@debug in (1, 2))
                                    begin
                                        select *
                                        from #statementstorun4frkversioncheck
                                        order by subjectname, subjectfullpath, statementid -- in case of schema change  ;
                                    end;


                                -- loop on queries...
                                while(@canexitloop = 0)
                                    begin
                                        set @currentstatementid = null;

                                        select top 1 @statementcheckname = checkname,
                                                     @currentstatementid = statementid,
                                                     @currentcomponentname = subjectname,
                                                     @currentcomponentfullname = subjectfullpath,
                                                     @tsql = statementtext,
                                                     @statementoutputscounter = statementoutputscounter,
                                                     @outputcounterexpectedvalue = outputcounterexpectedvalue,
                                                     @statementoutputsexecret = statementoutputsexecret,
                                                     @statementoutputsdatetime = statementoutputsdatetime
                                        from #statementstorun4frkversioncheck
                                        order by subjectname, subjectfullpath, statementid /* in case of schema change */
                                        ;

                                        -- loop exit condition
                                        if (@currentstatementid is null)
                                            begin
                                                break;
                                            end;

                                        if @debug in (1, 2) raiserror ('    Statement: %s',0,1,@tsql);

                                        -- we start a new component
                                        if (@previouscomponentname is null or
                                            (@previouscomponentname is not null and
                                             @previouscomponentname <> @currentcomponentname) or
                                            (@previouscomponentname is not null and
                                             @previouscomponentname = @currentcomponentname and
                                             @previouscomponentfullpath <> @currentcomponentfullname)
                                            )
                                            begin
                                                -- reset variables
                                                set @currentcomponentmandatorycheckok = 0;
                                                set @currentcomponentversioncheckmodeok = 0;
                                                set @previouscomponentname = @currentcomponentname;
                                                set @previouscomponentfullpath = @currentcomponentfullname;
                                            end;

                                        if (@statementcheckname not in
                                            ('Mandatory', 'VersionCheckMode', 'VersionCheck'))
                                            begin
                                                insert into #blitzresults(checkid,
                                                                          priority,
                                                                          findingsgroup,
                                                                          finding,
                                                                          url,
                                                                          details)
                                                select 226                                             as checkid,
                                                       253                                             as priority,
                                                       'First Responder Kit'                           as findingsgroup,
                                                       'Version Check Failed (code generator changed)' as finding,
                                                       'http://FirstResponderKit.org'                  as url,
                                                       'Download an updated First Responder Kit. Your version check failed because a change has been made to the version check code generator.' +
                                                       @crlf +
                                                       'Error: No handler for check with name "' +
                                                       ISNULL(@statementcheckname, '') + '"'           as details;

                                                -- we will stop the test because it's possible to get the same message for other components
                                                set @canexitloop = 1;
                                                continue;
                                            end;

                                        if (@statementcheckname = 'Mandatory')
                                            begin
                                                -- outputs counter
                                                exec @execret = sp_executesql @tsql, N'@cnt INT OUTPUT', @cnt = @tmpcnt output;

                                                if (@execret <> 0)
                                                    begin

                                                        insert into #blitzresults(checkid,
                                                                                  priority,
                                                                                  findingsgroup,
                                                                                  finding,
                                                                                  url,
                                                                                  details)
                                                        select 226                                            as checkid,
                                                               253                                            as priority,
                                                               'First Responder Kit'                          as findingsgroup,
                                                               'Version Check Failed (dynamic query failure)' as finding,
                                                               'http://FirstResponderKit.org'                 as url,
                                                               'Download an updated First Responder Kit. Your version check failed due to dynamic query failure.' +
                                                               @crlf +
                                                               'Error: following query failed at execution (check if component [' +
                                                               ISNULL(@currentcomponentname, @currentcomponentname) +
                                                               '] is mandatory and missing)' + @crlf +
                                                               @tsql                                          as details;

                                                        -- we will stop the test because it's possible to get the same message for other components
                                                        set @canexitloop = 1;
                                                        continue;
                                                    end;

                                                if (@tmpcnt <> @outputcounterexpectedvalue)
                                                    begin
                                                        insert into #blitzresults(checkid,
                                                                                  priority,
                                                                                  findingsgroup,
                                                                                  finding,
                                                                                  url,
                                                                                  details)
                                                        select 227                                                                     as checkid,
                                                               253                                                                     as priority,
                                                               'First Responder Kit'                                                   as findingsgroup,
                                                               'Component Missing: ' + @currentcomponentname                           as finding,
                                                               'http://FirstResponderKit.org'                                          as url,
                                                               'Download an updated version of the First Responder Kit to install it.' as details;

                                                        -- as it's missing, no value for SubjectFullPath
                                                        delete
                                                        from #statementstorun4frkversioncheck
                                                        where subjectname = @currentcomponentname;
                                                        continue;
                                                    end;

                                                set @currentcomponentmandatorycheckok = 1;
                                            end;

                                        if (@statementcheckname = 'VersionCheckMode')
                                            begin
                                                if (@currentcomponentmandatorycheckok = 0)
                                                    begin
                                                        insert into #blitzresults(checkid,
                                                                                  priority,
                                                                                  findingsgroup,
                                                                                  finding,
                                                                                  url,
                                                                                  details)
                                                        select 226                                                            as checkid,
                                                               253                                                            as priority,
                                                               'First Responder Kit'                                          as findingsgroup,
                                                               'Version Check Failed (unexpectedly modified checks ordering)' as finding,
                                                               'http://FirstResponderKit.org'                                 as url,
                                                               'Download an updated First Responder Kit. Version check failed because "Mandatory" check has not been completed before for current component' +
                                                               @crlf +
                                                               'Error: version check mode happenned before "Mandatory" check for component called "' +
                                                               @currentcomponentfullname + '"';

                                                        -- we will stop the test because it's possible to get the same message for other components
                                                        set @canexitloop = 1;
                                                        continue;
                                                    end;

                                                -- outputs counter
                                                exec @execret = sp_executesql @tsql, N'@cnt INT OUTPUT', @cnt = @tmpcnt output;

                                                if (@execret <> 0)
                                                    begin
                                                        insert into #blitzresults(checkid,
                                                                                  priority,
                                                                                  findingsgroup,
                                                                                  finding,
                                                                                  url,
                                                                                  details)
                                                        select 226                                            as checkid,
                                                               253                                            as priority,
                                                               'First Responder Kit'                          as findingsgroup,
                                                               'Version Check Failed (dynamic query failure)' as finding,
                                                               'http://FirstResponderKit.org'                 as url,
                                                               'Download an updated First Responder Kit. Version check failed because a change has been made to the code generator.' +
                                                               @crlf +
                                                               'Error: following query failed at execution (check if component [' +
                                                               @currentcomponentfullname +
                                                               '] can run in VersionCheckMode)' + @crlf +
                                                               @tsql                                          as details;

                                                        -- we will stop the test because it's possible to get the same message for other components
                                                        set @canexitloop = 1;
                                                        continue;
                                                    end;

                                                if (@tmpcnt <> @outputcounterexpectedvalue)
                                                    begin
                                                        insert into #blitzresults(checkid,
                                                                                  priority,
                                                                                  findingsgroup,
                                                                                  finding,
                                                                                  url,
                                                                                  details)
                                                        select 228                                                                                                                                            as checkid,
                                                               253                                                                                                                                            as priority,
                                                               'First Responder Kit'                                                                                                                          as findingsgroup,
                                                               'Component Outdated: ' + @currentcomponentfullname                                                                                             as finding,
                                                               'http://FirstResponderKit.org'                                                                                                                 as url,
                                                               'Download an updated First Responder Kit. Component ' +
                                                               @currentcomponentfullname +
                                                               ' is not at the minimum version required to run this procedure' +
                                                               @crlf +
                                                               'VersionCheckMode has been introduced in component version date after "20190320". This means its version is lower than or equal to that date.' as details;
                                                        ;

                                                        delete
                                                        from #statementstorun4frkversioncheck
                                                        where subjectfullpath = @currentcomponentfullname;
                                                        continue;
                                                    end;

                                                set @currentcomponentversioncheckmodeok = 1;
                                            end;

                                        if (@statementcheckname = 'VersionCheck')
                                            begin
                                                if (@currentcomponentmandatorycheckok = 0 or
                                                    @currentcomponentversioncheckmodeok = 0)
                                                    begin
                                                        insert into #blitzresults(checkid,
                                                                                  priority,
                                                                                  findingsgroup,
                                                                                  finding,
                                                                                  url,
                                                                                  details)
                                                        select 226                                                            as checkid,
                                                               253                                                            as priority,
                                                               'First Responder Kit'                                          as findingsgroup,
                                                               'Version Check Failed (unexpectedly modified checks ordering)' as finding,
                                                               'http://FirstResponderKit.org'                                 as url,
                                                               'Download an updated First Responder Kit. Version check failed because "VersionCheckMode" check has not been completed before for component called "' +
                                                               @currentcomponentfullname + '"' + @crlf +
                                                               'Error: VersionCheck happenned before "VersionCheckMode" check for component called "' +
                                                               @currentcomponentfullname + '"';

                                                        -- we will stop the test because it's possible to get the same message for other components
                                                        set @canexitloop = 1;
                                                        continue;
                                                    end;

                                                exec @execret = sp_executesql @tsql,
                                                                N'@ExecRet INT OUTPUT, @ObjDate DATETIME OUTPUT',
                                                                @execret = @innerexecret output,
                                                                @objdate = @currentcomponentversiondate output;

                                                if (@execret <> 0)
                                                    begin
                                                        insert into #blitzresults(checkid,
                                                                                  priority,
                                                                                  findingsgroup,
                                                                                  finding,
                                                                                  url,
                                                                                  details)
                                                        select 226                                            as checkid,
                                                               253                                            as priority,
                                                               'First Responder Kit'                          as findingsgroup,
                                                               'Version Check Failed (dynamic query failure)' as finding,
                                                               'http://FirstResponderKit.org'                 as url,
                                                               'Download an updated First Responder Kit. The version check failed because a change has been made to the code generator.' +
                                                               @crlf +
                                                               'Error: following query failed at execution (check if component [' +
                                                               @currentcomponentfullname +
                                                               '] is at the expected version)' + @crlf +
                                                               @tsql                                          as details;

                                                        -- we will stop the test because it's possible to get the same message for other components
                                                        set @canexitloop = 1;
                                                        continue;
                                                    end;


                                                if (@innerexecret <> 0)
                                                    begin
                                                        insert into #blitzresults(checkid,
                                                                                  priority,
                                                                                  findingsgroup,
                                                                                  finding,
                                                                                  url,
                                                                                  details)
                                                        select 226                             as checkid,
                                                               253                             as priority,
                                                               'First Responder Kit'           as findingsgroup,
                                                               'Version Check Failed (Failed dynamic SP call to ' +
                                                               @currentcomponentfullname + ')' as finding,
                                                               'http://FirstResponderKit.org'  as url,
                                                               'Download an updated First Responder Kit. Error: following query failed at execution (check if component [' +
                                                               @currentcomponentfullname +
                                                               '] is at the expected version)' + @crlf +
                                                               'Return code: ' + CONVERT(varchar(10), @innerexecret) +
                                                               @crlf +
                                                               'T-SQL Query: ' + @crlf +
                                                               @tsql                           as details;

                                                        -- advance to next component
                                                        delete
                                                        from #statementstorun4frkversioncheck
                                                        where subjectfullpath = @currentcomponentfullname;
                                                        continue;
                                                    end;

                                                if (@currentcomponentversiondate < @versiondate)
                                                    begin

                                                        insert into #blitzresults(checkid,
                                                                                  priority,
                                                                                  findingsgroup,
                                                                                  finding,
                                                                                  url,
                                                                                  details)
                                                        select 228                                                                                                                           as checkid,
                                                               253                                                                                                                           as priority,
                                                               'First Responder Kit'                                                                                                         as findingsgroup,
                                                               'Component Outdated: ' + @currentcomponentfullname                                                                            as finding,
                                                               'http://FirstResponderKit.org'                                                                                                as url,
                                                               'Download and install the latest First Responder Kit - you''re running some older code, and it doesn''t get better with age.' as details;

                                                        raiserror ('Component %s is outdated',10,1,@currentcomponentfullname);
                                                        -- advance to next component
                                                        delete
                                                        from #statementstorun4frkversioncheck
                                                        where subjectfullpath = @currentcomponentfullname;
                                                        continue;
                                                    end;

                                                else
                                                    if (@currentcomponentversiondate > @versiondate and
                                                        @blitzisoutdatedcomparedtoothers = 0)
                                                        begin
                                                            set @blitzisoutdatedcomparedtoothers = 1;
                                                            raiserror ('Procedure %s is outdated',10,1,@spblitzfullname);
                                                            if (@maximumversiondate is null or
                                                                @maximumversiondate < @currentcomponentversiondate)
                                                                begin
                                                                    set @maximumversiondate = @currentcomponentversiondate;
                                                                end;
                                                        end;
                                                /* Kept for debug purpose:
            ELSE
            BEGIN
                INSERT  INTO #BlitzResults(
                    CheckID ,
                    Priority ,
                    FindingsGroup ,
                    Finding ,
                    URL ,
                    Details
                )
                SELECT
                    2000 AS CheckID ,
                    250 AS Priority ,
                    'Informational' AS FindingsGroup ,
                    'First Responder kit component ' + @CurrentComponentFullName + ' is at the expected version' AS Finding ,
                    'https://www.BrentOzar.com/blitz/' AS URL ,
                    'Version date is: ' + CONVERT(VARCHAR(32),@CurrentComponentVersionDate,121) AS Details
                ;
            END;
            */
                                            end;

                                        -- could be performed differently to minimize computation
                                        delete
                                        from #statementstorun4frkversioncheck
                                        where statementid = @currentstatementid;
                                    end;
                            end;


/*This counts memory dumps and gives min and max date of in view*/
                        if @productversionmajor >= 10
                            and
                           not (@productversionmajor = 10.5 and @productversionminor < 4297) /* Skip due to crash bug: https://support.microsoft.com/en-us/help/2908087 */
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 171)
                            begin
                                if EXISTS(select 1
                                          from sys.all_objects
                                          where name = 'dm_server_memory_dumps')
                                    begin
                                        if 5 <= (select COUNT(*)
                                                 from [sys].[dm_server_memory_dumps]
                                                 where [creation_time] >= DATEADD(year, -1, GETDATE()))
                                            begin

                                                if @debug in (1, 2)
                                                    raiserror ('Running CheckId [%d].', 0, 1, 171) with nowait;

                                                insert into [#BlitzResults]
                                                ([CheckID],
                                                 [Priority],
                                                 [FindingsGroup],
                                                 [Finding],
                                                 [URL],
                                                 [Details])

                                                select 171                             as [CheckID],
                                                       20                              as [Priority],
                                                       'Reliability'                   as [FindingsGroup],
                                                       'Memory Dumps Have Occurred'    as [Finding],
                                                       'https://BrentOzar.com/go/dump' as [URL],
                                                       ('That ain''t good. I''ve had ' +
                                                        CAST(COUNT(*) as varchar(100)) + ' memory dumps between ' +
                                                        CAST(CAST(MIN([creation_time]) as datetime) as varchar(100)) +
                                                        ' and ' +
                                                        CAST(CAST(MAX([creation_time]) as datetime) as varchar(100)) +
                                                        '!'
                                                           )                           as [Details]
                                                from [sys].[dm_server_memory_dumps]
                                                where [creation_time] >= DATEADD(year, -1, GETDATE());

                                            end;
                                    end;
                            end;

/*Checks to see if you're on Developer or Evaluation*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 173)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 173) with nowait;

                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])

                                select 173                                  as [CheckID],
                                       200                                  as [Priority],
                                       'Licensing'                          as [FindingsGroup],
                                       'Non-Production License'             as [Finding],
                                       'https://BrentOzar.com/go/licensing' as [URL],
                                       ('We''re not the licensing police, but if this is supposed to be a production server, and you''re running ' +
                                        CAST(SERVERPROPERTY('edition') as varchar(100)) +
                                        ' the good folks at Microsoft might get upset with you. Better start counting those cores.'
                                           )                                as [Details]
                                where CAST(SERVERPROPERTY('edition') as varchar(100)) like '%Developer%'
                                   or CAST(SERVERPROPERTY('edition') as varchar(100)) like '%Evaluation%';

                            end;

/*Checks to see if Buffer Pool Extensions are in use*/
                        if @productversionmajor >= 12
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 174)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 174) with nowait;

                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])

                                select 174                              as [CheckID],
                                       200                              as [Priority],
                                       'Performance'                    as [FindingsGroup],
                                       'Buffer Pool Extensions Enabled' as [Finding],
                                       'https://BrentOzar.com/go/bpe'   as [URL],
                                       ('You have Buffer Pool Extensions enabled, and one lives here: ' +
                                        [path] +
                                        '. It''s currently ' +
                                        case
                                            when [current_size_in_kb] / 1024. / 1024. > 0
                                                then CAST([current_size_in_kb] / 1024. / 1024. as varchar(100))
                                                + ' GB'
                                            else CAST([current_size_in_kb] / 1024. as varchar(100))
                                                + ' MB'
                                            end +
                                        '. Did you know that BPEs only provide single threaded access 8KB (one page) at a time?'
                                           )                            as [Details]
                                from sys.dm_os_buffer_pool_extension_configuration
                                where [state_description] <> 'BUFFER POOL EXTENSION DISABLED';

                            end;

/*Check for too many tempdb files*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 175)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 175) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select distinct 175                                               as checkid,
                                                'TempDB'                                          as databasename,
                                                170                                               as priority,
                                                'File Configuration'                              as findingsgroup,
                                                'TempDB Has >16 Data Files'                       as finding,
                                                'https://BrentOzar.com/go/tempdb'                 as url,
                                                'Woah, Nelly! TempDB has ' + CAST(COUNT_BIG(*) as varchar(30)) +
                                                '. Did you forget to terminate a loop somewhere?' as details
                                from sys.[master_files] as [mf]
                                where [mf].[database_id] = 2
                                  and [mf].[type] = 0
                                having COUNT_BIG(*) > 16;
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 176)
                            begin

                                if EXISTS(select 1
                                          from sys.all_objects
                                          where name = 'dm_xe_sessions')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 176) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         databasename,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select distinct 176                                                                 as checkid,
                                                        ''                                                                  as databasename,
                                                        200                                                                 as priority,
                                                        'Monitoring'                                                        as findingsgroup,
                                                        'Extended Events Hyperextension'                                    as finding,
                                                        'https://BrentOzar.com/go/xe'                                       as url,
                                                        'Hey big spender, you have ' +
                                                        CAST(COUNT_BIG(*) as varchar(30)) +
                                                        ' Extended Events sessions running. You sure you meant to do that?' as details
                                        from sys.dm_xe_sessions
                                        where [name] not in
                                              ('AlwaysOn_health',
                                               'system_health',
                                               'telemetry_xevents',
                                               'sp_server_diagnostics',
                                               'sp_server_diagnostics session',
                                               'hkenginexesession')
                                          and name not like '%$A%'
                                        having COUNT_BIG(*) >= 2;
                                    end;
                            end;

                        /*Harmful startup parameter*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 177)
                            begin

                                if EXISTS(select 1
                                          from sys.all_objects
                                          where name = 'dm_server_registry')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 177) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         databasename,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select distinct 177                                                                                                               as checkid,
                                                        ''                                                                                                                as databasename,
                                                        5                                                                                                                 as priority,
                                                        'Monitoring'                                                                                                      as findingsgroup,
                                                        'Disabled Internal Monitoring Features'                                                                           as finding,
                                                        'https://msdn.microsoft.com/en-us/library/ms190737.aspx'                                                          as url,
                                                        'You have -x as a startup parameter. You should head to the URL and read more about what it does to your system.' as details
                                        from [sys].[dm_server_registry] as [dsr]
                                        where [dsr].[registry_key] like N'%MSSQLServer\Parameters'
                                          and [dsr].[value_data] = '-x';;
                                    end;
                            end;


                        /* Reliability - Dangerous Third Party Modules - 179 */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 179)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 179) with nowait;

                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])

                                select 179                                                         as [CheckID],
                                       5                                                           as [Priority],
                                       'Reliability'                                               as [FindingsGroup],
                                       'Dangerous Third Party Modules'                             as [Finding],
                                       'https://support.microsoft.com/en-us/kb/2033238'            as [URL],
                                       (COALESCE(company, '') + ' - ' + COALESCE(description, '') + ' - ' +
                                        COALESCE(name, '') +
                                        ' - suspected dangerous third party module is installed.') as [Details]
                                from sys.dm_os_loaded_modules
                                where UPPER(name) like UPPER('%\ENTAPI.DLL') /* McAfee VirusScan Enterprise */
                                   or UPPER(name) like UPPER('%\HIPI.DLL')
                                   or UPPER(name) like UPPER('%\HcSQL.dll')
                                   or UPPER(name) like UPPER('%\HcApi.dll')
                                   or UPPER(name) like UPPER('%\HcThe.dll') /* McAfee Host Intrusion */
                                   or UPPER(name) like UPPER('%\SOPHOS_DETOURED.DLL')
                                   or UPPER(name) like UPPER('%\SOPHOS_DETOURED_x64.DLL')
                                   or UPPER(name) like UPPER('%\SWI_IFSLSP_64.dll')
                                   or UPPER(name) like UPPER('%\SOPHOS~%.dll') /* Sophos AV */
                                   or UPPER(name) like UPPER('%\PIOLEDB.DLL')
                                   or UPPER(name) like UPPER('%\PISDK.DLL'); /* OSISoft PI data access */

                            end;

                        /*Find shrink database tasks*/

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 180)
                            and
                           CONVERT(varchar(128), SERVERPROPERTY('productversion')) like '1%' /* Only run on 2008+ */
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 180) with nowait;

                                with xmlnamespaces ('www.microsoft.com/SqlServer/Dts' as [dts])
                                   , [maintenance_plan_steps] as (
                                    select [name]
                                   , [id] -- ID required to link maintenace plan with jobs and jobhistory (sp_Blitz Issue #776)
                                   , CAST(CAST([packagedata] as varbinary (max)) as xml) as [maintenance_plan_xml]
                                    from [msdb].[dbo].[sysssispackages]
                                    where [packagetype] = 6
                                    )
                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])
                                select 180                                        as [CheckID],
                                       -- sp_Blitz Issue #776
                                       -- Job has history and was executed in the last 30 days
                                       case
                                           when (cast(datediff(dd, substring(cast(sjh.run_date as nvarchar(10)), 1, 4) +
                                                                   '-' +
                                                                   substring(cast(sjh.run_date as nvarchar(10)), 5, 2) +
                                                                   '-' +
                                                                   substring(cast(sjh.run_date as nvarchar(10)), 7, 2),
                                                               GETDATE()) as int) < 30) or
                                                (j.[enabled] = 1 and ssc.[enabled] = 1) then
                                               100
                                           else -- no job history (implicit) AND job not run in the past 30 days AND (Job disabled OR Job Schedule disabled)
                                               200
                                           end                                    as priority,
                                       'Performance'                              as [FindingsGroup],
                                       'Shrink Database Step In Maintenance Plan' as [Finding],
                                       'https://BrentOzar.com/go/autoshrink'      as [URL],
                                       'The maintenance plan ' + [mps].[name] +
                                       ' has a step to shrink databases in it. Shrinking databases is as outdated as maintenance plans.'
                                           + case
                                                 when COALESCE(ssc.name, '0') != '0'
                                                     then + ' (Schedule: [' + ssc.name + '])'
                                                 else + '' end                    as [Details]
                                from [maintenance_plan_steps] [mps]
                                         cross apply [maintenance_plan_xml].[nodes]('//dts:Executables/dts:Executable') [t]([c])
                                         join msdb.dbo.sysmaintplan_subplans as sms
                                              on mps.id = sms.plan_id
                                         join msdb.dbo.sysjobs j
                                              on sms.job_id = j.job_id
                                         left outer join msdb.dbo.sysjobsteps as step
                                                         on j.job_id = step.job_id
                                         left outer join msdb.dbo.sysjobschedules as sjsc
                                                         on j.job_id = sjsc.job_id
                                         left outer join msdb.dbo.sysschedules as ssc
                                                         on sjsc.schedule_id = ssc.schedule_id
                                                             and sjsc.job_id = j.job_id
                                         left outer join msdb.dbo.sysjobhistory as sjh
                                                         on j.job_id = sjh.job_id
                                                             and step.step_id = sjh.step_id
                                                             and sjh.run_date in (select max(sjh2.run_date)
                                                                                  from msdb.dbo.sysjobhistory as sjh2
                                                                                  where sjh2.job_id = j.job_id) -- get the latest entry date
                                                             and sjh.run_time in (select max(sjh3.run_time)
                                                                                  from msdb.dbo.sysjobhistory as sjh3
                                                                                  where sjh3.job_id = j.job_id
                                                                                    and sjh3.run_date = sjh.run_date) -- get the latest entry time
                                where [c].[value]('(@dts:ObjectName)', 'VARCHAR(128)') = 'Shrink Database Task';

                            end;

                        /*Find repetitive maintenance tasks*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 181)
                            and
                           CONVERT(varchar(128), SERVERPROPERTY('productversion')) like '1%' /* Only run on 2008+ */
                            begin
                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 181) with nowait;

                                with xmlnamespaces ('www.microsoft.com/SqlServer/Dts' as [dts])
                                   , [maintenance_plan_steps] as (
                                    select [name]
                                   , CAST(CAST([packagedata] as varbinary (max)) as xml) as [maintenance_plan_xml]
                                    from [msdb].[dbo].[sysssispackages]
                                    where [packagetype] = 6
                                    )
                                   , [maintenance_plan_table] as (
                                    select [mps].[name]
                                   , [c].[value]('(@dts:ObjectName)'
                                   , 'NVARCHAR(128)') as [step_name]
                                    from [maintenance_plan_steps] [mps]
                                    cross apply [maintenance_plan_xml].[nodes]('//dts:Executables/dts:Executable') [t]([c])
                                    )
                                   , [mp_steps_pretty] as (select distinct [m1].[name]
                                   , STUFF((select N', ' + [m2].[step_name] from [maintenance_plan_table] as [m2] where [m1].[name] = [m2].[name]
                                    for xml path (N''))
                                   , 1
                                   , 2
                                   , N'') as [maintenance_plan_steps]
                                    from [maintenance_plan_table] as [m1])

                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])

                                select 181                                                                                                     as [CheckID],
                                       100                                                                                                     as [Priority],
                                       'Performance'                                                                                           as [FindingsGroup],
                                       'Repetitive Steps In Maintenance Plans'                                                                 as [Finding],
                                       'https://ola.hallengren.com/'                                                                           as [URL],
                                       'The maintenance plan ' + [m].[name] +
                                       ' is doing repetitive work on indexes and statistics. Perhaps it''s time to try something more modern?' as [Details]
                                from [mp_steps_pretty] m
                                where m.[maintenance_plan_steps] like '%Rebuild%Reorganize%'
                                   or m.[maintenance_plan_steps] like '%Rebuild%Update%';

                            end;


                        /* Reliability - No Failover Cluster Nodes Available - 184 */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 184)
                            and CAST(SERVERPROPERTY('ProductVersion') as nvarchar(128)) not like '10%'
                            and CAST(SERVERPROPERTY('ProductVersion') as nvarchar(128)) not like '9%'
                            begin
                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 184) with nowait;

                                set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        							SELECT TOP 1
							  184 AS CheckID ,
							  20 AS Priority ,
							  ''Reliability'' AS FindingsGroup ,
							  ''No Failover Cluster Nodes Available'' AS Finding ,
							  ''https://BrentOzar.com/go/node'' AS URL ,
							  ''There are no failover cluster nodes available if the active node fails'' AS Details
							FROM (
							  SELECT SUM(CASE WHEN [status] = 0 AND [is_current_owner] = 0 THEN 1 ELSE 0 END) AS [available_nodes]
							  FROM sys.dm_os_cluster_nodes
							) a
							WHERE [available_nodes] < 1 OPTION (RECOMPILE)';

                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);
                            end;

                        /* Reliability - TempDB File Error */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 191)
                            and (select COUNT(*) from sys.master_files where database_id = 2) <>
                                (select COUNT(*) from tempdb.sys.database_files)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 191) with nowait

                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])

                                select 191                                                                                                as [CheckID],
                                       50                                                                                                 as [Priority],
                                       'Reliability'                                                                                      as [FindingsGroup],
                                       'TempDB File Error'                                                                                as [Finding],
                                       'https://BrentOzar.com/go/tempdboops'                                                              as [URL],
                                       'Mismatch between the number of TempDB files in sys.master_files versus tempdb.sys.database_files' as [Details];
                            end;

/*Perf - Odd number of cores in a socket*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 198)
                            and EXISTS(select 1
                                       from sys.dm_os_schedulers
                                       where is_online = 1
                                         and scheduler_id < 255
                                         and parent_node_id < 64
                                       group by parent_node_id,
                                                is_online
                                       having (COUNT(cpu_id) + 2) % 2 = 1)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 198) with nowait

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 198                               as checkid,
                                       null                              as databasename,
                                       10                                as priority,
                                       'Performance'                     as findingsgroup,
                                       'CPU w/Odd Number of Cores'       as finding,
                                       'https://BrentOzar.com/go/oddity' as url,
                                       'Node ' + CONVERT(varchar(10), parent_node_id) + ' has ' +
                                       CONVERT(varchar(10), COUNT(cpu_id))
                                           + case
                                                 when COUNT(cpu_id) = 1
                                                     then ' core assigned to it. This is a really bad NUMA configuration.'
                                                 else ' cores assigned to it. This is a really bad NUMA configuration.'
                                           end                           as details
                                from sys.dm_os_schedulers
                                where is_online = 1
                                  and scheduler_id < 255
                                  and parent_node_id < 64
                                  and EXISTS(
                                        select 1
                                        from (select memory_node_id, SUM(online_scheduler_count) as schedulers
                                              from sys.dm_os_nodes
                                              where memory_node_id < 64
                                              group by memory_node_id) as nodes
                                        having MIN(nodes.schedulers) <> MAX(nodes.schedulers)
                                    )
                                group by parent_node_id,
                                         is_online
                                having (COUNT(cpu_id) + 2) % 2 = 1;

                            end;

                        /*Begin: checking default trace for odd DBCC activity*/

                        --Grab relevant event data
                        if @tracefileissue = 0
                            begin
                                select UPPER(
                                               REPLACE(
                                                       SUBSTRING(CONVERT(nvarchar(max), t.textdata), 0,
                                                                 ISNULL(
                                                                         NULLIF(
                                                                                 CHARINDEX('(', CONVERT(nvarchar(max), t.textdata)),
                                                                                 0),
                                                                         LEN(CONVERT(nvarchar(max), t.textdata)) + 1)) --This replaces everything up to an open paren, if one exists.
                                                   , SUBSTRING(CONVERT(nvarchar(max), t.textdata),
                                                               ISNULL(
                                                                       NULLIF(
                                                                               CHARINDEX(' WITH ', CONVERT(nvarchar(max), t.textdata))
                                                                           , 0),
                                                                       LEN(CONVERT(nvarchar(max), t.textdata)) + 1),
                                                               LEN(CONVERT(nvarchar(max), t.textdata)) + 1)
                                                   ,
                                                       '') --This replaces any optional WITH clause to a DBCC command, like tableresults.
                                           )                                                                   as [dbcc_event_trunc_upper],
                                       UPPER(
                                               REPLACE(
                                                       CONVERT(nvarchar(max), t.textdata), SUBSTRING(
                                                       CONVERT(nvarchar(max), t.textdata),
                                                       ISNULL(
                                                               NULLIF(
                                                                       CHARINDEX(' WITH ', CONVERT(nvarchar(max), t.textdata))
                                                                   , 0),
                                                               LEN(CONVERT(nvarchar(max), t.textdata)) + 1),
                                                       LEN(CONVERT(nvarchar(max), t.textdata)) + 1),
                                                       ''))                                                    as [dbcc_event_full_upper],
                                       MIN(t.starttime)
                                           over (partition by CONVERT(nvarchar(128), t.textdata))              as min_start_time,
                                       MAX(t.starttime)
                                           over (partition by CONVERT(nvarchar(128), t.textdata))              as max_start_time,
                                       t.ntusername                                                            as [nt_user_name],
                                       t.ntdomainname                                                          as [nt_domain_name],
                                       t.hostname                                                              as [host_name],
                                       t.applicationname                                                       as [application_name],
                                       t.loginname                                                                [login_name],
                                       t.dbusername                                                            as [db_user_name]
                                into #dbcc_events_from_trace
                                from #fntracegettable as t
                                where t.eventclass = 116
                                option (recompile)
                            end;

                        /*Overall count of DBCC events excluding silly stuff*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 203)
                            and @tracefileissue = 0
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 203) with nowait

                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])
                                select 203                                 as checkid,
                                       50                                  as priority,
                                       'DBCC Events'                       as findingsgroup,
                                       'Overall Events'                    as finding,
                                       'https://www.BrentOzar.com/go/dbcc' as url,
                                       CAST(COUNT(*) as nvarchar(100)) + ' DBCC events have taken place between ' +
                                       CONVERT(nvarchar(30), MIN(d.min_start_time)) + ' and ' +
                                       CONVERT(nvarchar(30), MAX(d.max_start_time)) +
                                       '. This does not include CHECKDB and other usually benign DBCC events.'
                                                                           as details
                                from #dbcc_events_from_trace d
                                    /* This WHERE clause below looks horrible, but it's because users can run stuff like
			   DBCC     LOGINFO
			   with lots of spaces (or carriage returns, or comments) in between the DBCC and the
			   command they're trying to run. See Github issues 1062, 1074, 1075.
			*/
                                where d.dbcc_event_full_upper not like '%DBCC%ADDINSTANCE%'
                                  and d.dbcc_event_full_upper not like '%DBCC%AUTOPILOT%'
                                  and d.dbcc_event_full_upper not like '%DBCC%CHECKALLOC%'
                                  and d.dbcc_event_full_upper not like '%DBCC%CHECKCATALOG%'
                                  and d.dbcc_event_full_upper not like '%DBCC%CHECKCONSTRAINTS%'
                                  and d.dbcc_event_full_upper not like '%DBCC%CHECKDB%'
                                  and d.dbcc_event_full_upper not like '%DBCC%CHECKFILEGROUP%'
                                  and d.dbcc_event_full_upper not like '%DBCC%CHECKIDENT%'
                                  and d.dbcc_event_full_upper not like '%DBCC%CHECKPRIMARYFILE%'
                                  and d.dbcc_event_full_upper not like '%DBCC%CHECKTABLE%'
                                  and d.dbcc_event_full_upper not like '%DBCC%CLEANTABLE%'
                                  and d.dbcc_event_full_upper not like '%DBCC%DBINFO%'
                                  and d.dbcc_event_full_upper not like '%DBCC%ERRORLOG%'
                                  and d.dbcc_event_full_upper not like '%DBCC%INCREMENTINSTANCE%'
                                  and d.dbcc_event_full_upper not like '%DBCC%INPUTBUFFER%'
                                  and d.dbcc_event_full_upper not like '%DBCC%LOGINFO%'
                                  and d.dbcc_event_full_upper not like '%DBCC%OPENTRAN%'
                                  and d.dbcc_event_full_upper not like '%DBCC%SETINSTANCE%'
                                  and d.dbcc_event_full_upper not like '%DBCC%SHOWFILESTATS%'
                                  and d.dbcc_event_full_upper not like '%DBCC%SHOW_STATISTICS%'
                                  and d.dbcc_event_full_upper not like '%DBCC%SQLPERF%NETSTATS%'
                                  and d.dbcc_event_full_upper not like '%DBCC%SQLPERF%LOGSPACE%'
                                  and d.dbcc_event_full_upper not like '%DBCC%TRACEON%'
                                  and d.dbcc_event_full_upper not like '%DBCC%TRACEOFF%'
                                  and d.dbcc_event_full_upper not like '%DBCC%TRACESTATUS%'
                                  and d.dbcc_event_full_upper not like '%DBCC%USEROPTIONS%'
                                  and d.application_name not like 'Critical Care(R) Collector'
                                  and d.application_name not like '%Red Gate Software Ltd SQL Prompt%'
                                  and d.application_name not like '%Spotlight Diagnostic Server%'
                                  and d.application_name not like '%SQL Diagnostic Manager%'
                                  and d.application_name not like 'SQL Server Checkup%'
                                  and d.application_name not like '%Sentry%'
                                  and d.application_name not like '%LiteSpeed%'
                                  and d.application_name not like '%SQL Monitor - Monitoring%'


                                having COUNT(*) > 0;

                            end;

                        /*Check for someone running drop clean buffers*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 207)
                            and @tracefileissue = 0
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 207) with nowait

                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])
                                select 207                                  as checkid,
                                       10                                   as priority,
                                       'Performance'                        as findingsgroup,
                                       'DBCC DROPCLEANBUFFERS Ran Recently' as finding,
                                       'https://www.BrentOzar.com/go/dbcc'  as url,
                                       'The user ' + COALESCE(d.nt_user_name, d.login_name) +
                                       ' has run DBCC DROPCLEANBUFFERS ' + CAST(COUNT(*) as nvarchar(100)) +
                                       ' times between ' + CONVERT(nvarchar(30), MIN(d.min_start_time)) + ' and ' +
                                       CONVERT(nvarchar(30), MAX(d.max_start_time)) +
                                       '. If this is a production box, know that you''re clearing all data out of memory when this happens. What kind of monster would do that?'
                                                                            as details
                                from #dbcc_events_from_trace d
                                where d.dbcc_event_full_upper = N'DBCC DROPCLEANBUFFERS'
                                group by COALESCE(d.nt_user_name, d.login_name)
                                having COUNT(*) > 0;

                            end;

                        /*Check for someone running free proc cache*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 208)
                            and @tracefileissue = 0
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 208) with nowait

                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])
                                select 208                                 as checkid,
                                       10                                  as priority,
                                       'DBCC Events'                       as findingsgroup,
                                       'DBCC FREEPROCCACHE Ran Recently'   as finding,
                                       'https://www.BrentOzar.com/go/dbcc' as url,
                                       'The user ' + COALESCE(d.nt_user_name, d.login_name) +
                                       ' has run DBCC FREEPROCCACHE ' + CAST(COUNT(*) as nvarchar(100)) +
                                       ' times between ' + CONVERT(nvarchar(30), MIN(d.min_start_time)) + ' and ' +
                                       CONVERT(nvarchar(30), MAX(d.max_start_time)) +
                                       '. This has bad idea jeans written all over its butt, like most other bad idea jeans.'
                                                                           as details
                                from #dbcc_events_from_trace d
                                where d.dbcc_event_full_upper = N'DBCC FREEPROCCACHE'
                                group by COALESCE(d.nt_user_name, d.login_name)
                                having COUNT(*) > 0;

                            end;

                        /*Check for someone clearing wait stats*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 205)
                            and @tracefileissue = 0
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 205) with nowait

                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])
                                select 205                                 as checkid,
                                       50                                  as priority,
                                       'Performance'                       as findingsgroup,
                                       'Wait Stats Cleared Recently'       as finding,
                                       'https://www.BrentOzar.com/go/dbcc' as url,
                                       'The user ' + COALESCE(d.nt_user_name, d.login_name) +
                                       ' has run DBCC SQLPERF(''SYS.DM_OS_WAIT_STATS'',CLEAR) ' +
                                       CAST(COUNT(*) as nvarchar(100)) + ' times between ' +
                                       CONVERT(nvarchar(30), MIN(d.min_start_time)) + ' and ' +
                                       CONVERT(nvarchar(30), MAX(d.max_start_time)) +
                                       '. Why are you clearing wait stats? What are you hiding?'
                                                                           as details
                                from #dbcc_events_from_trace d
                                where d.dbcc_event_full_upper = N'DBCC SQLPERF(''SYS.DM_OS_WAIT_STATS'',CLEAR)'
                                group by COALESCE(d.nt_user_name, d.login_name)
                                having COUNT(*) > 0;

                            end;

                        /*Check for someone writing to pages. Yeah, right?*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 209)
                            and @tracefileissue = 0
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 209) with nowait

                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])
                                select 209                                 as checkid,
                                       50                                  as priority,
                                       'Reliability'                       as findingsgroup,
                                       'DBCC WRITEPAGE Used Recently'      as finding,
                                       'https://www.BrentOzar.com/go/dbcc' as url,
                                       'The user ' + COALESCE(d.nt_user_name, d.login_name) +
                                       ' has run DBCC WRITEPAGE ' + CAST(COUNT(*) as nvarchar(100)) +
                                       ' times between ' + CONVERT(nvarchar(30), MIN(d.min_start_time)) + ' and ' +
                                       CONVERT(nvarchar(30), MAX(d.max_start_time)) +
                                       '. So, uh, are they trying to fix corruption, or cause corruption?'
                                                                           as details
                                from #dbcc_events_from_trace d
                                where d.dbcc_event_trunc_upper = N'DBCC WRITEPAGE'
                                group by COALESCE(d.nt_user_name, d.login_name)
                                having COUNT(*) > 0;

                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 210)
                            and @tracefileissue = 0
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 210) with nowait

                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])

                                select 210                                 as checkid,
                                       10                                  as priority,
                                       'Performance'                       as findingsgroup,
                                       'DBCC SHRINK% Ran Recently'         as finding,
                                       'https://www.BrentOzar.com/go/dbcc' as url,
                                       'The user ' + COALESCE(d.nt_user_name, d.login_name) + ' has run file shrinks ' +
                                       CAST(COUNT(*) as nvarchar(100)) + ' times between ' +
                                       CONVERT(nvarchar(30), MIN(d.min_start_time)) + ' and ' +
                                       CONVERT(nvarchar(30), MAX(d.max_start_time)) +
                                       '. So, uh, are they trying cause bad performance on purpose?'
                                                                           as details
                                from #dbcc_events_from_trace d
                                where d.dbcc_event_trunc_upper like N'DBCC SHRINK%'
                                group by COALESCE(d.nt_user_name, d.login_name)
                                having COUNT(*) > 0;

                            end;

                        /*End: checking default trace for odd DBCC activity*/

                        /*Begin check for autoshrink events*/

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 206)
                            and @tracefileissue = 0
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 206) with nowait

                                insert into [#BlitzResults]
                                ([CheckID],
                                 [Priority],
                                 [FindingsGroup],
                                 [Finding],
                                 [URL],
                                 [Details])

                                select 206                        as checkid,
                                       10                         as priority,
                                       'Performance'              as findingsgroup,
                                       'Auto-Shrink Ran Recently' as finding,
                                       ''                         as url,
                                       N'The database ' + QUOTENAME(t.databasename) + N' has had '
                                           + CONVERT(nvarchar(10), COUNT(*))
                                           + N' auto shrink events between '
                                           + CONVERT(nvarchar(30), MIN(t.starttime)) + ' and ' +
                                       CONVERT(nvarchar(30), MAX(t.starttime))
                                           + ' that lasted on average '
                                           + CONVERT(nvarchar(10), AVG(DATEDIFF(second, t.starttime, t.endtime)))
                                           + ' seconds.'          as details
                                from #fntracegettable as t
                                where t.eventclass in (94, 95)
                                group by t.databasename
                                having AVG(DATEDIFF(second, t.starttime, t.endtime)) > 5;

                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 215)
                            and @tracefileissue = 0
                            and EXISTS(select * from sys.all_columns where name = 'database_id'
                                                                       and object_id = OBJECT_ID('sys.dm_exec_sessions'))
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 215) with nowait

                                set @stringtoexecute = 'INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
                                      [DatabaseName] ,
									  [URL] ,
									  [Details] )

								SELECT	215 AS CheckID ,
										100 AS Priority ,
										''Performance'' AS FindingsGroup ,
										''Implicit Transactions'' AS Finding ,
										DB_NAME(s.database_id) AS DatabaseName,
										''https://www.brentozar.com/go/ImplicitTransactions/'' AS URL ,
										N''The database '' +
										DB_NAME(s.database_id)
										+ '' has ''
										+ CONVERT(NVARCHAR(20), COUNT_BIG(*))
										+ '' open implicit transactions with an oldest begin time of ''
										+ CONVERT(NVARCHAR(30), MIN(tat.transaction_begin_time))
										+ '' Run sp_BlitzWho and check the is_implicit_transaction column to see the culprits.'' AS details
								FROM    sys.dm_tran_active_transactions AS tat
								LEFT JOIN sys.dm_tran_session_transactions AS tst
								ON tst.transaction_id = tat.transaction_id
								LEFT JOIN sys.dm_exec_sessions AS s
								ON s.session_id = tst.session_id
								WHERE tat.name = ''implicit_transaction''
								GROUP BY DB_NAME(s.database_id), transaction_type, transaction_state;';


                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                if @debug = 2 and @stringtoexecute is null
                                    print '@StringToExecute has gone NULL, for some reason.';

                                execute (@stringtoexecute);


                            end;


                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 221)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 221) with nowait;

                                with reboot_airhorn
                                         as
                                         (
                                             select create_date
                                             from sys.databases
                                             where database_id = 2
                                             union all
                                             select CAST(
                                                            DATEADD(second, (ms_ticks / 1000) * (-1), GETDATE()) as datetime)
                                             from sys.dm_os_sys_info
                                         )
                                insert
                                into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 221                                                   as checkid,
                                       10                                                    as priority,
                                       'Reliability'                                         as findingsgroup,
                                       'Server restarted in last 24 hours'                   as finding,
                                       ''                                                    as url,
                                       'Surprise! Your server was last restarted on: ' +
                                       CONVERT(varchar(30), MAX(reboot_airhorn.create_date)) as details
                                from reboot_airhorn
                                having MAX(reboot_airhorn.create_date) >= DATEADD(hour, -24, GETDATE());


                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 229)
                            and CAST(SERVERPROPERTY('Edition') as nvarchar(4000)) like '%Evaluation%'
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 229) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 229 as                                                                            checkid,
                                       1 as                                                                              priority,
                                       'Reliability' as                                                                  findingsgroup,
                                       'Evaluation Edition' as                                                           finding,
                                       'https://www.BrentOzar.com/go/workgroup' as                                       url,
                                       'This server will stop working on: ' + CAST(
                                               CONVERT(datetime, DATEADD(dd, 180, create_date), 102) as varchar(100)) as details
                                from sys.server_principals
                                where sid = 0x010100000000000512000000;

                            end;


                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 233)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 233) with nowait;


                                if EXISTS(select *
                                          from sys.all_columns
                                          where object_id = OBJECT_ID('sys.dm_os_memory_clerks') and name = 'pages_kb')
                                    begin
                                        /* SQL 2012+ version */
                                        set @stringtoexecute = N'
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
							SELECT 233 AS CheckID,
							       50 AS Priority,
							       ''Performance'' AS FindingsGroup,
							       ''Memory Leak in USERSTORE_TOKENPERM Cache'' AS Finding,
							       ''https://www.BrentOzar.com/go/userstore'' AS URL,
							       N''UserStore_TokenPerm clerk is using '' + CAST(CAST(SUM(CASE WHEN type = ''USERSTORE_TOKENPERM'' AND name = ''TokenAndPermUserStore'' THEN pages_kb * 1.0 ELSE 0.0 END) / 1024.0 / 1024.0 AS INT) AS NVARCHAR(100))
								   		+ N''GB RAM, total buffer pool is '' + CAST(CAST(SUM(pages_kb) / 1024.0 / 1024.0 AS INT) AS NVARCHAR(100)) + N''GB.''
								   AS details
							FROM sys.dm_os_memory_clerks
							HAVING SUM(CASE WHEN type = ''USERSTORE_TOKENPERM'' AND name = ''TokenAndPermUserStore'' THEN pages_kb * 1.0 ELSE 0.0 END) / SUM(pages_kb) >= 0.1
							  AND SUM(pages_kb) / 1024.0 / 1024.0 >= 1; /* At least 1GB RAM overall */';
                                        exec sp_executesql @stringtoexecute;
                                    end
                                else
                                    begin
                                        /* Antiques Roadshow SQL 2008R2 - version */
                                        set @stringtoexecute = N'
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
							SELECT 233 AS CheckID,
							       50 AS Priority,
							       ''Performance'' AS FindingsGroup,
							       ''Memory Leak in USERSTORE_TOKENPERM Cache'' AS Finding,
							       ''https://www.BrentOzar.com/go/userstore'' AS URL,
							       N''UserStore_TokenPerm clerk is using '' + CAST(CAST(SUM(CASE WHEN type = ''USERSTORE_TOKENPERM'' AND name = ''TokenAndPermUserStore'' THEN single_pages_kb + multi_pages_kb * 1.0 ELSE 0.0 END) / 1024.0 / 1024.0 AS INT) AS NVARCHAR(100))
								   		+ N''GB RAM, total buffer pool is '' + CAST(CAST(SUM(single_pages_kb + multi_pages_kb) / 1024.0 / 1024.0 AS INT) AS NVARCHAR(100)) + N''GB.''
								   AS details
							FROM sys.dm_os_memory_clerks
							HAVING SUM(CASE WHEN type = ''USERSTORE_TOKENPERM'' AND name = ''TokenAndPermUserStore'' THEN single_pages_kb + multi_pages_kb * 1.0 ELSE 0.0 END) / SUM(single_pages_kb + multi_pages_kb) >= 0.1
							  AND SUM(single_pages_kb + multi_pages_kb) / 1024.0 / 1024.0 >= 1; /* At least 1GB RAM overall */';
                                        exec sp_executesql @stringtoexecute;
                                    end

                            end;


                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 234)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 234) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 databasename,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 234                                                                                                                                                                                                                     as checkid,
                                       100                                                                                                                                                                                                                     as priority,
                                       db_name(f.database_id)                                                                                                                                                                                                  as databasename,
                                       'Reliability'                                                                                                                                                                                                           as findingsgroup,
                                       'SQL Server Update May Fail'                                                                                                                                                                                            as finding,
                                       'https://desertdba.com/failovers-cant-serve-two-masters/'                                                                                                                                                               as url,
                                       'This database has a file with a logical name of ''master'', which can break SQL Server updates. Rename it in SSMS by right-clicking on the database, go into Properties, and rename the file. Takes effect instantly.' as details
                                from master.sys.master_files f
                                where (f.name = N'master')
                                  and f.database_id > 4
                                  and db_name(f.database_id) <> 'master'; /* Thanks Michaels3 for catching this */
                            end;


                        if @checkuserdatabaseobjects = 1
                            begin

                                if @debug in (1, 2)
                                    raiserror ('Starting @CheckUserDatabaseObjects section.', 0, 1) with nowait

                                /*
                        But what if you need to run a query in every individual database?
				        Check out CheckID 99 below. Yes, it uses sp_MSforeachdb, and no,
				        we're not happy about that. sp_MSforeachdb is known to have a lot
				        of issues, like skipping databases sometimes. However, this is the
				        only built-in option that we have. If you're writing your own code
				        for database maintenance, consider Aaron Bertrand's alternative:
				        http://www.mssqltips.com/sqlservertip/2201/making-a-more-reliable-and-flexible-spmsforeachdb/
				        We don't include that as part of sp_Blitz, of course, because
				        copying and distributing copyrighted code from others without their
				        written permission isn't a good idea.
				        */
                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 99)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 99) with nowait;

                                        exec dbo.sp_msforeachdb
                                             'USE [?]; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; IF EXISTS (SELECT * FROM  sys.tables WITH (NOLOCK) WHERE name = ''sysmergepublications'' ) IF EXISTS ( SELECT * FROM sysmergepublications WITH (NOLOCK) WHERE retention = 0)   INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details) SELECT DISTINCT 99, DB_NAME(), 110, ''Performance'', ''Infinite merge replication metadata retention period'', ''https://BrentOzar.com/go/merge'', (''The ['' + DB_NAME() + ''] database has merge replication metadata retention period set to infinite - this can be the case of significant performance issues.'')';
                                    end;
                                /*
				        Note that by using sp_MSforeachdb, we're running the query in all
				        databases. We're not checking #SkipChecks here for each database to
				        see if we should run the check in this database. That means we may
				        still run a skipped check if it involves sp_MSforeachdb. We just
				        don't output those results in the last step.
                        */

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 163)
                                    and EXISTS(
                                           select * from sys.all_objects where name = 'database_query_store_options')
                                    begin
                                        /* --TOURSTOP03-- */

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 163) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
                                        SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
			                            INSERT INTO #BlitzResults
			                            (CheckID,
			                            DatabaseName,
			                            Priority,
			                            FindingsGroup,
			                            Finding,
			                            URL,
			                            Details)
		                              SELECT TOP 1 163,
		                              N''?'',
		                              200,
		                              ''Performance'',
		                              ''Query Store Disabled'',
		                              ''https://BrentOzar.com/go/querystore'',
		                              (''The new SQL Server 2016 Query Store feature has not been enabled on this database.'')
		                              FROM [?].sys.database_query_store_options WHERE desired_state = 0
									  AND N''?'' NOT IN (''master'', ''model'', ''msdb'', ''tempdb'', ''DWConfiguration'', ''DWDiagnostics'', ''DWQueue'', ''ReportServer'', ''ReportServerTempDB'') OPTION (RECOMPILE)';
                                    end;


                                if @productversionmajor >= 13 and @productversionminor < 2149 --CU1 has the fix in it
                                    and not EXISTS(select 1
                                                   from #skipchecks
                                                   where databasename is null
                                                     and checkid = 182)
                                    and CAST(SERVERPROPERTY('edition') as varchar(100)) not like '%Enterprise%'
                                    and CAST(SERVERPROPERTY('edition') as varchar(100)) not like '%Developer%'
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 182) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults
													(CheckID,
													DatabaseName,
													Priority,
													FindingsGroup,
													Finding,
													URL,
													Details)
													SELECT TOP 1
													182,
													''Server'',
													20,
													''Reliability'',
													''Query Store Cleanup Disabled'',
													''https://BrentOzar.com/go/cleanup'',
													(''SQL 2016 RTM has a bug involving dumps that happen every time Query Store cleanup jobs run. This is fixed in CU1 and later: https://sqlserverupdates.com/sql-server-2016-updates/'')
													FROM    sys.databases AS d
													WHERE   d.is_query_store_on = 1 OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 41)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 41) with nowait;

                                        exec dbo.sp_msforeachdb 'use [?];
		                              SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                      INSERT INTO #BlitzResults
		                              (CheckID,
		                              DatabaseName,
		                              Priority,
		                              FindingsGroup,
		                              Finding,
		                              URL,
		                              Details)
		                              SELECT 41,
		                              N''?'',
		                              170,
		                              ''File Configuration'',
		                              ''Multiple Log Files on One Drive'',
		                              ''https://BrentOzar.com/go/manylogs'',
		                              (''The ['' + DB_NAME() + ''] database has multiple log files on the '' + LEFT(physical_name, 1) + '' drive. This is not a performance booster because log file access is sequential, not parallel.'')
		                              FROM [?].sys.database_files WHERE type_desc = ''LOG''
			                            AND N''?'' <> ''[tempdb]''
		                              GROUP BY LEFT(physical_name, 1)
		                              HAVING COUNT(*) > 1 OPTION (RECOMPILE);';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 42)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 42) with nowait;

                                        exec dbo.sp_msforeachdb 'use [?];
			                            SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                        INSERT INTO #BlitzResults
			                            (CheckID,
			                            DatabaseName,
			                            Priority,
			                            FindingsGroup,
			                            Finding,
			                            URL,
			                            Details)
			                            SELECT DISTINCT 42,
			                            N''?'',
			                            170,
			                            ''File Configuration'',
			                            ''Uneven File Growth Settings in One Filegroup'',
			                            ''https://BrentOzar.com/go/grow'',
			                            (''The ['' + DB_NAME() + ''] database has multiple data files in one filegroup, but they are not all set up to grow in identical amounts.  This can lead to uneven file activity inside the filegroup.'')
			                            FROM [?].sys.database_files
			                            WHERE type_desc = ''ROWS''
			                            GROUP BY data_space_id
			                            HAVING COUNT(DISTINCT growth) > 1 OR COUNT(DISTINCT is_percent_growth) > 1 OPTION (RECOMPILE);';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 82)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 82) with nowait;

                                        exec sp_MSforeachdb 'use [?];
		                                SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                        INSERT INTO #BlitzResults
		                                (CheckID,
		                                DatabaseName,
		                                Priority,
		                                FindingsGroup,
		                                Finding,
		                                URL, Details)
		                                SELECT  DISTINCT 82 AS CheckID,
		                                N''?'' as DatabaseName,
		                                170 AS Priority,
		                                ''File Configuration'' AS FindingsGroup,
		                                ''File growth set to percent'',
		                                ''https://BrentOzar.com/go/percentgrowth'' AS URL,
		                                ''The ['' + DB_NAME() + ''] database file '' + f.physical_name + '' has grown to '' + CONVERT(NVARCHAR(10), CONVERT(NUMERIC(38, 2), (f.size / 128.) / 1024.)) + '' GB, and is using percent filegrowth settings. This can lead to slow performance during growths if Instant File Initialization is not enabled.''
		                                FROM    [?].sys.database_files f
		                                WHERE   is_percent_growth = 1 and size > 128000  OPTION (RECOMPILE);';
                                    end;

                                /* addition by Henrik Staun Poulsen, Stovi Software */
                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 158)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 158) with nowait;

                                        exec sp_MSforeachdb 'use [?];
		                                SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                        INSERT INTO #BlitzResults
		                                (CheckID,
		                                DatabaseName,
		                                Priority,
		                                FindingsGroup,
		                                Finding,
		                                URL, Details)
		                                SELECT  DISTINCT 158 AS CheckID,
		                                N''?'' as DatabaseName,
		                                170 AS Priority,
		                                ''File Configuration'' AS FindingsGroup,
		                                ''File growth set to 1MB'',
		                                ''https://BrentOzar.com/go/percentgrowth'' AS URL,
		                                ''The ['' + DB_NAME() + ''] database file '' + f.physical_name + '' is using 1MB filegrowth settings, but it has grown to '' + CAST((f.size * 8 / 1000000) AS NVARCHAR(10)) + '' GB. Time to up the growth amount.''
		                                FROM    [?].sys.database_files f
                                        WHERE is_percent_growth = 0 and growth=128 and size > 128000  OPTION (RECOMPILE);';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 33)
                                    begin
                                        if @@VERSION not like '%Microsoft SQL Server 2000%'
                                            and @@VERSION not like '%Microsoft SQL Server 2005%'
                                            and @skipblockingchecks = 0
                                            begin

                                                if @debug in (1, 2)
                                                    raiserror ('Running CheckId [%d].', 0, 1, 33) with nowait;

                                                exec dbo.sp_msforeachdb 'USE [?]; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                            INSERT INTO #BlitzResults
					                                (CheckID,
					                                DatabaseName,
					                                Priority,
					                                FindingsGroup,
					                                Finding,
					                                URL,
					                                Details)
		                                  SELECT DISTINCT 33,
		                                  db_name(),
		                                  200,
		                                  ''Licensing'',
		                                  ''Enterprise Edition Features In Use'',
		                                  ''https://BrentOzar.com/go/ee'',
		                                  (''The ['' + DB_NAME() + ''] database is using '' + feature_name + ''.  If this database is restored onto a Standard Edition server, the restore will fail on versions prior to 2016 SP1.'')
		                                  FROM [?].sys.dm_db_persisted_sku_features OPTION (RECOMPILE);';
                                            end;
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 19)
                                    begin
                                        /* Method 1: Check sys.databases parameters */

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 19) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         databasename,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)

                                        select 19                                                                 as checkid,
                                               [name]                                                             as databasename,
                                               200                                                                as priority,
                                               'Informational'                                                    as findingsgroup,
                                               'Replication In Use'                                               as finding,
                                               'https://BrentOzar.com/go/repl'                                    as url,
                                               ('Database [' + [name]
                                                   +
                                                '] is a replication publisher, subscriber, or distributor.')      as details
                                        from sys.databases
                                        where name not in (select distinct databasename
                                                           from #skipchecks
                                                           where checkid is null
                                                              or checkid = 19)
                                            and is_published = 1
                                           or is_subscribed = 1
                                           or is_merge_published = 1
                                           or is_distributor = 1;

                                        /* Method B: check subscribers for MSreplication_objects tables */
                                        exec dbo.sp_msforeachdb 'USE [?]; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                    INSERT INTO #BlitzResults
										        (CheckID,
										        DatabaseName,
										        Priority,
										        FindingsGroup,
										        Finding,
										        URL,
										        Details)
							          SELECT DISTINCT 19,
							          db_name(),
							          200,
							          ''Informational'',
							          ''Replication In Use'',
							          ''https://BrentOzar.com/go/repl'',
							          (''['' + DB_NAME() + ''] has MSreplication_objects tables in it, indicating it is a replication subscriber.'')
							          FROM [?].sys.tables
							          WHERE name = ''dbo.MSreplication_objects'' AND ''?'' <> ''master'' OPTION (RECOMPILE)';

                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 32)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 32) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
			SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
            INSERT INTO #BlitzResults
			(CheckID,
			DatabaseName,
			Priority,
			FindingsGroup,
			Finding,
			URL,
			Details)
			SELECT 32,
			N''?'',
			150,
			''Performance'',
			''Triggers on Tables'',
			''https://BrentOzar.com/go/trig'',
			(''The ['' + DB_NAME() + ''] database has '' + CAST(SUM(1) AS NVARCHAR(50)) + '' triggers.'')
			FROM [?].sys.triggers t INNER JOIN [?].sys.objects o ON t.parent_id = o.object_id
			INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id WHERE t.is_ms_shipped = 0 AND DB_NAME() != ''ReportServer''
			HAVING SUM(1) > 0 OPTION (RECOMPILE)';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 38)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 38) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
			SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
            INSERT INTO #BlitzResults
			(CheckID,
			DatabaseName,
			Priority,
			FindingsGroup,
			Finding,
			URL,
			Details)
		  SELECT DISTINCT 38,
		  N''?'',
		  110,
		  ''Performance'',
		  ''Active Tables Without Clustered Indexes'',
		  ''https://BrentOzar.com/go/heaps'',
		  (''The ['' + DB_NAME() + ''] database has heaps - tables without a clustered index - that are being actively queried.'')
		  FROM [?].sys.indexes i INNER JOIN [?].sys.objects o ON i.object_id = o.object_id
		  INNER JOIN [?].sys.partitions p ON i.object_id = p.object_id AND i.index_id = p.index_id
		  INNER JOIN sys.databases sd ON sd.name = N''?''
		  LEFT OUTER JOIN [?].sys.dm_db_index_usage_stats ius ON i.object_id = ius.object_id AND i.index_id = ius.index_id AND ius.database_id = sd.database_id
		  WHERE i.type_desc = ''HEAP'' AND COALESCE(NULLIF(ius.user_seeks,0), NULLIF(ius.user_scans,0), NULLIF(ius.user_lookups,0), NULLIF(ius.user_updates,0)) IS NOT NULL
		  AND sd.name <> ''tempdb'' AND sd.name <> ''DWDiagnostics'' AND o.is_ms_shipped = 0 AND o.type <> ''S'' OPTION (RECOMPILE)';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 164)
                                    and EXISTS(select * from sys.all_objects where name = 'fn_validate_plan_guide')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 164) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
			SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
            INSERT INTO #BlitzResults
			(CheckID,
			DatabaseName,
			Priority,
			FindingsGroup,
			Finding,
			URL,
			Details)
		  SELECT DISTINCT 164,
		  N''?'',
		  20,
		  ''Reliability'',
		  ''Plan Guides Failing'',
		  ''https://BrentOzar.com/go/misguided'',
		  (''The ['' + DB_NAME() + ''] database has plan guides that are no longer valid, so the queries involved may be failing silently.'')
		  FROM [?].sys.plan_guides g CROSS APPLY fn_validate_plan_guide(g.plan_guide_id) OPTION (RECOMPILE)';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 39)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 39) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
			SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
            INSERT INTO #BlitzResults
			(CheckID,
			DatabaseName,
			Priority,
			FindingsGroup,
			Finding,
			URL,
			Details)
		  SELECT DISTINCT 39,
		  N''?'',
		  150,
		  ''Performance'',
		  ''Inactive Tables Without Clustered Indexes'',
		  ''https://BrentOzar.com/go/heaps'',
		  (''The ['' + DB_NAME() + ''] database has heaps - tables without a clustered index - that have not been queried since the last restart.  These may be backup tables carelessly left behind.'')
		  FROM [?].sys.indexes i INNER JOIN [?].sys.objects o ON i.object_id = o.object_id
		  INNER JOIN [?].sys.partitions p ON i.object_id = p.object_id AND i.index_id = p.index_id
		  INNER JOIN sys.databases sd ON sd.name = N''?''
		  LEFT OUTER JOIN [?].sys.dm_db_index_usage_stats ius ON i.object_id = ius.object_id AND i.index_id = ius.index_id AND ius.database_id = sd.database_id
		  WHERE i.type_desc = ''HEAP'' AND COALESCE(NULLIF(ius.user_seeks,0), NULLIF(ius.user_scans,0), NULLIF(ius.user_lookups,0), NULLIF(ius.user_updates,0)) IS NULL
		  AND sd.name <> ''tempdb'' AND sd.name <> ''DWDiagnostics'' AND o.is_ms_shipped = 0 AND o.type <> ''S'' OPTION (RECOMPILE)';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 46)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 46) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
		  SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
          INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 46,
		  N''?'',
		  150,
		  ''Performance'',
		  ''Leftover Fake Indexes From Wizards'',
		  ''https://BrentOzar.com/go/hypo'',
		  (''The index ['' + DB_NAME() + ''].['' + s.name + ''].['' + o.name + ''].['' + i.name + ''] is a leftover hypothetical index from the Index Tuning Wizard or Database Tuning Advisor.  This index is not actually helping performance and should be removed.'')
		  from [?].sys.indexes i INNER JOIN [?].sys.objects o ON i.object_id = o.object_id INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id
		  WHERE i.is_hypothetical = 1 OPTION (RECOMPILE);';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 47)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 47) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
		  SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
          INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 47,
		  N''?'',
		  100,
		  ''Performance'',
		  ''Indexes Disabled'',
		  ''https://BrentOzar.com/go/ixoff'',
		  (''The index ['' + DB_NAME() + ''].['' + s.name + ''].['' + o.name + ''].['' + i.name + ''] is disabled.  This index is not actually helping performance and should either be enabled or removed.'')
		  from [?].sys.indexes i INNER JOIN [?].sys.objects o ON i.object_id = o.object_id INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id
		  WHERE i.is_disabled = 1 OPTION (RECOMPILE);';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 48)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 48) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
		  SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
          INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT DISTINCT 48,
		  N''?'',
		  150,
		  ''Performance'',
		  ''Foreign Keys Not Trusted'',
		  ''https://BrentOzar.com/go/trust'',
		  (''The ['' + DB_NAME() + ''] database has foreign keys that were probably disabled, data was changed, and then the key was enabled again.  Simply enabling the key is not enough for the optimizer to use this key - we have to alter the table using the WITH CHECK CHECK CONSTRAINT parameter.'')
		  from [?].sys.foreign_keys i INNER JOIN [?].sys.objects o ON i.parent_object_id = o.object_id INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id
		  WHERE i.is_not_trusted = 1 AND i.is_not_for_replication = 0 AND i.is_disabled = 0 AND N''?'' NOT IN (''master'', ''model'', ''msdb'', ''ReportServer'', ''ReportServerTempDB'') OPTION (RECOMPILE);';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 56)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 56) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
		  SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
          INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 56,
		  N''?'',
		  150,
		  ''Performance'',
		  ''Check Constraint Not Trusted'',
		  ''https://BrentOzar.com/go/trust'',
		  (''The check constraint ['' + DB_NAME() + ''].['' + s.name + ''].['' + o.name + ''].['' + i.name + ''] is not trusted - meaning, it was disabled, data was changed, and then the constraint was enabled again.  Simply enabling the constraint is not enough for the optimizer to use this constraint - we have to alter the table using the WITH CHECK CHECK CONSTRAINT parameter.'')
		  from [?].sys.check_constraints i INNER JOIN [?].sys.objects o ON i.parent_object_id = o.object_id
		  INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id
		  WHERE i.is_not_trusted = 1 AND i.is_not_for_replication = 0 AND i.is_disabled = 0 OPTION (RECOMPILE);';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 95)
                                    begin
                                        if @@VERSION not like '%Microsoft SQL Server 2000%'
                                            and @@VERSION not like '%Microsoft SQL Server 2005%'
                                            begin

                                                if @debug in (1, 2)
                                                    raiserror ('Running CheckId [%d].', 0, 1, 95) with nowait;

                                                exec dbo.sp_msforeachdb 'USE [?];
			SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
            INSERT INTO #BlitzResults
				  (CheckID,
				  DatabaseName,
				  Priority,
				  FindingsGroup,
				  Finding,
				  URL,
				  Details)
			SELECT TOP 1 95 AS CheckID,
			N''?'' as DatabaseName,
			110 AS Priority,
			''Performance'' AS FindingsGroup,
			''Plan Guides Enabled'' AS Finding,
			''https://BrentOzar.com/go/guides'' AS URL,
			(''Database ['' + DB_NAME() + ''] has query plan guides so a query will always get a specific execution plan. If you are having trouble getting query performance to improve, it might be due to a frozen plan. Review the DMV sys.plan_guides to learn more about the plan guides in place on this server.'') AS Details
			FROM [?].sys.plan_guides WHERE is_disabled = 0 OPTION (RECOMPILE);';
                                            end;
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 60)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 60) with nowait;

                                        exec sp_MSforeachdb 'USE [?];
		  SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
          INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 60 AS CheckID,
		  N''?'' as DatabaseName,
		  100 AS Priority,
		  ''Performance'' AS FindingsGroup,
		  ''Fill Factor Changed'',
		  ''https://BrentOzar.com/go/fillfactor'' AS URL,
		  ''The ['' + DB_NAME() + ''] database has '' + CAST(SUM(1) AS NVARCHAR(50)) + '' objects with fill factor = '' + CAST(fill_factor AS NVARCHAR(5)) + ''%. This can cause memory and storage performance problems, but may also prevent page splits.''
		  FROM    [?].sys.indexes
		  WHERE   fill_factor <> 0 AND fill_factor < 80 AND is_disabled = 0 AND is_hypothetical = 0
		  GROUP BY fill_factor OPTION (RECOMPILE);';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 78)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 78) with nowait;

                                        execute master.sys.sp_msforeachdb 'USE [?];
                                    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                    INSERT INTO #Recompile
                                    SELECT DISTINCT DBName = DB_Name(), SPName = SO.name, SM.is_recompiled, ISR.SPECIFIC_SCHEMA
                                    FROM sys.sql_modules AS SM
                                    LEFT OUTER JOIN master.sys.databases AS sDB ON SM.object_id = DB_id()
                                    LEFT OUTER JOIN dbo.sysobjects AS SO ON SM.object_id = SO.id and type = ''P''
                                    LEFT OUTER JOIN INFORMATION_SCHEMA.ROUTINES AS ISR on ISR.Routine_Name = SO.name AND ISR.SPECIFIC_CATALOG = DB_Name()
                                    WHERE SM.is_recompiled=1  OPTION (RECOMPILE); /* oh the rich irony of recompile here */
                                    ';
                                        insert into #blitzresults
                                        (priority,
                                         findingsgroup,
                                         finding,
                                         databasename,
                                         url,
                                         details,
                                         checkid)
                                        select [Priority]    = '100',
                                               findingsgroup = 'Performance',
                                               finding       = 'Stored Procedure WITH RECOMPILE',
                                               databasename  = dbname,
                                               url           = 'https://BrentOzar.com/go/recompile',
                                               details       = '[' + dbname + '].[' + spschema + '].[' + procname +
                                                               '] has WITH RECOMPILE in the stored procedure code, which may cause increased CPU usage due to constant recompiles of the code.',
                                               checkid       = '78'
                                        from #recompile as tr
                                        where procname not like 'sp_AllNightLog%'
                                          and procname not like 'sp_AskBrent%'
                                          and procname not like 'sp_Blitz%';
                                        drop table #recompile;
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 86)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 86) with nowait;

                                        exec dbo.sp_msforeachdb
                                             'USE [?]; INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details) SELECT DISTINCT 86, DB_NAME(), 230, ''Security'', ''Elevated Permissions on a Database'', ''https://BrentOzar.com/go/elevated'', (''In ['' + DB_NAME() + ''], user ['' + u.name + '']  has the role ['' + g.name + ''].  This user can perform tasks beyond just reading and writing data.'') FROM (SELECT memberuid = convert(int, member_principal_id), groupuid = convert(int, role_principal_id) FROM [?].sys.database_role_members) m inner join [?].dbo.sysusers u on m.memberuid = u.uid inner join sysusers g on m.groupuid = g.uid where u.name <> ''dbo'' and g.name in (''db_owner'' , ''db_accessadmin'' , ''db_securityadmin'' , ''db_ddladmin'') OPTION (RECOMPILE);';
                                    end;

                                /*Check for non-aligned indexes in partioned databases*/

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 72)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 72) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
								SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                insert into #partdb(dbname, objectname, type_desc)
								SELECT distinct db_name(DB_ID()) as DBName,o.name Object_Name,ds.type_desc
								FROM sys.objects AS o JOIN sys.indexes AS i ON o.object_id = i.object_id
								JOIN sys.data_spaces ds on ds.data_space_id = i.data_space_id
								LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s ON i.object_id = s.object_id AND i.index_id = s.index_id AND s.database_id = DB_ID()
								WHERE  o.type = ''u''
								 -- Clustered and Non-Clustered indexes
								AND i.type IN (1, 2)
								AND o.object_id in
								  (
									SELECT a.object_id from
									  (SELECT ob.object_id, ds.type_desc from sys.objects ob JOIN sys.indexes ind on ind.object_id = ob.object_id join sys.data_spaces ds on ds.data_space_id = ind.data_space_id
									  GROUP BY ob.object_id, ds.type_desc ) a group by a.object_id having COUNT (*) > 1
								  )  OPTION (RECOMPILE);';
                                        insert into #blitzresults
                                        (checkid,
                                         databasename,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select distinct 72                                                                                                    as checkid,
                                                        dbname                                                                                                as databasename,
                                                        100                                                                                                   as priority,
                                                        'Performance'                                                                                         as findingsgroup,
                                                        'The partitioned database ' + dbname
                                                            +
                                                        ' may have non-aligned indexes'                                                                       as finding,
                                                        'https://BrentOzar.com/go/aligned'                                                                    as url,
                                                        'Having non-aligned indexes on partitioned tables may cause inefficient query plans and CPU pressure' as details
                                        from #partdb
                                        where dbname is not null
                                          and dbname not in (select distinct databasename
                                                             from #skipchecks
                                                             where checkid is null
                                                                or checkid = 72);
                                        drop table #partdb;
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 113)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 113) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
							  SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                              INSERT INTO #BlitzResults
									(CheckID,
									DatabaseName,
									Priority,
									FindingsGroup,
									Finding,
									URL,
									Details)
							  SELECT DISTINCT 113,
							  N''?'',
							  50,
							  ''Reliability'',
							  ''Full Text Indexes Not Updating'',
							  ''https://BrentOzar.com/go/fulltext'',
							  (''At least one full text index in this database has not been crawled in the last week.'')
							  from [?].sys.fulltext_indexes i WHERE change_tracking_state_desc <> ''AUTO'' AND i.is_enabled = 1 AND i.crawl_end_date < DATEADD(dd, -7, GETDATE())  OPTION (RECOMPILE);';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 115)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 115) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
		  SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
          INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 115,
		  N''?'',
		  110,
		  ''Performance'',
		  ''Parallelism Rocket Surgery'',
		  ''https://BrentOzar.com/go/makeparallel'',
		  (''['' + DB_NAME() + ''] has a make_parallel function, indicating that an advanced developer may be manhandling SQL Server into forcing queries to go parallel.'')
		  from [?].INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_NAME = ''make_parallel'' AND ROUTINE_TYPE = ''FUNCTION'' OPTION (RECOMPILE);';
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 122)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 122) with nowait;

                                        /* SQL Server 2012 and newer uses temporary stats for Availability Groups, and those show up as user-created */
                                        if EXISTS(select *
                                                  from sys.all_columns c
                                                           inner join sys.all_objects o on c.object_id = o.object_id
                                                  where c.name = 'is_temporary'
                                                    and o.name = 'stats')
                                            exec dbo.sp_msforeachdb 'USE [?];
												SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                                INSERT INTO #BlitzResults
													(CheckID,
													DatabaseName,
													Priority,
													FindingsGroup,
													Finding,
													URL,
													Details)
												SELECT TOP 1 122,
												N''?'',
												200,
												''Performance'',
												''User-Created Statistics In Place'',
												''https://BrentOzar.com/go/userstats'',
												(''['' + DB_NAME() + ''] has '' + CAST(SUM(1) AS NVARCHAR(10)) + '' user-created statistics. This indicates that someone is being a rocket scientist with the stats, and might actually be slowing things down, especially during stats updates.'')
												from [?].sys.stats WHERE user_created = 1 AND is_temporary = 0
                                                HAVING SUM(1) > 0  OPTION (RECOMPILE);';

                                        else
                                            exec dbo.sp_msforeachdb 'USE [?];
												SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                                INSERT INTO #BlitzResults
													(CheckID,
													DatabaseName,
													Priority,
													FindingsGroup,
													Finding,
													URL,
													Details)
												SELECT 122,
												N''?'',
												200,
												''Performance'',
												''User-Created Statistics In Place'',
												''https://BrentOzar.com/go/userstats'',
												(''['' + DB_NAME() + ''] has '' + CAST(SUM(1) AS NVARCHAR(10)) + '' user-created statistics. This indicates that someone is being a rocket scientist with the stats, and might actually be slowing things down, especially during stats updates.'')
												from [?].sys.stats WHERE user_created = 1
                                                HAVING SUM(1) > 0 OPTION (RECOMPILE);';

                                    end;
                                /* IF NOT EXISTS ( SELECT  1 */

                                /*Check for high VLF count: this will omit any database snapshots*/

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 69)
                                    begin
                                        if @productversionmajor >= 11
                                            begin

                                                if @debug in (1, 2)
                                                    raiserror ('Running CheckId [%d] (2012 version of Log Info).', 0, 1, 69) with nowait;

                                                exec sp_MSforeachdb N'USE [?];
		                                      SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                              INSERT INTO #LogInfo2012
		                                      EXEC sp_executesql N''DBCC LogInfo() WITH NO_INFOMSGS'';
		                                      IF    @@ROWCOUNT > 999
		                                      BEGIN
			                                    INSERT  INTO #BlitzResults
			                                    ( CheckID
			                                    ,DatabaseName
			                                    ,Priority
			                                    ,FindingsGroup
			                                    ,Finding
			                                    ,URL
			                                    ,Details)
			                                    SELECT      69
			                                    ,DB_NAME()
			                                    ,170
			                                    ,''File Configuration''
			                                    ,''High VLF Count''
			                                    ,''https://BrentOzar.com/go/vlf''
			                                    ,''The ['' + DB_NAME() + ''] database has '' +  CAST(COUNT(*) as VARCHAR(20)) + '' virtual log files (VLFs). This may be slowing down startup, restores, and even inserts/updates/deletes.''
			                                    FROM #LogInfo2012
			                                    WHERE EXISTS (SELECT name FROM master.sys.databases
					                                    WHERE source_database_id is null)  OPTION (RECOMPILE);
		                                      END
		                                    TRUNCATE TABLE #LogInfo2012;';
                                                drop table #loginfo2012;
                                            end;
                                        else
                                            begin

                                                if @debug in (1, 2)
                                                    raiserror ('Running CheckId [%d] (pre-2012 version of Log Info).', 0, 1, 69) with nowait;

                                                exec sp_MSforeachdb N'USE [?];
		                                      SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                              INSERT INTO #LogInfo
		                                      EXEC sp_executesql N''DBCC LogInfo() WITH NO_INFOMSGS'';
		                                      IF    @@ROWCOUNT > 999
		                                      BEGIN
			                                    INSERT  INTO #BlitzResults
			                                    ( CheckID
			                                    ,DatabaseName
			                                    ,Priority
			                                    ,FindingsGroup
			                                    ,Finding
			                                    ,URL
			                                    ,Details)
			                                    SELECT      69
			                                    ,DB_NAME()
			                                    ,170
			                                    ,''File Configuration''
			                                    ,''High VLF Count''
			                                    ,''https://BrentOzar.com/go/vlf''
			                                    ,''The ['' + DB_NAME() + ''] database has '' +  CAST(COUNT(*) as VARCHAR(20)) + '' virtual log files (VLFs). This may be slowing down startup, restores, and even inserts/updates/deletes.''
			                                    FROM #LogInfo
			                                    WHERE EXISTS (SELECT name FROM master.sys.databases
			                                    WHERE source_database_id is null) OPTION (RECOMPILE);
		                                      END
		                                      TRUNCATE TABLE #LogInfo;';
                                                drop table #loginfo;
                                            end;
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 80)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 80) with nowait;

                                        exec dbo.sp_msforeachdb 'USE [?];
                                    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                    INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details)
                                    SELECT DISTINCT 80, DB_NAME(), 170, ''Reliability'', ''Max File Size Set'', ''https://BrentOzar.com/go/maxsize'',
                                    (''The ['' + DB_NAME() + ''] database file '' + df.name + '' has a max file size set to ''
                                        + CAST(CAST(df.max_size AS BIGINT) * 8 / 1024 AS VARCHAR(100))
                                        + ''MB. If it runs out of space, the database will stop working even though there may be drive space available.'')
                                    FROM sys.database_files df
                                    WHERE 0 = (SELECT is_read_only FROM sys.databases WHERE name = ''?'')
                                      AND df.max_size <> 268435456
                                      AND df.max_size <> -1
                                      AND df.type <> 2
                                      AND df.growth > 0
                                      AND df.name <> ''DWDiagnostics'' OPTION (RECOMPILE);';

                                        delete br
                                        from #blitzresults br
                                                 inner join #skipchecks sc on sc.checkid = 80 and br.databasename = sc.databasename;
                                    end;


                                /* Check if columnstore indexes are in use - for Github issue #615 */
                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 74) /* Trace flags */
                                    begin
                                        truncate table #temporarydatabaseresults;

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 74) with nowait;

                                        exec dbo.sp_msforeachdb
                                             'USE [?]; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; IF EXISTS(SELECT * FROM sys.indexes WHERE type IN (5,6)) INSERT INTO #TemporaryDatabaseResults (DatabaseName, Finding) VALUES (DB_NAME(), ''Yup'') OPTION (RECOMPILE);';
                                        if EXISTS(select * from #temporarydatabaseresults)
                                            set @columnstoreindexesinuse = 1;
                                    end;

                                /* Non-Default Database Scoped Config - Github issue #598 */
                                if EXISTS(select * from sys.all_objects where [name] = 'database_scoped_configurations')
                                    begin

                                        if @debug in (1, 2)
                                            raiserror ('Running CheckId [%d] through [%d].', 0, 1, 194, 197) with nowait;

                                        insert into #databasescopedconfigurationdefaults (configuration_id, [name],
                                                                                          default_value,
                                                                                          default_value_for_secondary,
                                                                                          checkid)
                                        select 1, 'MAXDOP', 0, null, 194
                                        union all
                                        select 2, 'LEGACY_CARDINALITY_ESTIMATION', 0, null, 195
                                        union all
                                        select 3, 'PARAMETER_SNIFFING', 1, null, 196
                                        union all
                                        select 4, 'QUERY_OPTIMIZER_HOTFIXES', 0, null, 197;
                                        exec dbo.sp_msforeachdb 'USE [?]; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details)
									SELECT def1.CheckID, DB_NAME(), 210, ''Non-Default Database Scoped Config'', dsc.[name], ''https://BrentOzar.com/go/dbscope'', (''Set value: '' + COALESCE(CAST(dsc.value AS NVARCHAR(100)),''Empty'') + '' Default: '' + COALESCE(CAST(def1.default_value AS NVARCHAR(100)),''Empty'') + '' Set value for secondary: '' + COALESCE(CAST(dsc.value_for_secondary AS NVARCHAR(100)),''Empty'') + '' Default value for secondary: '' + COALESCE(CAST(def1.default_value_for_secondary AS NVARCHAR(100)),''Empty''))
									FROM [?].sys.database_scoped_configurations dsc
									INNER JOIN #DatabaseScopedConfigurationDefaults def1 ON dsc.configuration_id = def1.configuration_id
									LEFT OUTER JOIN #DatabaseScopedConfigurationDefaults def ON dsc.configuration_id = def.configuration_id AND (dsc.value = def.default_value OR dsc.value IS NULL) AND (dsc.value_for_secondary = def.default_value_for_secondary OR dsc.value_for_secondary IS NULL)
									LEFT OUTER JOIN #SkipChecks sk ON (sk.CheckID IS NULL OR def.CheckID = sk.CheckID) AND (sk.DatabaseName IS NULL OR sk.DatabaseName = DB_NAME())
									WHERE def.configuration_id IS NULL AND sk.CheckID IS NULL ORDER BY 1
									 OPTION (RECOMPILE);';
                                    end;

                                /* Check 218 - Show me the dodgy SET Options */
                                if not EXISTS(
                                        select 1
                                        from #skipchecks
                                        where databasename is null
                                          and checkid = 218
                                    )
                                    begin
                                        if @debug in (1, 2)
                                            begin
                                                raiserror ('Running CheckId [%d].',0,1,218) with nowait;
                                            end

                                        execute sp_MSforeachdb 'USE [?];
					SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                    INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details)
					SELECT 218 AS CheckID
						,''?'' AS DatabaseName
						,150 AS Priority
						,''Performance'' AS FindingsGroup
						,''Objects created with dangerous SET Options'' AS Finding
						,''https://BrentOzar.com/go/badset'' AS URL
						,''The '' + QUOTENAME(DB_NAME())
							+ '' database has '' + CONVERT(VARCHAR(20),COUNT(1))
							+ '' objects that were created with dangerous ANSI_NULL or QUOTED_IDENTIFIER options.''
							+ '' These objects can break when using filtered indexes, indexed views''
							+ '' and other advanced SQL features.'' AS Details
					FROM sys.sql_modules sm
					JOIN sys.objects o ON o.[object_id] = sm.[object_id]
						AND (
							sm.uses_ansi_nulls <> 1
							OR sm.uses_quoted_identifier <> 1
							)
						AND o.is_ms_shipped = 0
					HAVING COUNT(1) > 0;';
                                    end;
                                --of Check 218.

                                /* Check 225 - Reliability - Resumable Index Operation Paused */
                                if not EXISTS(
                                        select 1
                                        from #skipchecks
                                        where databasename is null
                                          and checkid = 225
                                    )
                                    and EXISTS(select * from sys.all_objects where name = 'index_resumable_operations')
                                    begin
                                        if @debug in (1, 2)
                                            begin
                                                raiserror ('Running CheckId [%d].',0,1,218) with nowait;
                                            end

                                        execute sp_MSforeachdb 'USE [?];
					SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                    INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details)
					SELECT 225 AS CheckID
						,''?'' AS DatabaseName
						,200 AS Priority
						,''Reliability'' AS FindingsGroup
						,''Resumable Index Operation Paused'' AS Finding
						,''https://BrentOzar.com/go/resumable'' AS URL
						,iro.state_desc + N'' since '' + CONVERT(NVARCHAR(50), last_pause_time, 120) + '', ''
                            + CAST(iro.percent_complete AS NVARCHAR(20)) + ''% complete: ''
                            + CAST(iro.sql_text AS NVARCHAR(1000)) AS Details
					FROM sys.index_resumable_operations iro
					JOIN sys.objects o ON iro.[object_id] = o.[object_id]
					WHERE iro.state <> 0;';
                                    end;
                                --of Check 225.

                                --/* Check 220 - Statistics Without Histograms */
                                --IF NOT EXISTS (
                                --		SELECT 1
                                --		FROM #SkipChecks
                                --		WHERE DatabaseName IS NULL
                                --			AND CheckID = 220
                                --		)
                                --             AND EXISTS (SELECT * FROM sys.all_objects WHERE name = 'dm_db_stats_histogram')
                                --BEGIN
                                --	IF @Debug IN (1,2)
                                --	BEGIN
                                --		RAISERROR ('Running CheckId [%d].',0,1,220) WITH NOWAIT;
                                --	END

                                --	EXECUTE sp_MSforeachdb 'USE [?];
                                --      SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                                --		INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details)
                                --		SELECT 220 AS CheckID
                                --			,DB_NAME() AS DatabaseName
                                --			,110 AS Priority
                                --			,''Performance'' AS FindingsGroup
                                --			,''Statistics Without Histograms'' AS Finding
                                --			,''https://BrentOzar.com/go/brokenstats'' AS URL
                                --			,CAST(COUNT(DISTINCT o.object_id) AS VARCHAR(100)) + '' tables have statistics that have not been updated since the database was restored or upgraded,''
                                --				+ '' and have no data in their histogram. See the More Info URL for a script to update them. '' AS Details
                                --                   FROM sys.all_objects o
                                --                   INNER JOIN sys.stats s ON o.object_id = s.object_id AND s.has_filter = 0
                                --                   OUTER APPLY sys.dm_db_stats_histogram(o.object_id, s.stats_id) h
                                --                   WHERE o.is_ms_shipped = 0 AND o.type_desc = ''USER_TABLE''
                                --                     AND h.object_id IS NULL
                                --                     AND 0 < (SELECT SUM(row_count) FROM sys.dm_db_partition_stats ps WHERE ps.object_id = o.object_id)
                                --                     AND ''?'' NOT IN (''master'', ''model'', ''msdb'', ''tempdb'')
                                --                   HAVING COUNT(DISTINCT o.object_id) > 0;';
                                --END; --of Check 220.


                            end; /* IF @CheckUserDatabaseObjects = 1 */

                        if @checkprocedurecache = 1
                            begin

                                if @debug in (1, 2) raiserror ('Begin checking procedure cache', 0, 1) with nowait;

                                begin

                                    if not EXISTS(select 1
                                                  from #skipchecks
                                                  where databasename is null
                                                    and checkid = 35)
                                        begin

                                            if @debug in (1, 2)
                                                raiserror ('Running CheckId [%d].', 0, 1, 35) with nowait;

                                            insert into #blitzresults
                                            (checkid,
                                             priority,
                                             findingsgroup,
                                             finding,
                                             url,
                                             details)
                                            select 35                                                                                                                                                                                                                                                        as checkid,
                                                   100                                                                                                                                                                                                                                                       as priority,
                                                   'Performance'                                                                                                                                                                                                                                             as findingsgroup,
                                                   'Single-Use Plans in Procedure Cache'                                                                                                                                                                                                                     as finding,
                                                   'https://BrentOzar.com/go/single'                                                                                                                                                                                                                         as url,
                                                   (CAST(COUNT(*) as varchar(10))
                                                       +
                                                    ' query plans are taking up memory in the procedure cache. This may be wasted memory if we cache plans for queries that never get called again. This may be a good use case for SQL Server 2008''s Optimize for Ad Hoc or for Forced Parameterization.') as details
                                            from sys.dm_exec_cached_plans as cp
                                            where cp.usecounts = 1
                                              and cp.objtype = 'Adhoc'
                                              and EXISTS(select 1
                                                         from sys.configurations
                                                         where name = 'optimize for ad hoc workloads'
                                                           and value_in_use = 0)
                                            having COUNT(*) > 1;
                                        end;

                                    /* Set up the cache tables. Different on 2005 since it doesn't support query_hash, query_plan_hash. */
                                    if @@VERSION like '%Microsoft SQL Server 2005%'
                                        begin
                                            if @checkprocedurecachefilter = 'CPU'
                                                or @checkprocedurecachefilter is null
                                                begin
                                                    set @stringtoexecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
			  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
			  FROM sys.dm_exec_query_stats qs
			  ORDER BY qs.total_worker_time DESC)
			  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
			  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
			  FROM queries qs
			  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
			  WHERE qsCaught.sql_handle IS NULL OPTION (RECOMPILE);';
                                                    execute (@stringtoexecute);
                                                end;

                                            if @checkprocedurecachefilter = 'Reads'
                                                or @checkprocedurecachefilter is null
                                                begin
                                                    set @stringtoexecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.total_logical_reads DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL OPTION (RECOMPILE);';
                                                    execute (@stringtoexecute);
                                                end;

                                            if @checkprocedurecachefilter = 'ExecCount'
                                                or @checkprocedurecachefilter is null
                                                begin
                                                    set @stringtoexecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.execution_count DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL OPTION (RECOMPILE);';
                                                    execute (@stringtoexecute);
                                                end;

                                            if @checkprocedurecachefilter = 'Duration'
                                                or @checkprocedurecachefilter is null
                                                begin
                                                    set @stringtoexecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
			AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
			FROM sys.dm_exec_query_stats qs
			ORDER BY qs.total_elapsed_time DESC)
			INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
			SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
			FROM queries qs
			LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
			WHERE qsCaught.sql_handle IS NULL OPTION (RECOMPILE);';
                                                    execute (@stringtoexecute);
                                                end;

                                        end;
                                    if @productversionmajor >= 10
                                        begin
                                            if @checkprocedurecachefilter = 'CPU'
                                                or @checkprocedurecachefilter is null
                                                begin
                                                    set @stringtoexecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.total_worker_time DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL OPTION (RECOMPILE);';
                                                    execute (@stringtoexecute);
                                                end;

                                            if @checkprocedurecachefilter = 'Reads'
                                                or @checkprocedurecachefilter is null
                                                begin
                                                    set @stringtoexecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.total_logical_reads DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL OPTION (RECOMPILE);';
                                                    execute (@stringtoexecute);
                                                end;

                                            if @checkprocedurecachefilter = 'ExecCount'
                                                or @checkprocedurecachefilter is null
                                                begin
                                                    set @stringtoexecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.execution_count DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL OPTION (RECOMPILE);';
                                                    execute (@stringtoexecute);
                                                end;

                                            if @checkprocedurecachefilter = 'Duration'
                                                or @checkprocedurecachefilter is null
                                                begin
                                                    set @stringtoexecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.total_elapsed_time DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL OPTION (RECOMPILE);';
                                                    execute (@stringtoexecute);
                                                end;

                                            /* Populate the query_plan_filtered field. Only works in 2005SP2+, but we're just doing it in 2008 to be safe. */
                                            update #dm_exec_query_stats
                                            set query_plan_filtered = qp.query_plan
                                            from #dm_exec_query_stats qs
                                                     cross apply sys.dm_exec_text_query_plan(qs.plan_handle,
                                                                                             qs.statement_start_offset,
                                                                                             qs.statement_end_offset)
                                                as qp;

                                        end;

                                    /* Populate the additional query_plan, text, and text_filtered fields */
                                    update #dm_exec_query_stats
                                    set query_plan    = qp.query_plan,
                                        [text]        = st.[text],
                                        text_filtered = SUBSTRING(st.text,
                                                                  (qs.statement_start_offset
                                                                      / 2) + 1,
                                                                  ((case qs.statement_end_offset
                                                                        when -1
                                                                            then DATALENGTH(st.text)
                                                                        else qs.statement_end_offset
                                                                        end
                                                                      - qs.statement_start_offset)
                                                                      / 2) + 1)
                                    from #dm_exec_query_stats qs
                                             cross apply sys.dm_exec_sql_text(qs.sql_handle) as st
                                             cross apply sys.dm_exec_query_plan(qs.plan_handle)
                                        as qp;

                                    /* Dump instances of our own script. We're not trying to tune ourselves. */
                                    delete #dm_exec_query_stats
                                    where text like '%sp_Blitz%'
                                       or text like '%#BlitzResults%';

                                    /* Look for implicit conversions */

                                    if not EXISTS(select 1
                                                  from #skipchecks
                                                  where databasename is null
                                                    and checkid = 63)
                                        begin

                                            if @debug in (1, 2)
                                                raiserror ('Running CheckId [%d].', 0, 1, 63) with nowait;

                                            insert into #blitzresults
                                            (checkid,
                                             priority,
                                             findingsgroup,
                                             finding,
                                             url,
                                             details,
                                             queryplan,
                                             queryplanfiltered)
                                            select 63                                                                                                    as checkid,
                                                   120                                                                                                   as priority,
                                                   'Query Plans'                                                                                         as findingsgroup,
                                                   'Implicit Conversion'                                                                                 as finding,
                                                   'https://BrentOzar.com/go/implicit'                                                                   as url,
                                                   ('One of the top resource-intensive queries is comparing two fields that are not the same datatype.') as details,
                                                   qs.query_plan,
                                                   qs.query_plan_filtered
                                            from #dm_exec_query_stats qs
                                            where COALESCE(qs.query_plan_filtered,
                                                           CAST(qs.query_plan as nvarchar(max))) like
                                                  '%CONVERT_IMPLICIT%'
                                              and COALESCE(qs.query_plan_filtered,
                                                           CAST(qs.query_plan as nvarchar(max))) like
                                                  '%PhysicalOp="Index Scan"%';
                                        end;

                                    if not EXISTS(select 1
                                                  from #skipchecks
                                                  where databasename is null
                                                    and checkid = 64)
                                        begin

                                            if @debug in (1, 2)
                                                raiserror ('Running CheckId [%d].', 0, 1, 64) with nowait;

                                            insert into #blitzresults
                                            (checkid,
                                             priority,
                                             findingsgroup,
                                             finding,
                                             url,
                                             details,
                                             queryplan,
                                             queryplanfiltered)
                                            select 64                                                                                                                 as checkid,
                                                   120                                                                                                                as priority,
                                                   'Query Plans'                                                                                                      as findingsgroup,
                                                   'Implicit Conversion Affecting Cardinality'                                                                        as finding,
                                                   'https://BrentOzar.com/go/implicit'                                                                                as url,
                                                   ('One of the top resource-intensive queries has an implicit conversion that is affecting cardinality estimation.') as details,
                                                   qs.query_plan,
                                                   qs.query_plan_filtered
                                            from #dm_exec_query_stats qs
                                            where COALESCE(qs.query_plan_filtered,
                                                           CAST(qs.query_plan as nvarchar(max))) like
                                                  '%<PlanAffectingConvert ConvertIssue="Cardinality Estimate" Expression="CONVERT_IMPLICIT%';
                                        end;

                                    /* @cms4j, 29.11.2013: Look for RID or Key Lookups */
                                    if not EXISTS(select 1
                                                  from #skipchecks
                                                  where databasename is null
                                                    and checkid = 118)
                                        begin

                                            if @debug in (1, 2)
                                                raiserror ('Running CheckId [%d].', 0, 1, 118) with nowait;

                                            insert into #blitzresults
                                            (checkid,
                                             priority,
                                             findingsgroup,
                                             finding,
                                             url,
                                             details,
                                             queryplan,
                                             queryplanfiltered)
                                            select 118                                                                                                                      as checkid,
                                                   120                                                                                                                      as priority,
                                                   'Query Plans'                                                                                                            as findingsgroup,
                                                   'RID or Key Lookups'                                                                                                     as finding,
                                                   'https://BrentOzar.com/go/lookup'                                                                                        as url,
                                                   'One of the top resource-intensive queries contains RID or Key Lookups. Try to avoid them by creating covering indexes.' as details,
                                                   qs.query_plan,
                                                   qs.query_plan_filtered
                                            from #dm_exec_query_stats qs
                                            where COALESCE(qs.query_plan_filtered,
                                                           CAST(qs.query_plan as nvarchar(max))) like '%Lookup="1"%';
                                        end;
                                    /* @cms4j, 29.11.2013: Look for RID or Key Lookups */

                                    /* Look for missing indexes */
                                    if not EXISTS(select 1
                                                  from #skipchecks
                                                  where databasename is null
                                                    and checkid = 65)
                                        begin

                                            if @debug in (1, 2)
                                                raiserror ('Running CheckId [%d].', 0, 1, 65) with nowait;

                                            insert into #blitzresults
                                            (checkid,
                                             priority,
                                             findingsgroup,
                                             finding,
                                             url,
                                             details,
                                             queryplan,
                                             queryplanfiltered)
                                            select 65                                                                                             as checkid,
                                                   120                                                                                            as priority,
                                                   'Query Plans'                                                                                  as findingsgroup,
                                                   'Missing Index'                                                                                as finding,
                                                   'https://BrentOzar.com/go/missingindex'                                                        as url,
                                                   ('One of the top resource-intensive queries may be dramatically improved by adding an index.') as details,
                                                   qs.query_plan,
                                                   qs.query_plan_filtered
                                            from #dm_exec_query_stats qs
                                            where COALESCE(qs.query_plan_filtered,
                                                           CAST(qs.query_plan as nvarchar(max))) like
                                                  '%MissingIndexGroup%';
                                        end;

                                    /* Look for cursors */
                                    if not EXISTS(select 1
                                                  from #skipchecks
                                                  where databasename is null
                                                    and checkid = 66)
                                        begin

                                            if @debug in (1, 2)
                                                raiserror ('Running CheckId [%d].', 0, 1, 66) with nowait;

                                            insert into #blitzresults
                                            (checkid,
                                             priority,
                                             findingsgroup,
                                             finding,
                                             url,
                                             details,
                                             queryplan,
                                             queryplanfiltered)
                                            select 66                                                               as checkid,
                                                   120                                                              as priority,
                                                   'Query Plans'                                                    as findingsgroup,
                                                   'Cursor'                                                         as finding,
                                                   'https://BrentOzar.com/go/cursor'                                as url,
                                                   ('One of the top resource-intensive queries is using a cursor.') as details,
                                                   qs.query_plan,
                                                   qs.query_plan_filtered
                                            from #dm_exec_query_stats qs
                                            where COALESCE(qs.query_plan_filtered,
                                                           CAST(qs.query_plan as nvarchar(max))) like '%<StmtCursor%';
                                        end;

                                    /* Look for scalar user-defined functions */

                                    if not EXISTS(select 1
                                                  from #skipchecks
                                                  where databasename is null
                                                    and checkid = 67)
                                        begin

                                            if @debug in (1, 2)
                                                raiserror ('Running CheckId [%d].', 0, 1, 67) with nowait;

                                            insert into #blitzresults
                                            (checkid,
                                             priority,
                                             findingsgroup,
                                             finding,
                                             url,
                                             details,
                                             queryplan,
                                             queryplanfiltered)
                                            select 67                                                                                                                  as checkid,
                                                   120                                                                                                                 as priority,
                                                   'Query Plans'                                                                                                       as findingsgroup,
                                                   'Scalar UDFs'                                                                                                       as finding,
                                                   'https://BrentOzar.com/go/functions'                                                                                as url,
                                                   ('One of the top resource-intensive queries is using a user-defined scalar function that may inhibit parallelism.') as details,
                                                   qs.query_plan,
                                                   qs.query_plan_filtered
                                            from #dm_exec_query_stats qs
                                            where COALESCE(qs.query_plan_filtered,
                                                           CAST(qs.query_plan as nvarchar(max))) like
                                                  '%<UserDefinedFunction%';
                                        end;

                                end; /* IF @CheckProcedureCache = 1 */
                            end;

                        /*Check to see if the HA endpoint account is set at the same as the SQL Server Service Account*/
                        if @productversionmajor >= 10
                            and not EXISTS(select 1
                                           from #skipchecks
                                           where databasename is null
                                             and checkid = 187)
                            if SERVERPROPERTY('IsHadrEnabled') = 1
                                begin

                                    if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 187) with nowait;

                                    insert into [#BlitzResults]
                                    ([CheckID],
                                     [Priority],
                                     [FindingsGroup],
                                     [Finding],
                                     [URL],
                                     [Details])
                                    select 187                               as [CheckID],
                                           230                               as [Priority],
                                           'Security'                        as [FindingsGroup],
                                           'Endpoints Owned by Users'        as [Finding],
                                           'https://BrentOzar.com/go/owners' as [URL],
                                           ('Endpoint ' + ep.[name] + ' is owned by ' + SUSER_NAME(ep.principal_id) +
                                            '. If the endpoint owner login is disabled or not available due to Active Directory problems, the high availability will stop working.'
                                               )                             as [Details]
                                    from sys.database_mirroring_endpoints ep
                                             left outer join sys.dm_server_services s
                                                             on SUSER_NAME(ep.principal_id) = s.service_account
                                    where s.service_account is null
                                      and ep.principal_id <> 1;
                                end;

                        /*Check for the last good DBCC CHECKDB date */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 68)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 68) with nowait;

                                exec sp_MSforeachdb N'USE [?];
                        SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
						INSERT #DBCCs
							(ParentObject,
							Object,
							Field,
							Value)
						EXEC (''DBCC DBInfo() With TableResults, NO_INFOMSGS'');
						UPDATE #DBCCs SET DbName = N''?'' WHERE DbName IS NULL OPTION (RECOMPILE);';

                                with db2
                                         as (select distinct field,
                                                             value,
                                                             dbname
                                             from #dbccs
                                                      inner join sys.databases d on #dbccs.dbname = d.name
                                             where field = 'dbi_dbccLastKnownGood'
                                               and d.create_date < DATEADD(dd, -14, GETDATE())
                                    )
                                insert
                                into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 68                                        as checkid,
                                       db2.dbname                                as databasename,
                                       1                                         as priority,
                                       'Reliability'                             as findingsgroup,
                                       'Last good DBCC CHECKDB over 2 weeks old' as finding,
                                       'https://BrentOzar.com/go/checkdb'        as url,
                                       'Last successful CHECKDB: '
                                           + case db2.value
                                                 when '1900-01-01 00:00:00.000'
                                                     then ' never.'
                                                 else db2.value
                                           end                                   as details
                                from db2
                                where db2.dbname <> 'tempdb'
                                  and db2.dbname not in (select distinct databasename
                                                         from #skipchecks
                                                         where checkid is null
                                                            or checkid = 68)
                                  and db2.dbname not in (select name
                                                         from sys.databases
                                                         where is_read_only = 1)
                                  and CONVERT(datetime, db2.value, 121) < DATEADD(dd,
                                                                                  -14,
                                                                                  CURRENT_TIMESTAMP);
                            end;

                        /*Verify that the servername is set */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 70)
                            begin
                                if @@SERVERNAME is null
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 70) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 70                                                                                                        as checkid,
                                               200                                                                                                       as priority,
                                               'Informational'                                                                                           as findingsgroup,
                                               '@@Servername Not Set'                                                                                    as finding,
                                               'https://BrentOzar.com/go/servername'                                                                     as url,
                                               '@@Servername variable is null. You can fix it by executing: "sp_addserver ''<LocalServerName>'', local"' as details;
                                    end;

                                if /* @@SERVERNAME IS set */
                                    (@@SERVERNAME is not null
                                        and
                                        /* not a named instance */
                                     CHARINDEX(CHAR(92), CAST(SERVERPROPERTY('ServerName') as nvarchar(128))) = 0
                                        and
                                        /* not clustered, when computername may be different than the servername */
                                     SERVERPROPERTY('IsClustered') = 0
                                        and
                                        /* @@SERVERNAME is different than the computer name */
                                     @@SERVERNAME <> CAST(
                                             ISNULL(SERVERPROPERTY('ComputerNamePhysicalNetBIOS'), @@SERVERNAME) as nvarchar(128)))
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 70) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 70                                                                                            as checkid,
                                               200                                                                                           as priority,
                                               'Configuration'                                                                               as findingsgroup,
                                               '@@Servername Not Correct'                                                                    as finding,
                                               'https://BrentOzar.com/go/servername'                                                         as url,
                                               'The @@Servername is different than the computer name, which may trigger certificate errors.' as details;
                                    end;

                            end;
                        /*Check to see if a failsafe operator has been configured*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 73)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 73) with nowait;

                                declare @alertinfo table
                                                   (
                                                       failsafeoperator nvarchar(255),
                                                       notificationmethod int,
                                                       forwardingserver nvarchar(255),
                                                       forwardingseverity int,
                                                       pagertotemplate nvarchar(255),
                                                       pagercctemplate nvarchar(255),
                                                       pagersubjecttemplate nvarchar(255),
                                                       pagersendsubjectonly nvarchar(255),
                                                       forwardalways int
                                                   );
                                insert into @alertinfo
                                    exec [master].[dbo].[sp_MSgetalertinfo] @includeaddresses = 0;
                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 73                                                                                                                                                         as checkid,
                                       200                                                                                                                                                        as priority,
                                       'Monitoring'                                                                                                                                               as findingsgroup,
                                       'No Failsafe Operator Configured'                                                                                                                          as finding,
                                       'https://BrentOzar.com/go/failsafe'                                                                                                                        as url,
                                       ('No failsafe operator is configured on this server.  This is a good idea just in-case there are issues with the [msdb] database that prevents alerting.') as details
                                from @alertinfo
                                where failsafeoperator is null;
                            end;

                        /*Identify globally enabled trace flags*/
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 74)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 74) with nowait;

                                insert into #tracestatus
                                    exec ( ' DBCC TRACESTATUS(-1) WITH NO_INFOMSGS'
                                        );
                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 74                                                      as checkid,
                                       200                                                     as priority,
                                       'Informational'                                         as findingsgroup,
                                       'TraceFlag On'                                          as finding,
                                       case
                                           when [T].[TraceFlag] = '834' and @columnstoreindexesinuse = 1
                                               then 'https://support.microsoft.com/en-us/kb/3210239'
                                           else 'https://www.BrentOzar.com/go/traceflags/' end as url,
                                       'Trace flag ' +
                                       case
                                           when [T].[TraceFlag] = '2330'
                                               then ' 2330 enabled globally. Using this trace Flag disables missing index requests!'
                                           when [T].[TraceFlag] = '1211'
                                               then ' 1211 enabled globally. Using this Trace Flag disables lock escalation when you least expect it. No Bueno!'
                                           when [T].[TraceFlag] = '1224'
                                               then ' 1224 enabled globally. Using this Trace Flag disables lock escalation based on the number of locks being taken. You shouldn''t have done that, Dave.'
                                           when [T].[TraceFlag] = '652'
                                               then ' 652 enabled globally. Using this Trace Flag disables pre-fetching during index scans. If you hate slow queries, you should turn that off.'
                                           when [T].[TraceFlag] = '661'
                                               then ' 661 enabled globally. Using this Trace Flag disables ghost record removal. Who you gonna call? No one, turn that thing off.'
                                           when [T].[TraceFlag] = '1806'
                                               then ' 1806 enabled globally. Using this Trace Flag disables Instant File Initialization. I question your sanity.'
                                           when [T].[TraceFlag] = '3505'
                                               then ' 3505 enabled globally. Using this Trace Flag disables Checkpoints. Probably not the wisest idea.'
                                           when [T].[TraceFlag] = '8649'
                                               then ' 8649 enabled globally. Using this Trace Flag drops cost threshold for parallelism down to 0. I hope this is a dev server.'
                                           when [T].[TraceFlag] = '834' and @columnstoreindexesinuse = 1
                                               then ' 834 is enabled globally. Using this Trace Flag with Columnstore Indexes is not a great idea.'
                                           when [T].[TraceFlag] = '8017' and
                                                (CAST(SERVERPROPERTY('Edition') as nvarchar(1000)) like N'%Express%')
                                               then ' 8017 is enabled globally, which is the default for express edition.'
                                           when [T].[TraceFlag] = '8017' and
                                                (CAST(SERVERPROPERTY('Edition') as nvarchar(1000)) not like
                                                 N'%Express%')
                                               then ' 8017 is enabled globally. Using this Trace Flag disables creation schedulers for all logical processors. Not good.'
                                           else [T].[TraceFlag] + ' is enabled globally.' end
                                                                                               as details
                                from #tracestatus t;
                            end;

                        /* High CMEMTHREAD waits that could need trace flag 8048.
               This check has to be run AFTER the globally enabled trace flag check,
               since it uses the #TraceStatus table to know if flags are enabled.
            */
                        if @productversionmajor >= 11 and not EXISTS(select 1
                                                                     from #skipchecks
                                                                     where databasename is null
                                                                       and checkid = 162)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 162) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 162                                       as checkid,
                                       50                                        as priority,
                                       'Performance'                             as findinggroup,
                                       'Poison Wait Detected: CMEMTHREAD & NUMA' as finding,
                                       'https://BrentOzar.com/go/poison'         as url,
                                       CONVERT(varchar(10), (MAX([wait_time_ms]) / 1000) / 86400) + ':' +
                                       CONVERT(varchar(20), DATEADD(s, (MAX([wait_time_ms]) / 1000), 0), 108) +
                                       ' of this wait have been recorded'
                                           + case
                                                 when ts.status = 1 then ' despite enabling trace flag 8048 already.'
                                                 else '. In servers with over 8 cores per NUMA node, when CMEMTHREAD waits are a bottleneck, trace flag 8048 may be needed.'
                                           end
                                from sys.dm_os_nodes n
                                         inner join sys.[dm_os_wait_stats] w on w.wait_type = 'CMEMTHREAD'
                                         left outer join #tracestatus ts on ts.traceflag = 8048 and ts.status = 1
                                where n.node_id = 0
                                  and n.online_scheduler_count >= 8
                                  and EXISTS(select *
                                             from sys.dm_os_nodes
                                             where node_id > 0 and node_state_desc not like '%DAC')
                                group by w.wait_type, ts.status
                                having SUM([wait_time_ms]) >
                                       (select 5000 * datediff(hh, create_date, CURRENT_TIMESTAMP) as hours_since_startup
                                        from sys.databases
                                        where name = 'tempdb')
                                   and SUM([wait_time_ms]) > 60000;
                            end;


                        /*Check for transaction log file larger than data file */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 75)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 75) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 75                                                                                                                                                                       as checkid,
                                       DB_NAME(a.database_id),
                                       50                                                                                                                                                                       as priority,
                                       'Reliability'                                                                                                                                                            as findingsgroup,
                                       'Transaction Log Larger than Data File'                                                                                                                                  as finding,
                                       'https://BrentOzar.com/go/biglog'                                                                                                                                        as url,
                                       'The database [' + DB_NAME(a.database_id)
                                           + '] has a ' + CAST((CAST(a.size as bigint) * 8 / 1000000) as nvarchar(20)) +
                                       ' GB transaction log file, larger than the total data file sizes. This may indicate that transaction log backups are not being performed or not performed often enough.' as details
                                from sys.master_files a
                                where a.type = 1
                                  and DB_NAME(a.database_id) not in (
                                    select distinct databasename
                                    from #skipchecks
                                    where checkid = 75
                                       or checkid is null)
                                  and a.size > 125000 /* Size is measured in pages here, so this gets us log files over 1GB. */
                                  and a.size > (select SUM(CAST(b.size as bigint))
                                                from sys.master_files b
                                                where a.database_id = b.database_id
                                                  and b.type = 0
                                )
                                  and a.database_id in (
                                    select database_id
                                    from sys.databases
                                    where source_database_id is null);
                            end;

                        /*Check for collation conflicts between user databases and tempdb */
                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 76)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 76) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 76                                                                                                                    as checkid,
                                       name                                                                                                                  as databasename,
                                       200                                                                                                                   as priority,
                                       'Informational'                                                                                                       as findingsgroup,
                                       'Collation is ' + collation_name                                                                                      as finding,
                                       'https://BrentOzar.com/go/collate'                                                                                    as url,
                                       'Collation differences between user databases and tempdb can cause conflicts especially when comparing string values' as details
                                from sys.databases
                                where name not in ('master', 'model', 'msdb')
                                  and name not like 'ReportServer%'
                                  and name not in (select distinct databasename
                                                   from #skipchecks
                                                   where checkid is null
                                                      or checkid = 76)
                                  and collation_name <> (select collation_name
                                                         from sys.databases
                                                         where name = 'tempdb'
                                );
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 77)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 77) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 databasename,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 77                                                                                                  as checkid,
                                       dsnap.[name]                                                                                        as databasename,
                                       50                                                                                                  as priority,
                                       'Reliability'                                                                                       as findingsgroup,
                                       'Database Snapshot Online'                                                                          as finding,
                                       'https://BrentOzar.com/go/snapshot'                                                                 as url,
                                       'Database [' + dsnap.[name]
                                           + '] is a snapshot of ['
                                           + doriginal.[name]
                                           +
                                       ']. Make sure you have enough drive space to maintain the snapshot as the original database grows.' as details
                                from sys.databases dsnap
                                         inner join sys.databases doriginal
                                                    on dsnap.source_database_id = doriginal.database_id
                                                        and dsnap.name not in (
                                                            select distinct databasename
                                                            from #skipchecks
                                                            where checkid = 77
                                                               or checkid is null);
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 79)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 79) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 79                                    as checkid,
                                       -- sp_Blitz Issue #776
                                       -- Job has history and was executed in the last 30 days OR Job is enabled AND Job Schedule is enabled
                                       case
                                           when (cast(datediff(dd, substring(cast(sjh.run_date as nvarchar(10)), 1, 4) +
                                                                   '-' +
                                                                   substring(cast(sjh.run_date as nvarchar(10)), 5, 2) +
                                                                   '-' +
                                                                   substring(cast(sjh.run_date as nvarchar(10)), 7, 2),
                                                               GETDATE()) as int) < 30) or
                                                (j.[enabled] = 1 and ssc.[enabled] = 1) then
                                               100
                                           else -- no job history (implicit) AND job not run in the past 30 days AND (Job disabled OR Job Schedule disabled)
                                               200
                                           end                               as priority,
                                       'Performance'                         as findingsgroup,
                                       'Shrink Database Job'                 as finding,
                                       'https://BrentOzar.com/go/autoshrink' as url,
                                       'In the [' + j.[name] + '] job, step ['
                                           + step.[step_name]
                                           +
                                       '] has SHRINKDATABASE or SHRINKFILE, which may be causing database fragmentation.'
                                           + case
                                                 when COALESCE(ssc.name, '0') != '0'
                                                     then + ' (Schedule: [' + ssc.name + '])'
                                                 else + '' end               as details
                                from msdb.dbo.sysjobs j
                                         inner join msdb.dbo.sysjobsteps step on j.job_id = step.job_id
                                         left outer join msdb.dbo.sysjobschedules as sjsc
                                                         on j.job_id = sjsc.job_id
                                         left outer join msdb.dbo.sysschedules as ssc
                                                         on sjsc.schedule_id = ssc.schedule_id
                                                             and sjsc.job_id = j.job_id
                                         left outer join msdb.dbo.sysjobhistory as sjh
                                                         on j.job_id = sjh.job_id
                                                             and step.step_id = sjh.step_id
                                                             and sjh.run_date in (select max(sjh2.run_date)
                                                                                  from msdb.dbo.sysjobhistory as sjh2
                                                                                  where sjh2.job_id = j.job_id) -- get the latest entry date
                                                             and sjh.run_time in (select max(sjh3.run_time)
                                                                                  from msdb.dbo.sysjobhistory as sjh3
                                                                                  where sjh3.job_id = j.job_id
                                                                                    and sjh3.run_date = sjh.run_date) -- get the latest entry time
                                where step.command like N'%SHRINKDATABASE%'
                                   or step.command like N'%SHRINKFILE%';
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 81)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 81) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select 81                                                                                                     as checkid,
                                       200                                                                                                    as priority,
                                       'Non-Active Server Config'                                                                             as findingsgroup,
                                       cr.name                                                                                                as finding,
                                       'https://www.BrentOzar.com/blitz/sp_configure/'                                                        as url,
                                       ('This sp_configure option isn''t running under its set value.  Its set value is '
                                           + CAST(cr.[value] as varchar(100))
                                           + ' and its running value is '
                                           + CAST(cr.value_in_use as varchar(100))
                                           +
                                        '. When someone does a RECONFIGURE or restarts the instance, this setting will start taking effect.') as details
                                from sys.configurations cr
                                where cr.value <> cr.value_in_use
                                  and not (cr.name = 'min server memory (MB)' and cr.value in (0, 16) and
                                           cr.value_in_use in (0, 16));
                            end;

                        if not EXISTS(select 1
                                      from #skipchecks
                                      where databasename is null
                                        and checkid = 123)
                            begin

                                if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 123) with nowait;

                                insert into #blitzresults
                                (checkid,
                                 priority,
                                 findingsgroup,
                                 finding,
                                 url,
                                 details)
                                select top 1 123                                                                                                                                  as checkid,
                                             200                                                                                                                                  as priority,
                                             'Informational'                                                                                                                      as findingsgroup,
                                             'Agent Jobs Starting Simultaneously'                                                                                                 as finding,
                                             'https://BrentOzar.com/go/busyagent/'                                                                                                as url,
                                             ('Multiple SQL Server Agent jobs are configured to start simultaneously. For detailed schedule listings, see the query in the URL.') as details
                                from msdb.dbo.sysjobactivity
                                where start_execution_date > DATEADD(dd, -14, GETDATE())
                                group by start_execution_date
                                having COUNT(*) > 1;
                            end;

                        if @checkserverinfo = 1
                            begin

                                /*This checks Windows version. It would be better if Microsoft gave everything a separate build number, but whatever.*/
                                if @productversionmajor >= 10
                                    and not EXISTS(select 1
                                                   from #skipchecks
                                                   where databasename is null
                                                     and checkid = 172)
                                    begin
                                        -- sys.dm_os_host_info includes both Windows and Linux info
                                        if EXISTS(select 1
                                                  from sys.all_objects
                                                  where name = 'dm_os_host_info')
                                            begin

                                                if @debug in (1, 2)
                                                    raiserror ('Running CheckId [%d].', 0, 1, 172) with nowait;

                                                insert into [#BlitzResults]
                                                ([CheckID],
                                                 [Priority],
                                                 [FindingsGroup],
                                                 [Finding],
                                                 [URL],
                                                 [Details])

                                                select 172                        as [CheckID],
                                                       250                        as [Priority],
                                                       'Server Info'              as [FindingsGroup],
                                                       'Operating System Version' as [Finding],
                                                       (case
                                                            when @iswindowsoperatingsystem = 1
                                                                then 'https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions'
                                                            else 'https://en.wikipedia.org/wiki/List_of_Linux_distributions'
                                                           end
                                                           )                      as [URL],
                                                       (case
                                                            when [ohi].[host_platform] = 'Linux' then
                                                                    'You''re running the ' +
                                                                    CAST([ohi].[host_distribution] as varchar(35)) +
                                                                    ' distribution of ' +
                                                                    CAST([ohi].[host_platform] as varchar(35)) +
                                                                    ', version ' +
                                                                    CAST([ohi].[host_release] as varchar(5))
                                                            when [ohi].[host_platform] = 'Windows' and [ohi].[host_release] = '5'
                                                                then 'You''re running Windows 2000, version ' +
                                                                     CAST([ohi].[host_release] as varchar(5))
                                                            when [ohi].[host_platform] = 'Windows' and [ohi].[host_release] > '5'
                                                                then 'You''re running ' +
                                                                     CAST([ohi].[host_distribution] as varchar(50)) +
                                                                     ', version ' +
                                                                     CAST([ohi].[host_release] as varchar(5))
                                                            else 'You''re running ' +
                                                                 CAST([ohi].[host_distribution] as varchar(35)) +
                                                                 ', version ' + CAST([ohi].[host_release] as varchar(5))
                                                           end
                                                           )                      as [Details]
                                                from [sys].[dm_os_host_info] [ohi];
                                            end;
                                        else
                                            begin
                                                -- Otherwise, stick with Windows-only detection

                                                if EXISTS(select 1
                                                          from sys.all_objects
                                                          where name = 'dm_os_windows_info')
                                                    begin

                                                        if @debug in (1, 2)
                                                            raiserror ('Running CheckId [%d].', 0, 1, 172) with nowait;

                                                        insert into [#BlitzResults]
                                                        ([CheckID],
                                                         [Priority],
                                                         [FindingsGroup],
                                                         [Finding],
                                                         [URL],
                                                         [Details])

                                                        select 172                                                                as [CheckID],
                                                               250                                                                as [Priority],
                                                               'Server Info'                                                      as [FindingsGroup],
                                                               'Windows Version'                                                  as [Finding],
                                                               'https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions' as [URL],
                                                               (case
                                                                    when [owi].[windows_release] = '5' then
                                                                            'You''re running Windows 2000, version ' +
                                                                            CAST([owi].[windows_release] as varchar(5))
                                                                    when [owi].[windows_release] > '5' and [owi].[windows_release] < '6'
                                                                        then
                                                                            'You''re running Windows Server 2003/2003R2 era, version ' +
                                                                            CAST([owi].[windows_release] as varchar(5))
                                                                    when [owi].[windows_release] >= '6' and [owi].[windows_release] <= '6.1'
                                                                        then
                                                                            'You''re running Windows Server 2008/2008R2 era, version ' +
                                                                            CAST([owi].[windows_release] as varchar(5))
                                                                    when [owi].[windows_release] >= '6.2' and [owi].[windows_release] <= '6.3'
                                                                        then
                                                                            'You''re running Windows Server 2012/2012R2 era, version ' +
                                                                            CAST([owi].[windows_release] as varchar(5))
                                                                    when [owi].[windows_release] = '10.0' then
                                                                            'You''re running Windows Server 2016/2019 era, version ' +
                                                                            CAST([owi].[windows_release] as varchar(5))
                                                                    else 'You''re running Windows Server, version ' +
                                                                         CAST([owi].[windows_release] as varchar(5))
                                                                   end
                                                                   )                                                              as [Details]
                                                        from [sys].[dm_os_windows_info] [owi];

                                                    end;
                                            end;
                                    end;

/*
This check hits the dm_os_process_memory system view
to see if locked_page_allocations_kb is > 0,
which could indicate that locked pages in memory is enabled.
*/
                                if @productversionmajor >= 10 and not EXISTS(select 1
                                                                             from #skipchecks
                                                                             where databasename is null
                                                                               and checkid = 166)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 166) with nowait;

                                        insert into [#BlitzResults]
                                        ([CheckID],
                                         [Priority],
                                         [FindingsGroup],
                                         [Finding],
                                         [URL],
                                         [Details])
                                        select 166                                       as [CheckID],
                                               250                                       as [Priority],
                                               'Server Info'                             as [FindingsGroup],
                                               'Locked Pages In Memory Enabled'          as [Finding],
                                               'https://BrentOzar.com/go/lpim'           as [URL],
                                               ('You currently have '
                                                   + case
                                                         when [dopm].[locked_page_allocations_kb] / 1024. / 1024. > 0
                                                             then CAST(
                                                                          [dopm].[locked_page_allocations_kb] / 1024 / 1024 as varchar(100))
                                                             + ' GB'
                                                         else CAST([dopm].[locked_page_allocations_kb] / 1024 as varchar(100))
                                                             + ' MB'
                                                    end + ' of pages locked in memory.') as [Details]
                                        from [sys].[dm_os_process_memory] as [dopm]
                                        where [dopm].[locked_page_allocations_kb] > 0;
                                    end;

                                /* Server Info - Locked Pages In Memory Enabled - Check 166 - SQL Server 2016 SP1 and newer */
                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 166)
                                    and EXISTS(select *
                                               from sys.all_objects o
                                                        inner join sys.all_columns c on o.object_id = c.object_id
                                               where o.name = 'dm_os_sys_info'
                                                 and c.name = 'sql_memory_model')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 166) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			SELECT  166 AS CheckID ,
			250 AS Priority ,
			''Server Info'' AS FindingsGroup ,
			''Memory Model Unconventional'' AS Finding ,
			''https://BrentOzar.com/go/lpim'' AS URL ,
			''Memory Model: '' + CAST(sql_memory_model_desc AS NVARCHAR(100))
			FROM sys.dm_os_sys_info WHERE sql_memory_model <> 1 OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;

                                /*
			Starting with SQL Server 2014 SP2, Instant File Initialization
			is logged in the SQL Server Error Log.
			*/
                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 184)
                                       and (@productversionmajor >= 13) or
                                   (@productversionmajor = 12 and @productversionminor >= 5000)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 184) with nowait;

                                        insert into #errorlog
                                            exec sys.xp_readerrorlog 0, 1,
                                                 N'Database Instant File Initialization: enabled';

                                        if @@ROWCOUNT > 0
                                            insert into #blitzresults
                                            (checkid,
                                             [Priority],
                                             findingsgroup,
                                             finding,
                                             url,
                                             details)
                                            select 193                                   as [CheckID],
                                                   250                                   as [Priority],
                                                   'Server Info'                         as [FindingsGroup],
                                                   'Instant File Initialization Enabled' as [Finding],
                                                   'https://BrentOzar.com/go/instant'    as [URL],
                                                   'The service account has the Perform Volume Maintenance Tasks permission.';
                                    end;

                                /* Server Info - Instant File Initialization Not Enabled - Check 192 - SQL Server 2016 SP1 and newer */
                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 192)
                                    and EXISTS(select *
                                               from sys.all_objects o
                                                        inner join sys.all_columns c on o.object_id = c.object_id
                                               where o.name = 'dm_server_services'
                                                 and c.name = 'instant_file_initialization_enabled')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 192) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			SELECT  192 AS CheckID ,
			50 AS Priority ,
			''Server Info'' AS FindingsGroup ,
			''Instant File Initialization Not Enabled'' AS Finding ,
			''https://BrentOzar.com/go/instant'' AS URL ,
			''Consider enabling IFI for faster restores and data file growths.''
			FROM sys.dm_server_services WHERE instant_file_initialization_enabled <> ''Y'' AND filename LIKE ''%sqlservr.exe%'' OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 130)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 130) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 130                                   as checkid,
                                               250                                   as priority,
                                               'Server Info'                         as findingsgroup,
                                               'Server Name'                         as finding,
                                               'https://BrentOzar.com/go/servername' as url,
                                               @@SERVERNAME                          as details
                                        where @@SERVERNAME is not null;
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 83)
                                    begin
                                        if EXISTS(select *
                                                  from sys.all_objects
                                                  where name = 'dm_server_services')
                                            begin

                                                if @debug in (1, 2)
                                                    raiserror ('Running CheckId [%d].', 0, 1, 83) with nowait;

                                                -- DATETIMEOFFSET and DATETIME have different minimum values, so there's
                                                -- a small workaround here to force 1753-01-01 if the minimum is detected
                                                set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
				SELECT  83 AS CheckID ,
				250 AS Priority ,
				''Server Info'' AS FindingsGroup ,
				''Services'' AS Finding ,
				'''' AS URL ,
				N''Service: '' + servicename + N'' runs under service account '' + service_account + N''. Last startup time: '' + COALESCE(CAST(CASE WHEN YEAR(last_startup_time) <= 1753 THEN CAST(''17530101'' as datetime) ELSE CAST(last_startup_time AS DATETIME) END AS VARCHAR(50)), ''not shown.'') + ''. Startup type: '' + startup_type_desc + N'', currently '' + status_desc + ''.''
				FROM sys.dm_server_services OPTION (RECOMPILE);';

                                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                                if @debug = 2 and @stringtoexecute is null
                                                    print '@StringToExecute has gone NULL, for some reason.';

                                                execute (@stringtoexecute);
                                            end;
                                    end;

                                /* Check 84 - SQL Server 2012 */
                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 84)
                                    begin
                                        if EXISTS(select *
                                                  from sys.all_objects o
                                                           inner join sys.all_columns c on o.object_id = c.object_id
                                                  where o.name = 'dm_os_sys_info'
                                                    and c.name = 'physical_memory_kb')
                                            begin

                                                if @debug in (1, 2)
                                                    raiserror ('Running CheckId [%d].', 0, 1, 84) with nowait;

                                                set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			SELECT  84 AS CheckID ,
			250 AS Priority ,
			''Server Info'' AS FindingsGroup ,
			''Hardware'' AS Finding ,
			'''' AS URL ,
			''Logical processors: '' + CAST(cpu_count AS VARCHAR(50)) + ''. Physical memory: '' + CAST( CAST(ROUND((physical_memory_kb / 1024.0 / 1024), 1) AS INT) AS VARCHAR(50)) + ''GB.''
			FROM sys.dm_os_sys_info OPTION (RECOMPILE);';

                                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                                if @debug = 2 and @stringtoexecute is null
                                                    print '@StringToExecute has gone NULL, for some reason.';

                                                execute (@stringtoexecute);
                                            end;

                                        /* Check 84 - SQL Server 2008 */
                                        if EXISTS(select *
                                                  from sys.all_objects o
                                                           inner join sys.all_columns c on o.object_id = c.object_id
                                                  where o.name = 'dm_os_sys_info'
                                                    and c.name = 'physical_memory_in_bytes')
                                            begin

                                                if @debug in (1, 2)
                                                    raiserror ('Running CheckId [%d].', 0, 1, 84) with nowait;

                                                set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			SELECT  84 AS CheckID ,
			250 AS Priority ,
			''Server Info'' AS FindingsGroup ,
			''Hardware'' AS Finding ,
			'''' AS URL ,
			''Logical processors: '' + CAST(cpu_count AS VARCHAR(50)) + ''. Physical memory: '' + CAST( CAST(ROUND((physical_memory_in_bytes / 1024.0 / 1024 / 1024), 1) AS INT) AS VARCHAR(50)) + ''GB.''
			FROM sys.dm_os_sys_info OPTION (RECOMPILE);';

                                                if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                                if @debug = 2 and @stringtoexecute is null
                                                    print '@StringToExecute has gone NULL, for some reason.';

                                                execute (@stringtoexecute);
                                            end;
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 85)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 85) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 85                   as checkid,
                                               250                  as priority,
                                               'Server Info'        as findingsgroup,
                                               'SQL Server Service' as finding,
                                               ''                   as url,
                                               N'Version: '
                                                   + CAST(SERVERPROPERTY('productversion') as nvarchar(100))
                                                   + N'. Patch Level: '
                                                   + CAST(SERVERPROPERTY('productlevel') as nvarchar(100))
                                                   + case
                                                         when SERVERPROPERTY('ProductUpdateLevel') is null
                                                             then N''
                                                         else N'. Cumulative Update: '
                                                             +
                                                              CAST(SERVERPROPERTY('ProductUpdateLevel') as nvarchar(100))
                                                   end
                                                   + N'. Edition: '
                                                   + CAST(SERVERPROPERTY('edition') as varchar(100))
                                                   + N'. Availability Groups Enabled: '
                                                   + CAST(COALESCE(SERVERPROPERTY('IsHadrEnabled'),
                                                                   0) as varchar(100))
                                                   + N'. Availability Groups Manager Status: '
                                                   + CAST(COALESCE(SERVERPROPERTY('HadrManagerStatus'),
                                                                   0) as varchar(100));
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 88)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 88) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 88                        as checkid,
                                               250                       as priority,
                                               'Server Info'             as findingsgroup,
                                               'SQL Server Last Restart' as finding,
                                               ''                        as url,
                                               CAST(create_date as varchar(100))
                                        from sys.databases
                                        where database_id = 2;
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 91)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 91) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 91                    as checkid,
                                               250                   as priority,
                                               'Server Info'         as findingsgroup,
                                               'Server Last Restart' as finding,
                                               ''                    as url,
                                               CAST(
                                                       DATEADD(second, (ms_ticks / 1000) * (-1), GETDATE()) as nvarchar(25))
                                        from sys.dm_os_sys_info;
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 92)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 92) with nowait;

                                        insert into #driveinfo
                                            (drive, size)
                                            exec master..xp_fixeddrives;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 92                            as checkid,
                                               250                           as priority,
                                               'Server Info'                 as findingsgroup,
                                               'Drive ' + i.drive + ' Space' as finding,
                                               ''                            as url,
                                               CAST(i.size as varchar(30))
                                                   + 'MB free on ' + i.drive
                                                   + ' drive'                as details
                                        from #driveinfo as i;
                                        drop table #driveinfo;
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 103)
                                    and EXISTS(select *
                                               from sys.all_objects o
                                                        inner join sys.all_columns c on o.object_id = c.object_id
                                               where o.name = 'dm_os_sys_info'
                                                 and c.name = 'virtual_machine_type_desc')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 103) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
									SELECT 103 AS CheckID,
									250 AS Priority,
									''Server Info'' AS FindingsGroup,
									''Virtual Server'' AS Finding,
									''https://BrentOzar.com/go/virtual'' AS URL,
									''Type: ('' + virtual_machine_type_desc + '')'' AS Details
									FROM sys.dm_os_sys_info
									WHERE virtual_machine_type <> 0 OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 214)
                                    and EXISTS(select *
                                               from sys.all_objects o
                                                        inner join sys.all_columns c on o.object_id = c.object_id
                                               where o.name = 'dm_os_sys_info'
                                                 and c.name = 'container_type_desc')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 214) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
									SELECT 214 AS CheckID,
									250 AS Priority,
									''Server Info'' AS FindingsGroup,
									''Container'' AS Finding,
									''https://BrentOzar.com/go/virtual'' AS URL,
									''Type: ('' + container_type_desc + '')'' AS Details
									FROM sys.dm_os_sys_info
									WHERE container_type_desc <> ''NONE'' OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 114)
                                    and EXISTS(select *
                                               from sys.all_objects o
                                               where o.name = 'dm_os_memory_nodes')
                                    and EXISTS(select *
                                               from sys.all_objects o
                                                        inner join sys.all_columns c on o.object_id = c.object_id
                                               where o.name = 'dm_os_nodes'
                                                 and c.name = 'processor_group')
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 114) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
										SELECT  114 AS CheckID ,
												250 AS Priority ,
												''Server Info'' AS FindingsGroup ,
												''Hardware - NUMA Config'' AS Finding ,
												'''' AS URL ,
												''Node: '' + CAST(n.node_id AS NVARCHAR(10)) + '' State: '' + node_state_desc
												+ '' Online schedulers: '' + CAST(n.online_scheduler_count AS NVARCHAR(10)) + '' Offline schedulers: '' + CAST(oac.offline_schedulers AS VARCHAR(100)) + '' Processor Group: '' + CAST(n.processor_group AS NVARCHAR(10))
												+ '' Memory node: '' + CAST(n.memory_node_id AS NVARCHAR(10)) + '' Memory VAS Reserved GB: '' + CAST(CAST((m.virtual_address_space_reserved_kb / 1024.0 / 1024) AS INT) AS NVARCHAR(100))
										FROM sys.dm_os_nodes n
										INNER JOIN sys.dm_os_memory_nodes m ON n.memory_node_id = m.memory_node_id
										OUTER APPLY (SELECT
										COUNT(*) AS [offline_schedulers]
										FROM sys.dm_os_schedulers dos
										WHERE n.node_id = dos.parent_node_id
										AND dos.status = ''VISIBLE OFFLINE''
										) oac
										WHERE n.node_state_desc NOT LIKE ''%DAC%''
										ORDER BY n.node_id OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;


                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 211)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 211) with nowait;

                                        declare @outval varchar(36);
                                        /* Get power plan if set by group policy [Git Hub Issue #1620] */
                                        exec master.sys.xp_regread @rootkey = 'HKEY_LOCAL_MACHINE',
                                             @key = 'SOFTWARE\Policies\Microsoft\Power\PowerSettings',
                                             @value_name = 'ActivePowerScheme',
                                             @value = @outval output;

                                        if @outval is null /* If power plan was not set by group policy, get local value [Git Hub Issue #1620]*/
                                            exec master.sys.xp_regread @rootkey = 'HKEY_LOCAL_MACHINE',
                                                 @key = 'SYSTEM\CurrentControlSet\Control\Power\User\PowerSchemes',
                                                 @value_name = 'ActivePowerScheme',
                                                 @value = @outval output;

                                        declare @cpu_speed_mhz int,
                                            @cpu_speed_ghz decimal(18, 2);

                                        exec master.sys.xp_regread @rootkey = 'HKEY_LOCAL_MACHINE',
                                             @key = 'HARDWARE\DESCRIPTION\System\CentralProcessor\0',
                                             @value_name = '~MHz',
                                             @value = @cpu_speed_mhz output;

                                        select @cpu_speed_ghz =
                                               CAST(CAST(@cpu_speed_mhz as decimal) / 1000 as decimal(18, 2));

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 211                                           as checkid,
                                               250                                           as priority,
                                               'Server Info'                                 as findingsgroup,
                                               'Power Plan'                                  as finding,
                                               'https://www.brentozar.com/blitz/power-mode/' as url,
                                               'Your server has '
                                                   + CAST(@cpu_speed_ghz as varchar(4))
                                                   + 'GHz CPUs, and is in '
                                                   + case @outval
                                                         when 'a1841308-3541-4fab-bc81-f71556f20b4a'
                                                             then 'power saving mode -- are you sure this is a production SQL Server?'
                                                         when '381b4222-f694-41f0-9685-ff5bb260df2e'
                                                             then 'balanced power mode -- Uh... you want your CPUs to run at full speed, right?'
                                                         when '8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c'
                                                             then 'high performance power mode'
                                                         when 'e9a42b02-d5df-448d-aa00-03f14749eb61'
                                                             then 'ultimate performance power mode'
                                                         else 'an unknown power mode.'
                                                   end                                       as details

                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 212)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 212) with nowait;

                                        insert into #instances (instance_number, instance_name, data_field)
                                            exec master.sys.xp_regread @rootkey = 'HKEY_LOCAL_MACHINE',
                                                 @key = 'SOFTWARE\Microsoft\Microsoft SQL Server',
                                                 @value_name = 'InstalledInstances'

                                        if (select COUNT(*) from #instances) > 1
                                            begin

                                                declare @instancecount nvarchar(max)
                                                select @instancecount = COUNT(*) from #instances

                                                insert into #blitzresults
                                                (checkid,
                                                 priority,
                                                 findingsgroup,
                                                 finding,
                                                 url,
                                                 details)
                                                select 212                                            as checkid,
                                                       250                                            as priority,
                                                       'Server Info'                                  as findingsgroup,
                                                       'Instance Stacking'                            as finding,
                                                       'https://www.brentozar.com/go/babygotstacked/' as url,
                                                       'Your Server has ' + @instancecount +
                                                       ' Instances of SQL Server installed. More than one is usually a bad idea. Read the URL for more info.'
                                            end;
                                    end;

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 106)
                                    and (select convert(int, value_in_use)
                                         from sys.configurations
                                         where name = 'default trace enabled') = 1
                                    and DATALENGTH(COALESCE(@base_tracefilename, '')) > DATALENGTH('.TRC')
                                    and @tracefileissue = 0
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 106) with nowait;

                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 106                              as checkid
                                             , 250                              as priority
                                             , 'Server Info'                    as findingsgroup
                                             , 'Default Trace Contents'         as finding
                                             , 'https://BrentOzar.com/go/trace' as url
                                             , 'The default trace holds ' +
                                               cast(DATEDIFF(hour, MIN(starttime), GETDATE()) as varchar(30)) +
                                               ' hours of data'
                                            + ' between ' + cast(Min(starttime) as varchar(30)) + ' and ' +
                                               cast(GETDATE() as varchar(30))
                                            + ('. The default trace files are located in: ' +
                                               left(@curr_tracefilename, len(@curr_tracefilename) - @indx)
                                                   )                            as details
                                        from ::fn_trace_gettable(@base_tracefilename, default)
                                        where eventclass between 65500 and 65600;
                                    end; /* CheckID 106 */

                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 152)
                                    begin
                                        if EXISTS(select *
                                                  from sys.dm_os_wait_stats ws
                                                           left outer join #ignorablewaits i on ws.wait_type = i.wait_type
                                                  where wait_time_ms > .1 * @cpumssincewaitscleared
                                                    and waiting_tasks_count > 0
                                                    and i.wait_type is null)
                                            begin
                                                /* Check for waits that have had more than 10% of the server's wait time */

                                                if @debug in (1, 2)
                                                    raiserror ('Running CheckId [%d].', 0, 1, 152) with nowait;

                                                with os(wait_type, waiting_tasks_count, wait_time_ms, max_wait_time_ms,
                                                        signal_wait_time_ms)
                                                         as
                                                         (select ws.wait_type,
                                                                 waiting_tasks_count,
                                                                 wait_time_ms,
                                                                 max_wait_time_ms,
                                                                 signal_wait_time_ms
                                                          from sys.dm_os_wait_stats ws
                                                                   left outer join #ignorablewaits i on ws.wait_type = i.wait_type
                                                          where i.wait_type is null
                                                            and wait_time_ms > .1 * @cpumssincewaitscleared
                                                            and waiting_tasks_count > 0)
                                                insert
                                                into #blitzresults
                                                (checkid,
                                                 priority,
                                                 findingsgroup,
                                                 finding,
                                                 url,
                                                 details)
                                                select top 9           152                                                                 as checkid
                                                           ,           240                                                                 as priority
                                                           ,           'Wait Stats'                                                        as findingsgroup
                                                           ,           CAST(
                                                                               ROW_NUMBER() over (order by os.wait_time_ms desc) as nvarchar(10)) +
                                                                       N' - ' +
                                                                       os.wait_type                                                        as finding
                                                           ,           'https://www.sqlskills.com/help/waits/' + LOWER(os.wait_type) + '/' as url
                                                           , details = CAST(CAST(
                                                        SUM(os.wait_time_ms / 1000.0 / 60 / 60) over (partition by os.wait_type) as numeric(18, 1)) as nvarchar(20)) +
                                                                       N' hours of waits, ' +
                                                                       CAST(CAST(
                                                                                   (SUM(60.0 * os.wait_time_ms) over (partition by os.wait_type)) /
                                                                                   @mssincewaitscleared as numeric(18, 1)) as nvarchar(20)) +
                                                                       N' minutes average wait time per hour, ' +
                                                                           /* CAST(CAST(
														100.* SUM(os.wait_time_ms) OVER (PARTITION BY os.wait_type)
														/ (1. * SUM(os.wait_time_ms) OVER () )
														AS NUMERIC(18,1)) AS NVARCHAR(40)) + N'% of waits, ' + */
                                                                       CAST(CAST(
                                                                                   100. * SUM(os.signal_wait_time_ms) over (partition by os.wait_type)
                                                                                   / (1. * SUM(os.wait_time_ms) over ())
                                                                           as numeric(18, 1)) as nvarchar(40)) +
                                                                       N'% signal wait, ' +
                                                                       CAST(
                                                                               SUM(os.waiting_tasks_count) over (partition by os.wait_type) as nvarchar(40)) +
                                                                       N' waiting tasks, ' +
                                                                       CAST(case
                                                                                when SUM(os.waiting_tasks_count) over (partition by os.wait_type) > 0
                                                                                    then
                                                                                    CAST(
                                                                                                SUM(os.wait_time_ms) over (partition by os.wait_type)
                                                                                                /
                                                                                                (1. * SUM(os.waiting_tasks_count) over (partition by os.wait_type))
                                                                                        as numeric(18, 1))
                                                                                else 0 end as nvarchar(40)) +
                                                                       N' ms average wait time.'
                                                from os
                                                order by SUM(os.wait_time_ms / 1000.0 / 60 / 60) over (partition by os.wait_type) desc;
                                            end;
                                        /* IF EXISTS (SELECT * FROM sys.dm_os_wait_stats WHERE wait_time_ms > 0 AND waiting_tasks_count > 0) */

                                        /* If no waits were found, add a note about that */
                                        if not EXISTS(select *
                                                      from #blitzresults
                                                      where checkid in (107, 108, 109, 121, 152, 162))
                                            begin

                                                if @debug in (1, 2)
                                                    raiserror ('Running CheckId [%d].', 0, 1, 153) with nowait;

                                                insert into #blitzresults
                                                (checkid,
                                                 priority,
                                                 findingsgroup,
                                                 finding,
                                                 url,
                                                 details)
                                                values (153, 240, 'Wait Stats', 'No Significant Waits Detected',
                                                        'https://BrentOzar.com/go/waits',
                                                        'This server might be just sitting around idle, or someone may have cleared wait stats recently.');
                                            end;
                                    end;
                                /* CheckID 152 */

                                /* CheckID 222 - Server Info - Azure Managed Instance */
                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 222)
                                    and 4 = (select COUNT(*)
                                             from sys.all_objects o
                                                      inner join sys.all_columns c on o.object_id = c.object_id
                                             where o.name = 'dm_os_job_object'
                                               and c.name in ('cpu_rate', 'memory_limit_mb', 'process_memory_limit_mb',
                                                              'workingset_limit_mb'))
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 222) with nowait;

                                        set @stringtoexecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
										SELECT  222 AS CheckID ,
												250 AS Priority ,
												''Server Info'' AS FindingsGroup ,
												''Azure Managed Instance'' AS Finding ,
												''https://www.BrenOzar.com/go/azurevm'' AS URL ,
												''cpu_rate: '' + CAST(COALESCE(cpu_rate, 0) AS VARCHAR(20)) +
												'', memory_limit_mb: '' + CAST(COALESCE(memory_limit_mb, 0) AS NVARCHAR(20)) +
												'', process_memory_limit_mb: '' + CAST(COALESCE(process_memory_limit_mb, 0) AS NVARCHAR(20)) +
												'', workingset_limit_mb: '' + CAST(COALESCE(workingset_limit_mb, 0) AS NVARCHAR(20))
										FROM sys.dm_os_job_object OPTION (RECOMPILE);';

                                        if @debug = 2 and @stringtoexecute is not null print @stringtoexecute;
                                        if @debug = 2 and @stringtoexecute is null
                                            print '@StringToExecute has gone NULL, for some reason.';

                                        execute (@stringtoexecute);
                                    end;

                                /* CheckID 224 - Performance - SSRS/SSAS/SSIS Installed */
                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 224)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 224) with nowait;

                                        if (select value_in_use from sys.configurations where [name] = 'xp_cmdshell') =
                                           1
                                            begin

                                                if OBJECT_ID('tempdb..#services') is not null drop table #services;
                                                create table #services
                                                (
                                                    cmdshell_output varchar(max)
                                                );

                                                insert into #services
                                                    exec xp_cmdshell 'net start'

                                                if EXISTS(select 1
                                                          from #services
                                                          where cmdshell_output like '%SQL Server Reporting Services%'
                                                             or cmdshell_output like '%SQL Server Integration Services%'
                                                             or cmdshell_output like '%SQL Server Analysis Services%')
                                                    begin
                                                        insert into #blitzresults
                                                        (checkid,
                                                         priority,
                                                         findingsgroup,
                                                         finding,
                                                         url,
                                                         details)
                                                        select 224                                                                                                                               as checkid
                                                             , 200                                                                                                                               as priority
                                                             , 'Performance'                                                                                                                     as findingsgroup
                                                             , 'SSAS/SSIS/SSRS Installed'                                                                                                        as finding
                                                             , 'https://www.BrentOzar.com/go/services'                                                                                           as url
                                                             , 'Did you know you have other SQL Server services installed on this box other than the engine? It can be a real performance pain.' as details

                                                    end;

                                            end;
                                    end;

                                /* CheckID 232 - Server Info - Data Size */
                                if not EXISTS(select 1
                                              from #skipchecks
                                              where databasename is null
                                                and checkid = 232)
                                    begin

                                        if @debug in (1, 2) raiserror ('Running CheckId [%d].', 0, 1, 232) with nowait;

                                        if OBJECT_ID('tempdb..#MasterFiles') is not null
                                            drop table #masterfiles;
                                        create table #masterfiles
                                        (
                                            database_id int,
                                            file_id int,
                                            type_desc nvarchar(50),
                                            name nvarchar(255),
                                            physical_name nvarchar(255),
                                            size bigint
                                        );
                                        /* Azure SQL Database doesn't have sys.master_files, so we have to build our own. */
                                        if ((SERVERPROPERTY('Edition')) = 'SQL Azure'
                                            and (OBJECT_ID('sys.master_files') is null))
                                            set @stringtoexecute =
                                                    'INSERT INTO #MasterFiles (database_id, file_id, type_desc, name, physical_name, size) SELECT DB_ID(), file_id, type_desc, name, physical_name, size FROM sys.database_files;';
                                        else
                                            set @stringtoexecute =
                                                    'INSERT INTO #MasterFiles (database_id, file_id, type_desc, name, physical_name, size) SELECT database_id, file_id, type_desc, name, physical_name, size FROM sys.master_files;';
                                        exec (@stringtoexecute);


                                        insert into #blitzresults
                                        (checkid,
                                         priority,
                                         findingsgroup,
                                         finding,
                                         url,
                                         details)
                                        select 232                   as checkid
                                             , 250                   as priority
                                             , 'Server Info'         as findingsgroup
                                             , 'Data Size'           as finding
                                             , ''                    as url
                                             , CAST(COUNT(distinct database_id) as nvarchar(100)) + N' databases, ' +
                                               CAST(
                                                       CAST(SUM(CAST(size as bigint) * 8. / 1024. / 1024.) as money) as varchar(100)) +
                                               ' GB total file size' as details
                                        from #masterfiles
                                        where database_id > 4;

                                    end;


                            end; /* IF @CheckServerInfo = 1 */
                    end;
                /* IF ( ( SERVERPROPERTY('ServerName') NOT IN ( SELECT ServerName */

                /* Delete priorites they wanted to skip. */
                if @ignoreprioritiesabove is not null
                    delete #blitzresults
                    where [Priority] > @ignoreprioritiesabove
                      and checkid <> -1;

                if @ignoreprioritiesbelow is not null
                    delete #blitzresults
                    where [Priority] < @ignoreprioritiesbelow
                      and checkid <> -1;

                /* Delete checks they wanted to skip. */
                if @skipcheckstable is not null
                    begin
                        delete
                        from #blitzresults
                        where databasename in (select databasename
                                               from #skipchecks
                                               where checkid is null
                                                 and (servername is null or servername = SERVERPROPERTY('ServerName')));
                        delete
                        from #blitzresults
                        where checkid in (select checkid
                                          from #skipchecks
                                          where databasename is null
                                            and (servername is null or servername = SERVERPROPERTY('ServerName')));
                        delete r
                        from #blitzresults r
                                 inner join #skipchecks c on r.databasename = c.databasename and r.checkid = c.checkid
                            and (servername is null or servername = SERVERPROPERTY('ServerName'));
                    end;

                /* Add summary mode */
                if @summarymode > 0
                    begin
                        update #blitzresults
                        set finding = br.finding + ' (' + CAST(brtotals.recs as nvarchar(20)) + ')'
                        from #blitzresults br
                                 inner join (select findingsgroup, finding, priority, COUNT(*) as recs
                                             from #blitzresults
                                             group by findingsgroup, finding, priority) brtotals
                                            on br.findingsgroup = brtotals.findingsgroup and
                                               br.finding = brtotals.finding and br.priority = brtotals.priority
                        where brtotals.recs > 1;

                        delete br
                        from #blitzresults br
                        where EXISTS(select *
                                     from #blitzresults brlower
                                     where br.findingsgroup = brlower.findingsgroup
                                       and br.finding = brlower.finding
                                       and br.priority = brlower.priority
                                       and br.id > brlower.id);

                    end;

                /* Add credits for the nice folks who put so much time into building and maintaining this for free: */

                insert into #blitzresults
                (checkid,
                 priority,
                 findingsgroup,
                 finding,
                 url,
                 details)
                values (-1,
                        255,
                        'Thanks!',
                        'From Your Community Volunteers',
                        'http://FirstResponderKit.org',
                        'We hope you found this tool useful.');

                insert into #blitzresults
                (checkid,
                 priority,
                 findingsgroup,
                 finding,
                 url,
                 details)
                values (-1,
                        0,
                        'sp_Blitz ' + CAST(CONVERT(datetime, @versiondate, 102) as varchar(100)),
                        'SQL Server First Responder Kit',
                        'http://FirstResponderKit.org/',
                        'To get help or add your own contributions, join us at http://FirstResponderKit.org.');

                insert into #blitzresults
                (checkid,
                 priority,
                 findingsgroup,
                 finding,
                 url,
                 details)
                select 156,
                       254,
                       'Rundate',
                       GETDATE(),
                       'http://FirstResponderKit.org/',
                       'Captain''s log: stardate something and something...';

                if @emailrecipients is not null
                    begin

                        if @debug in (1, 2) raiserror ('Sending an email.', 0, 1) with nowait;

                        /* Database mail won't work off a local temp table. I'm not happy about this hacky workaround either. */
                        if (OBJECT_ID('tempdb..##BlitzResults', 'U') is not null) drop table ##blitzresults;
                        select * into ##blitzresults from #blitzresults;
                        set @query_result_separator = char(9);
                        set @stringtoexecute =
                                'SET NOCOUNT ON;SELECT [Priority] , [FindingsGroup] , [Finding] , [DatabaseName] , [URL] ,  [Details] , CheckID FROM ##BlitzResults ORDER BY Priority , FindingsGroup, Finding, Details; SET NOCOUNT OFF;';
                        set @emailsubject = 'sp_Blitz Results for ' + @@SERVERNAME;
                        set @emailbody = 'sp_Blitz ' + CAST(CONVERT(datetime, @versiondate, 102) as varchar(100)) +
                                         '. http://FirstResponderKit.org';
                        if @emailprofile is null
                            exec msdb.dbo.sp_send_dbmail
                                 @recipients = @emailrecipients,
                                 @subject = @emailsubject,
                                 @body = @emailbody,
                                 @query_attachment_filename = 'sp_Blitz-Results.csv',
                                 @attach_query_result_as_file = 1,
                                 @query_result_header = 1,
                                 @query_result_width = 32767,
                                 @append_query_error = 1,
                                 @query_result_no_padding = 1,
                                 @query_result_separator = @query_result_separator,
                                 @query = @stringtoexecute;
                        else
                            exec msdb.dbo.sp_send_dbmail
                                 @profile_name = @emailprofile,
                                 @recipients = @emailrecipients,
                                 @subject = @emailsubject,
                                 @body = @emailbody,
                                 @query_attachment_filename = 'sp_Blitz-Results.csv',
                                 @attach_query_result_as_file = 1,
                                 @query_result_header = 1,
                                 @query_result_width = 32767,
                                 @append_query_error = 1,
                                 @query_result_no_padding = 1,
                                 @query_result_separator = @query_result_separator,
                                 @query = @stringtoexecute;
                        if (OBJECT_ID('tempdb..##BlitzResults', 'U') is not null) drop table ##blitzresults;
                    end;

                /* Checks if @OutputServerName is populated with a valid linked server, and that the database name specified is valid */
                declare @validoutputserver bit;
                declare @validoutputlocation bit;
                declare @linkedserverdbcheck nvarchar(2000);
                declare @validlinkedserverdb int;
                declare @tmpdbchk table
                                  (
                                      cnt int
                                  );
                if @outputservername is not null
                    begin

                        if @debug in (1, 2) raiserror ('Outputting to a remote server.', 0, 1) with nowait;

                        if EXISTS(select server_id from sys.servers where QUOTENAME([name]) = @outputservername)
                            begin
                                set @linkedserverdbcheck = 'SELECT 1 WHERE EXISTS (SELECT * FROM ' + @outputservername +
                                                           '.master.sys.databases WHERE QUOTENAME([name]) = ''' +
                                                           @outputdatabasename + ''')';
                                insert into @tmpdbchk exec sys.sp_executesql @linkedserverdbcheck;
                                set @validlinkedserverdb = (select COUNT(*) from @tmpdbchk);
                                if (@validlinkedserverdb > 0)
                                    begin
                                        set @validoutputserver = 1;
                                        set @validoutputlocation = 1;
                                    end;
                                else
                                    raiserror ('The specified database was not found on the output server', 16, 0);
                            end;
                        else
                            begin
                                raiserror ('The specified output server was not found', 16, 0);
                            end;
                    end;
                else
                    begin
                        if @outputdatabasename is not null
                            and @outputschemaname is not null
                            and @outputtablename is not null
                            and EXISTS(select *
                                       from sys.databases
                                       where QUOTENAME([name]) = @outputdatabasename)
                            begin
                                set @validoutputlocation = 1;
                            end;
                        else
                            if @outputdatabasename is not null
                                and @outputschemaname is not null
                                and @outputtablename is not null
                                and not EXISTS(select *
                                               from sys.databases
                                               where QUOTENAME([name]) = @outputdatabasename)
                                begin
                                    raiserror ('The specified output database was not found on this server', 16, 0);
                                end;
                            else
                                begin
                                    set @validoutputlocation = 0;
                                end;
                    end;

                /* @OutputTableName lets us export the results to a permanent table */
                if @validoutputlocation = 1
                    begin
                        set @stringtoexecute = 'USE '
                            + @outputdatabasename
                            + '; IF EXISTS(SELECT * FROM '
                            + @outputdatabasename
                            + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                            + @outputschemaname
                            + ''') AND NOT EXISTS (SELECT * FROM '
                            + @outputdatabasename
                            + '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
                            + @outputschemaname + ''' AND QUOTENAME(TABLE_NAME) = '''
                            + @outputtablename + ''') CREATE TABLE '
                            + @outputschemaname + '.'
                            + @outputtablename
                            + ' (ID INT IDENTITY(1,1) NOT NULL,
								ServerName NVARCHAR(128),
								CheckDate DATETIMEOFFSET,
								Priority TINYINT ,
								FindingsGroup VARCHAR(50) ,
								Finding VARCHAR(200) ,
								DatabaseName NVARCHAR(128),
								URL VARCHAR(200) ,
								Details NVARCHAR(4000) ,
								QueryPlan [XML] NULL ,
								QueryPlanFiltered [NVARCHAR](MAX) NULL,
								CheckID INT ,
								CONSTRAINT [PK_' + CAST(NEWID() as char(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));';
                        if @validoutputserver = 1
                            begin
                                set @stringtoexecute = REPLACE(@stringtoexecute, '''' + @outputschemaname + '''',
                                                               '''''' + @outputschemaname + '''''');
                                set @stringtoexecute = REPLACE(@stringtoexecute, '''' + @outputtablename + '''',
                                                               '''''' + @outputtablename + '''''');
                                set @stringtoexecute = REPLACE(@stringtoexecute, '[XML]', '[NVARCHAR](MAX)');
                                exec ('EXEC('''+@stringtoexecute+''') AT ' + @outputservername);
                            end;
                        else
                            begin
                                exec (@stringtoexecute);
                            end;
                        if @validoutputserver = 1
                            begin
                                set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                                    + @outputservername + '.'
                                    + @outputdatabasename
                                    + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                    + @outputschemaname + ''') INSERT '
                                    + @outputservername + '.'
                                    + @outputdatabasename + '.'
                                    + @outputschemaname + '.'
                                    + @outputtablename
                                    +
                                                       ' (ServerName, CheckDate, CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered) SELECT '''
                                    + CAST(SERVERPROPERTY('ServerName') as nvarchar(128))
                                    +
                                                       ''', SYSDATETIMEOFFSET(), CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, CAST(QueryPlan AS NVARCHAR(MAX)), QueryPlanFiltered FROM #BlitzResults ORDER BY Priority , FindingsGroup , Finding , Details';

                                exec (@stringtoexecute);
                            end;
                        else
                            begin
                                set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                                    + @outputdatabasename
                                    + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                    + @outputschemaname + ''') INSERT '
                                    + @outputdatabasename + '.'
                                    + @outputschemaname + '.'
                                    + @outputtablename
                                    +
                                                       ' (ServerName, CheckDate, CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered) SELECT '''
                                    + CAST(SERVERPROPERTY('ServerName') as nvarchar(128))
                                    +
                                                       ''', SYSDATETIMEOFFSET(), CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered FROM #BlitzResults ORDER BY Priority , FindingsGroup , Finding , Details';

                                exec (@stringtoexecute);
                            end;
                    end;
                else
                    if (SUBSTRING(@outputtablename, 2, 2) = '##')
                        begin
                            if @validoutputserver = 1
                                begin
                                    raiserror ('Due to the nature of temporary tables, outputting to a linked server requires a permanent table.', 16, 0);
                                end;
                            else
                                begin
                                    set @stringtoexecute = N' IF (OBJECT_ID(''tempdb..'
                                        + @outputtablename
                                        + ''') IS NOT NULL) DROP TABLE ' + @outputtablename + ';'
                                        + 'CREATE TABLE '
                                        + @outputtablename
                                        + ' (ID INT IDENTITY(1,1) NOT NULL,
										ServerName NVARCHAR(128),
										CheckDate DATETIMEOFFSET,
										Priority TINYINT ,
										FindingsGroup VARCHAR(50) ,
										Finding VARCHAR(200) ,
										DatabaseName NVARCHAR(128),
										URL VARCHAR(200) ,
										Details NVARCHAR(4000) ,
										QueryPlan [XML] NULL ,
										QueryPlanFiltered [NVARCHAR](MAX) NULL,
										CheckID INT ,
										CONSTRAINT [PK_' + CAST(NEWID() as char(36)) +
                                                           '] PRIMARY KEY CLUSTERED (ID ASC));'
                                        + ' INSERT '
                                        + @outputtablename
                                        +
                                                           ' (ServerName, CheckDate, CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered) SELECT '''
                                        + CAST(SERVERPROPERTY('ServerName') as nvarchar(128))
                                        +
                                                           ''', SYSDATETIMEOFFSET(), CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered FROM #BlitzResults ORDER BY Priority , FindingsGroup , Finding , Details';

                                    exec (@stringtoexecute);
                                end;
                        end;
                    else
                        if (SUBSTRING(@outputtablename, 2, 1) = '#')
                            begin
                                raiserror ('Due to the nature of Dymamic SQL, only global (i.e. double pound (##)) temp tables are supported for @OutputTableName', 16, 0);
                            end;

                declare @separator as varchar(1);
                if @outputtype = 'RSV'
                    set @separator = CHAR(31);
                else
                    set @separator = ',';

                if @outputtype = 'COUNT'
                    begin
                        select COUNT(*) as warnings
                        from #blitzresults;
                    end;
                else
                    if @outputtype in ('CSV', 'RSV')
                        begin

                            select result = CAST([Priority] as nvarchar(100))
                                + @separator + CAST(checkid as nvarchar(100))
                                + @separator + COALESCE([FindingsGroup],
                                                        '(N/A)') + @separator
                                + COALESCE([Finding], '(N/A)') + @separator
                                + COALESCE(databasename, '(N/A)') + @separator
                                + COALESCE([URL], '(N/A)') + @separator
                                + COALESCE([Details], '(N/A)')
                            from #blitzresults
                            order by priority,
                                     findingsgroup,
                                     finding,
                                     databasename,
                                     details;
                        end;
                    else
                        if @outputxmlasnvarchar = 1 and @outputtype <> 'NONE'
                            begin
                                select [Priority],
                                       [FindingsGroup],
                                       [Finding],
                                       [DatabaseName],
                                       [URL],
                                       [Details],
                                       CAST([QueryPlan] as nvarchar(max)) as queryplan,
                                       [QueryPlanFiltered],
                                       checkid
                                from #blitzresults
                                order by priority,
                                         findingsgroup,
                                         finding,
                                         databasename,
                                         details;
                            end;
                        else
                            if @outputtype = 'MARKDOWN'
                                begin
                                    with results as (select row_number()
                                                                    over (order by priority, findingsgroup, finding, databasename, details) as rownum,
                                                            *
                                                     from #blitzresults
                                                     where priority > 0
                                                       and priority < 255
                                                       and findingsgroup is not null
                                                       and finding is not null
                                                       and findingsgroup <> 'Security' /* Specifically excluding security checks for public exports */)
                                    select case
                                               when r.priority <> COALESCE(rprior.priority, 0) or
                                                    r.findingsgroup <> rprior.findingsgroup then @crlf +
                                                                                                 N'**Priority ' +
                                                                                                 CAST(COALESCE(r.priority, N'') as nvarchar(5)) +
                                                                                                 N': ' +
                                                                                                 COALESCE(r.findingsgroup, N'') +
                                                                                                 N'**:' + @crlf + @crlf
                                               else N''
                                               end
                                               + case
                                                     when r.finding <> COALESCE(rprior.finding, N'') and
                                                          r.finding <> rnext.finding then N'- ' +
                                                                                          COALESCE(r.finding, N'') +
                                                                                          N' ' +
                                                                                          COALESCE(r.databasename, N'') +
                                                                                          N' - ' +
                                                                                          COALESCE(r.details, N'') +
                                                                                          @crlf
                                                     when r.finding <> COALESCE(rprior.finding, N'') and
                                                          r.finding = rnext.finding and r.details = rnext.details then
                                                             N'- ' + COALESCE(r.finding, N'') + N' - ' +
                                                             COALESCE(r.details, N'') + @crlf + @crlf + N'    * ' +
                                                             COALESCE(r.databasename, N'') + @crlf
                                                     when r.finding <> COALESCE(rprior.finding, N'') and
                                                          r.finding = rnext.finding then N'- ' +
                                                                                         COALESCE(r.finding, N'') +
                                                                                         @crlf + case
                                                                                                     when r.databasename is null
                                                                                                         then N''
                                                                                                     else N'    * ' + COALESCE(r.databasename, N'') end +
                                                                                         case
                                                                                             when r.details <> rprior.details
                                                                                                 then N' - ' + COALESCE(r.details, N'') + @crlf
                                                                                             else '' end
                                                     else case
                                                              when r.databasename is null then N''
                                                              else N'    * ' + COALESCE(r.databasename, N'') end + case
                                                                                                                       when r.details <> rprior.details
                                                                                                                           then N' - ' + COALESCE(r.details, N'') + @crlf
                                                                                                                       else N'' + @crlf end
                                               end + @crlf
                                    from results r
                                             left outer join results rprior on r.rownum = rprior.rownum + 1
                                             left outer join results rnext on r.rownum = rnext.rownum - 1
                                    order by r.rownum
                                    for xml path(N'');
                                end;
                            else
                                if @outputtype = 'XML'
                                    begin
                                        /* --TOURSTOP05-- */
                                        select [Priority],
                                               [FindingsGroup],
                                               [Finding],
                                               [DatabaseName],
                                               [URL],
                                               [Details],
                                               [QueryPlanFiltered],
                                               checkid
                                        from #blitzresults
                                        order by priority,
                                                 findingsgroup,
                                                 finding,
                                                 databasename,
                                                 details
                                        for xml path('Result'), root('sp_Blitz_Output');
                                    end;
                                else
                                    if @outputtype <> 'NONE'
                                        begin
                                            /* --TOURSTOP05-- */
                                            select [Priority],
                                                   [FindingsGroup],
                                                   [Finding],
                                                   [DatabaseName],
                                                   [URL],
                                                   [Details],
                                                   [QueryPlan],
                                                   [QueryPlanFiltered],
                                                   checkid
                                            from #blitzresults
                                            order by priority,
                                                     findingsgroup,
                                                     finding,
                                                     databasename,
                                                     details;
                                        end;

                drop table #blitzresults;

                if @outputprocedurecache = 1
                    and @checkprocedurecache = 1
                    select top 20 total_worker_time / execution_count   as avgcpu,
                                  total_worker_time                     as totalcpu,
                                  CAST(ROUND(100.00 * total_worker_time
                                                 / (select SUM(total_worker_time)
                                                    from sys.dm_exec_query_stats
                                             ), 2) as money)            as percentcpu,
                                  total_elapsed_time / execution_count  as avgduration,
                                  total_elapsed_time                    as totalduration,
                                  CAST(ROUND(100.00 * total_elapsed_time
                                                 / (select SUM(total_elapsed_time)
                                                    from sys.dm_exec_query_stats
                                             ), 2) as money)            as percentduration,
                                  total_logical_reads / execution_count as avgreads,
                                  total_logical_reads                   as totalreads,
                                  CAST(ROUND(100.00 * total_logical_reads
                                                 / (select SUM(total_logical_reads)
                                                    from sys.dm_exec_query_stats
                                             ), 2) as money)            as percentreads,
                                  execution_count,
                                  CAST(ROUND(100.00 * execution_count
                                                 / (select SUM(execution_count)
                                                    from sys.dm_exec_query_stats
                                             ), 2) as money)            as percentexecutions,
                                  case
                                      when DATEDIFF(mi, creation_time,
                                                    qs.last_execution_time) = 0 then 0
                                      else CAST((1.00 * execution_count / DATEDIFF(mi,
                                                                                   creation_time,
                                                                                   qs.last_execution_time)) as money)
                                      end                               as executions_per_minute,
                                  qs.creation_time                      as plan_creation_time,
                                  qs.last_execution_time,
                                  text,
                                  text_filtered,
                                  query_plan,
                                  query_plan_filtered,
                                  sql_handle,
                                  query_hash,
                                  plan_handle,
                                  query_plan_hash
                    from #dm_exec_query_stats qs
                    order by case UPPER(@checkprocedurecachefilter)
                                 when 'CPU' then total_worker_time
                                 when 'READS' then total_logical_reads
                                 when 'EXECCOUNT' then execution_count
                                 when 'DURATION' then total_elapsed_time
                                 else total_worker_time
                                 end desc;

            end; /* ELSE -- IF @OutputType = 'SCHEMA' */

/*
	   Cleanups - drop temporary tables that have been created by this SP.
    */

    if (OBJECT_ID('tempdb..#InvalidLogins') is not null)
        begin
            exec sp_executesql N'DROP TABLE #InvalidLogins;';
        end;

    /*
	Reset the Nmumeric_RoundAbort session state back to enabled if it was disabled earlier.
	See Github issue #2302 for more info.
	*/
    if @needtoturnnumericroundabortbackon = 1
        set numeric_roundabort on;

    set nocount off;
go

/*
--Sample execution call with the most common parameters:
EXEC [dbo].[sp_Blitz]
    @CheckUserDatabaseObjects = 1 ,
    @CheckProcedureCache = 0 ,
    @OutputType = 'TABLE' ,
    @OutputProcedureCache = 0 ,
    @CheckProcedureCacheFilter = NULL,
    @CheckServerInfo = 1
*/
if OBJECT_ID('dbo.sp_BlitzBackups') is null
    exec ('CREATE PROCEDURE dbo.sp_BlitzBackups AS RETURN 0;');
go
alter procedure [dbo].[sp_BlitzBackups] @help tinyint = 0,
                                        @hoursback int = 168,
                                        @msdbname nvarchar(256) = 'msdb',
                                        @agname nvarchar(256) = null,
                                        @restorespeedfullmbps int = null,
                                        @restorespeeddiffmbps int = null,
                                        @restorespeedlogmbps int = null,
                                        @debug tinyint = 0,
                                        @pushbackuphistorytolistener bit = 0,
                                        @writebackupstolistenername nvarchar(256) = null,
                                        @writebackupstodatabasename nvarchar(256) = null,
                                        @writebackupslasthours int = 168,
                                        @version varchar(30) = null output,
                                        @versiondate datetime = null output,
                                        @versioncheckmode bit = 0
    with recompile
as
begin
    set nocount on;
    set transaction isolation level read uncommitted;

    select @version = '3.97', @versiondate = '20200712';

    if (@versioncheckmode = 1)
        begin
            return;
        end;

    if @help = 1
        print '
	/*
	sp_BlitzBackups from http://FirstResponderKit.org

	This script checks your backups to see how much data you might lose when
	this server fails, and how long it might take to recover.

	To learn more, visit http://FirstResponderKit.org where you can download new
	versions for free, watch training videos on how it works, get more info on
	the findings, contribute your own code, and more.

	Known limitations of this version:
	 - Only Microsoft-supported versions of SQL Server. Sorry, 2005 and 2000.

	Unknown limitations of this version:
	 - None.  (If we knew them, they would be known. Duh.)

     Changes - for the full list of improvements and fixes in this version, see:
     https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/


	Parameter explanations:

	@HoursBack INT = 168		How many hours of history to examine, back from now.
								You can check just the last 24 hours of backups, for example.
	@MSDBName NVARCHAR(255) 	You can restore MSDB from different servers and check them
								centrally. Also useful if you create a DBA utility database
								and merge data from several servers in an AG into one DB.
	@RestoreSpeedFullMBps INT	By default, we use the backup speed from MSDB to guesstimate
								how fast your restores will go. If you have done performance
								tuning and testing of your backups (or if they horribly go even
								slower in your DR environment, and you want to account for
								that), then you can pass in different numbers here.
	@RestoreSpeedDiffMBps INT	See above.
	@RestoreSpeedLogMBps INT	See above.

	For more documentation: https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/

    MIT License

	Copyright (c) 2020 Brent Ozar Unlimited

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.




	*/';
    else
        begin
            declare @stringtoexecute nvarchar(max) = N'',
                @innerstringtoexecute nvarchar(max) = N'',
                @productversion nvarchar(128),
                @productversionmajor decimal(10, 2),
                @productversionminor decimal(10, 2),
                @starttime datetime2, @resulttext nvarchar(max),
                @crlf nvarchar(2),
                @moreinfoheader nvarchar(100),
                @moreinfofooter nvarchar(100);

            if @hoursback > 0
                set @hoursback = @hoursback * -1;

            if @writebackupslasthours > 0
                set @writebackupslasthours = @writebackupslasthours * -1;

            select @crlf = NCHAR(13) + NCHAR(10),
                   @starttime = DATEADD(hh, @hoursback, GETDATE()),
                   @moreinfoheader = N'<?ClickToSeeDetails -- ' + @crlf,
                   @moreinfofooter = @crlf + N' -- ?>';

            set @productversion = CAST(SERVERPROPERTY('ProductVersion') as nvarchar(128));
            select @productversionmajor = SUBSTRING(@productversion, 1, CHARINDEX('.', @productversion) + 1),
                   @productversionminor = PARSENAME(CONVERT(varchar(32), @productversion), 2);

            create table #backups
            (
                id int identity (1, 1),
                database_name nvarchar(128),
                database_guid uniqueidentifier,
                rpoworstcaseminutes decimal(18, 1),
                rtoworstcaseminutes decimal(18, 1),
                rpoworstcasebackupsetid int,
                rpoworstcasebackupsetfinishtime datetime,
                rpoworstcasebackupsetidprior int,
                rpoworstcasebackupsetpriorfinishtime datetime,
                rpoworstcasemoreinfoquery xml,
                rtoworstcasebackupfilesizemb decimal(18, 2),
                rtoworstcasemoreinfoquery xml,
                fullmbpsavg decimal(18, 2),
                fullmbpsmin decimal(18, 2),
                fullmbpsmax decimal(18, 2),
                fullsizembavg decimal(18, 2),
                fullsizembmin decimal(18, 2),
                fullsizembmax decimal(18, 2),
                fullcompressedsizembavg decimal(18, 2),
                fullcompressedsizembmin decimal(18, 2),
                fullcompressedsizembmax decimal(18, 2),
                diffmbpsavg decimal(18, 2),
                diffmbpsmin decimal(18, 2),
                diffmbpsmax decimal(18, 2),
                diffsizembavg decimal(18, 2),
                diffsizembmin decimal(18, 2),
                diffsizembmax decimal(18, 2),
                diffcompressedsizembavg decimal(18, 2),
                diffcompressedsizembmin decimal(18, 2),
                diffcompressedsizembmax decimal(18, 2),
                logmbpsavg decimal(18, 2),
                logmbpsmin decimal(18, 2),
                logmbpsmax decimal(18, 2),
                logsizembavg decimal(18, 2),
                logsizembmin decimal(18, 2),
                logsizembmax decimal(18, 2),
                logcompressedsizembavg decimal(18, 2),
                logcompressedsizembmin decimal(18, 2),
                logcompressedsizembmax decimal(18, 2)
            );

            create table #rtorecoverypoints
            (
                id int identity (1, 1),
                database_name nvarchar(128),
                database_guid uniqueidentifier,
                rto_worst_case_size_mb as
                    (COALESCE(log_file_size_mb, 0) + COALESCE(diff_file_size_mb, 0) + COALESCE(full_file_size_mb, 0)),
                rto_worst_case_time_seconds as
                    (COALESCE(log_time_seconds, 0) + COALESCE(diff_time_seconds, 0) + COALESCE(full_time_seconds, 0)),
                full_backup_set_id int,
                full_last_lsn numeric(25, 0),
                full_backup_set_uuid uniqueidentifier,
                full_time_seconds bigint,
                full_file_size_mb decimal(18, 2),
                diff_backup_set_id int,
                diff_last_lsn numeric(25, 0),
                diff_time_seconds bigint,
                diff_file_size_mb decimal(18, 2),
                log_backup_set_id int,
                log_last_lsn numeric(25, 0),
                log_time_seconds bigint,
                log_file_size_mb decimal(18, 2),
                log_backups int
            );

            create table #recoverability
            (
                id int identity,
                databasename nvarchar(128),
                databaseguid uniqueidentifier,
                lastbackuprecoverymodel nvarchar(60),
                firstfullbackupsizemb decimal(18, 2),
                firstfullbackupdate datetime,
                lastfullbackupsizemb decimal(18, 2),
                lastfullbackupdate datetime,
                avgfullbackupthroughputmb decimal(18, 2),
                avgfullbackupdurationseconds int,
                avgdiffbackupthroughputmb decimal(18, 2),
                avgdiffbackupdurationseconds int,
                avglogbackupthroughputmb decimal(18, 2),
                avglogbackupdurationseconds int,
                avgfullsizemb decimal(18, 2),
                avgdiffsizemb decimal(18, 2),
                avglogsizemb decimal(18, 2),
                isbigdiff as case
                                 when (avgfullsizemb > 10240. and ((avgdiffsizemb * 100.) / avgfullsizemb >= 40.))
                                     then 1
                                 else 0 end,
                isbiglog as case
                                when (avgfullsizemb > 10240. and ((avglogsizemb * 100.) / avgfullsizemb >= 20.)) then 1
                                else 0 end
            );

            create table #trending
            (
                databasename nvarchar(128),
                databaseguid uniqueidentifier,
                [0] decimal(18, 2),
                [-1] decimal(18, 2),
                [-2] decimal(18, 2),
                [-3] decimal(18, 2),
                [-4] decimal(18, 2),
                [-5] decimal(18, 2),
                [-6] decimal(18, 2),
                [-7] decimal(18, 2),
                [-8] decimal(18, 2),
                [-9] decimal(18, 2),
                [-10] decimal(18, 2),
                [-11] decimal(18, 2),
                [-12] decimal(18, 2)
            );


            create table #warnings
            (
                id int identity (1, 1) primary key clustered,
                checkid int,
                priority int,
                databasename varchar(128),
                finding varchar(256),
                warning varchar(8000)
            );

            if not EXISTS(select * from sys.databases where name = @msdbname)
                begin
                    raiserror ('@MSDBName was specified, but the database does not exist.', 16, 1) with nowait;
                    return;
                end

            if @pushbackuphistorytolistener = 1
                goto pushbackuphistorytolistener


            raiserror ('Inserting to #Backups', 0, 1) with nowait;

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute +=
                    N'WITH Backups AS (SELECT bs.database_name, bs.database_guid, bs.type AS backup_type ' + @crlf
                    +
                    ' , MBpsAvg = CAST(AVG(( bs.backup_size / ( CASE WHEN DATEDIFF(ss, bs.backup_start_date, bs.backup_finish_date) = 0 THEN 1 ELSE DATEDIFF(ss, bs.backup_start_date, bs.backup_finish_date) END ) / 1048576 )) AS INT) ' +
                    @crlf
                    +
                    ' , MBpsMin = CAST(MIN(( bs.backup_size / ( CASE WHEN DATEDIFF(ss, bs.backup_start_date, bs.backup_finish_date) = 0 THEN 1 ELSE DATEDIFF(ss, bs.backup_start_date, bs.backup_finish_date) END ) / 1048576 )) AS INT) ' +
                    @crlf
                    +
                    ' , MBpsMax = CAST(MAX(( bs.backup_size / ( CASE WHEN DATEDIFF(ss, bs.backup_start_date, bs.backup_finish_date) = 0 THEN 1 ELSE DATEDIFF(ss, bs.backup_start_date, bs.backup_finish_date) END ) / 1048576 )) AS INT) ' +
                    @crlf
                    + ' , SizeMBAvg = AVG(backup_size / 1048576.0) ' + @crlf
                    + ' , SizeMBMin = MIN(backup_size / 1048576.0) ' + @crlf
                    + ' , SizeMBMax = MAX(backup_size / 1048576.0) ' + @crlf
                    + ' , CompressedSizeMBAvg = AVG(compressed_backup_size / 1048576.0) ' + @crlf
                    + ' , CompressedSizeMBMin = MIN(compressed_backup_size / 1048576.0) ' + @crlf
                    + ' , CompressedSizeMBMax = MAX(compressed_backup_size / 1048576.0) ' + @crlf;


            set @stringtoexecute += N' FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset bs ' + @crlf
                + N' WHERE bs.backup_finish_date >= @StartTime AND bs.is_damaged = 0 ' + @crlf
                + N' GROUP BY bs.database_name, bs.database_guid, bs.type)' + @crlf;

            set @stringtoexecute += + N'INSERT INTO #Backups(database_name, database_guid, ' + @crlf
                +
                                    N' FullMBpsAvg, FullMBpsMin, FullMBpsMax, FullSizeMBAvg, FullSizeMBMin, FullSizeMBMax, FullCompressedSizeMBAvg, FullCompressedSizeMBMin, FullCompressedSizeMBMax, ' +
                                    @crlf
                +
                                    N' DiffMBpsAvg, DiffMBpsMin, DiffMBpsMax, DiffSizeMBAvg, DiffSizeMBMin, DiffSizeMBMax, DiffCompressedSizeMBAvg, DiffCompressedSizeMBMin, DiffCompressedSizeMBMax, ' +
                                    @crlf
                +
                                    N' LogMBpsAvg, LogMBpsMin, LogMBpsMax, LogSizeMBAvg, LogSizeMBMin, LogSizeMBMax, LogCompressedSizeMBAvg, LogCompressedSizeMBMin, LogCompressedSizeMBMax ) ' +
                                    @crlf
                + N'SELECT bF.database_name, bF.database_guid ' + @crlf
                + N' , bF.MBpsAvg AS FullMBpsAvg ' + @crlf
                + N' , bF.MBpsMin AS FullMBpsMin ' + @crlf
                + N' , bF.MBpsMax AS FullMBpsMax ' + @crlf
                + N' , bF.SizeMBAvg AS FullSizeMBAvg ' + @crlf
                + N' , bF.SizeMBMin AS FullSizeMBMin ' + @crlf
                + N' , bF.SizeMBMax AS FullSizeMBMax ' + @crlf
                + N' , bF.CompressedSizeMBAvg AS FullCompressedSizeMBAvg ' + @crlf
                + N' , bF.CompressedSizeMBMin AS FullCompressedSizeMBMin ' + @crlf
                + N' , bF.CompressedSizeMBMax AS FullCompressedSizeMBMax ' + @crlf
                + N' , bD.MBpsAvg AS DiffMBpsAvg ' + @crlf
                + N' , bD.MBpsMin AS DiffMBpsMin ' + @crlf
                + N' , bD.MBpsMax AS DiffMBpsMax ' + @crlf
                + N' , bD.SizeMBAvg AS DiffSizeMBAvg ' + @crlf
                + N' , bD.SizeMBMin AS DiffSizeMBMin ' + @crlf
                + N' , bD.SizeMBMax AS DiffSizeMBMax ' + @crlf
                + N' , bD.CompressedSizeMBAvg AS DiffCompressedSizeMBAvg ' + @crlf
                + N' , bD.CompressedSizeMBMin AS DiffCompressedSizeMBMin ' + @crlf
                + N' , bD.CompressedSizeMBMax AS DiffCompressedSizeMBMax ' + @crlf
                + N' , bL.MBpsAvg AS LogMBpsAvg ' + @crlf
                + N' , bL.MBpsMin AS LogMBpsMin ' + @crlf
                + N' , bL.MBpsMax AS LogMBpsMax ' + @crlf
                + N' , bL.SizeMBAvg AS LogSizeMBAvg ' + @crlf
                + N' , bL.SizeMBMin AS LogSizeMBMin ' + @crlf
                + N' , bL.SizeMBMax AS LogSizeMBMax ' + @crlf
                + N' , bL.CompressedSizeMBAvg AS LogCompressedSizeMBAvg ' + @crlf
                + N' , bL.CompressedSizeMBMin AS LogCompressedSizeMBMin ' + @crlf
                + N' , bL.CompressedSizeMBMax AS LogCompressedSizeMBMax ' + @crlf
                + N' FROM Backups bF ' + @crlf
                +
                                    N' LEFT OUTER JOIN Backups bD ON bF.database_name = bD.database_name AND bF.database_guid = bD.database_guid AND bD.backup_type = ''I''' +
                                    @crlf
                +
                                    N' LEFT OUTER JOIN Backups bL ON bF.database_name = bL.database_name AND bF.database_guid = bL.database_guid AND bL.backup_type = ''L''' +
                                    @crlf
                + N' WHERE bF.backup_type = ''D''; ' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute, N'@StartTime DATETIME2', @starttime;


            raiserror ('Updating #Backups with worst RPO case', 0, 1) with nowait;

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							 SELECT  bs.database_name, bs.database_guid, bs.backup_set_id, bsPrior.backup_set_id AS backup_set_id_prior,
							         bs.backup_finish_date, bsPrior.backup_finish_date AS backup_finish_date_prior,
							         DATEDIFF(ss, bsPrior.backup_finish_date, bs.backup_finish_date) AS backup_gap_seconds
							 INTO #backup_gaps
							 FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS bs
							 CROSS APPLY (
							 	SELECT TOP 1 bs1.backup_set_id, bs1.backup_finish_date
							 	FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS bs1
							 	WHERE bs.database_name = bs1.database_name
							 	        AND bs.database_guid = bs1.database_guid
							 	        AND bs.backup_finish_date > bs1.backup_finish_date
							 			AND bs.backup_set_id > bs1.backup_set_id
							 	ORDER BY bs1.backup_finish_date DESC, bs1.backup_set_id DESC
							 ) bsPrior
							 WHERE bs.backup_finish_date > @StartTime

							 CREATE CLUSTERED INDEX cx_backup_gaps ON #backup_gaps (database_name, database_guid, backup_set_id, backup_finish_date, backup_gap_seconds);

							 WITH max_gaps AS (
							 SELECT g.database_name, g.database_guid, g.backup_set_id, g.backup_set_id_prior, g.backup_finish_date_prior,
							        g.backup_finish_date, MAX(g.backup_gap_seconds) AS max_backup_gap_seconds
							 FROM #backup_gaps AS g
							 GROUP BY g.database_name, g.database_guid, g.backup_set_id, g.backup_set_id_prior, g.backup_finish_date_prior,  g.backup_finish_date
												)
							UPDATE #Backups
								SET   RPOWorstCaseMinutes = bg.max_backup_gap_seconds / 60.0
							        , RPOWorstCaseBackupSetID = bg.backup_set_id
									, RPOWorstCaseBackupSetFinishTime = bg.backup_finish_date
									, RPOWorstCaseBackupSetIDPrior = bg.backup_set_id_prior
									, RPOWorstCaseBackupSetPriorFinishTime = bg.backup_finish_date_prior
								FROM #Backups b
								INNER HASH JOIN max_gaps bg ON b.database_name = bg.database_name AND b.database_guid = bg.database_guid
								LEFT OUTER HASH JOIN max_gaps bgBigger ON bg.database_name = bgBigger.database_name AND bg.database_guid = bgBigger.database_guid AND bg.max_backup_gap_seconds < bgBigger.max_backup_gap_seconds
								WHERE bgBigger.backup_set_id IS NULL;
								';
            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute, N'@StartTime DATETIME2', @starttime;

            raiserror ('Updating #Backups with worst RPO case queries', 0, 1) with nowait;

            update #backups
            set rpoworstcasemoreinfoquery = @moreinfoheader + N'SELECT * ' + @crlf
                + N' FROM ' + QUOTENAME(@msdbname) + '.dbo.backupset ' + @crlf
                + N' WHERE database_name = ''' + database_name + ''' ' + @crlf
                + N' AND database_guid = ''' + CAST(database_guid as nvarchar(50)) + ''' ' + @crlf
                + N' AND backup_finish_date >= DATEADD(hh, -2, ''' + CAST(
                                                    CONVERT(datetime, rpoworstcasebackupsetpriorfinishtime, 102) as nvarchar(100)) +
                                            ''') ' + @crlf
                + N' AND backup_finish_date <= DATEADD(hh, 2, ''' + CAST(
                                                    CONVERT(datetime, rpoworstcasebackupsetpriorfinishtime, 102) as nvarchar(100)) +
                                            ''') ' + @crlf
                + N' ORDER BY backup_finish_date;'
                + @moreinfofooter;


/* RTO */

            raiserror ('Gathering RTO information', 0, 1) with nowait;


            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							 INSERT INTO #RTORecoveryPoints(database_name, database_guid, log_last_lsn)
							 SELECT database_name, database_guid, MAX(last_lsn) AS log_last_lsn
							 FROM ' + QUOTENAME(@msdbname) + '.dbo.backupset bLastLog
							 WHERE type = ''L''
							 AND bLastLog.backup_finish_date >= @StartTime
							 GROUP BY database_name, database_guid;
							';

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute, N'@StartTime DATETIME2', @starttime;

/* Find the most recent full backups for those logs */

            raiserror ('Updating #RTORecoveryPoints', 0, 1) with nowait;

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							 UPDATE #RTORecoveryPoints
							 SET log_backup_set_id = bLasted.backup_set_id
							     ,full_backup_set_id = bLasted.backup_set_id
							     ,full_last_lsn = bLasted.last_lsn
							     ,full_backup_set_uuid = bLasted.backup_set_uuid
							 FROM #RTORecoveryPoints rp
							 		CROSS APPLY (
							 				SELECT TOP 1 bLog.backup_set_id AS backup_set_id_log, bLastFull.backup_set_id, bLastFull.last_lsn, bLastFull.backup_set_uuid, bLastFull.database_guid, bLastFull.database_name
							 				FROM  ' + QUOTENAME(@msdbname) + N'.dbo.backupset bLog
							 				INNER JOIN ' + QUOTENAME(@msdbname) + N'.dbo.backupset bLastFull
							 					ON bLog.database_guid = bLastFull.database_guid
							 					AND bLog.database_name = bLastFull.database_name
							 					AND bLog.first_lsn > bLastFull.last_lsn
							 					AND bLastFull.type = ''D''
							 				WHERE rp.database_guid = bLog.database_guid
							 					AND rp.database_name = bLog.database_name
							 			) bLasted
							 LEFT OUTER JOIN ' + QUOTENAME(@msdbname) + N'.dbo.backupset bLaterFulls ON bLasted.database_guid = bLaterFulls.database_guid AND bLasted.database_name = bLaterFulls.database_name
							     AND bLasted.last_lsn < bLaterFulls.last_lsn
							     AND bLaterFulls.first_lsn < bLasted.last_lsn
							     AND bLaterFulls.type = ''D''
							 WHERE bLaterFulls.backup_set_id IS NULL;
							 ';

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute;

/* Add any full backups in the StartDate range that weren't part of the above log backup chain */

            raiserror ('Add any full backups in the StartDate range that weren''t part of the above log backup chain', 0, 1) with nowait;

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							 INSERT INTO #RTORecoveryPoints(database_name, database_guid, full_backup_set_id, full_last_lsn, full_backup_set_uuid)
							 SELECT bFull.database_name, bFull.database_guid, bFull.backup_set_id, bFull.last_lsn, bFull.backup_set_uuid
							 FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset bFull
							 LEFT OUTER JOIN #RTORecoveryPoints rp ON bFull.backup_set_uuid = rp.full_backup_set_uuid
							 WHERE bFull.type = ''D''
							     AND bFull.backup_finish_date IS NOT NULL
							     AND rp.full_backup_set_uuid IS NULL
							     AND bFull.backup_finish_date >= @StartTime;
							';

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute, N'@StartTime DATETIME2', @starttime;

/* Fill out the most recent log for that full, but before the next full */

            raiserror ('Fill out the most recent log for that full, but before the next full', 0, 1) with nowait;

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							UPDATE rp
						    SET log_last_lsn = (SELECT MAX(last_lsn) FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset bLog WHERE bLog.first_lsn >= rp.full_last_lsn AND bLog.first_lsn <= rpNextFull.full_last_lsn AND bLog.type = ''L'')
							FROM #RTORecoveryPoints rp
						    INNER JOIN #RTORecoveryPoints rpNextFull ON rp.database_guid = rpNextFull.database_guid AND rp.database_name = rpNextFull.database_name
						        AND rp.full_last_lsn < rpNextFull.full_last_lsn
						    LEFT OUTER JOIN #RTORecoveryPoints rpEarlierFull ON rp.database_guid = rpEarlierFull.database_guid AND rp.database_name = rpEarlierFull.database_name
						        AND rp.full_last_lsn < rpEarlierFull.full_last_lsn
						        AND rpNextFull.full_last_lsn > rpEarlierFull.full_last_lsn
						    WHERE rpEarlierFull.full_backup_set_id IS NULL;
							';

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute;

/* Fill out a diff in that range */

            raiserror ('Fill out a diff in that range', 0, 1) with nowait;

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							UPDATE #RTORecoveryPoints
							SET diff_last_lsn = (SELECT TOP 1 bDiff.last_lsn FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset bDiff
							                        WHERE rp.database_guid = bDiff.database_guid AND rp.database_name = bDiff.database_name
							                            AND bDiff.type = ''I''
							                            AND bDiff.last_lsn < rp.log_last_lsn
							                            AND rp.full_backup_set_uuid = bDiff.differential_base_guid
							                            ORDER BY bDiff.last_lsn DESC)
							FROM #RTORecoveryPoints rp
							WHERE diff_last_lsn IS NULL;
							';

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute;

/* Get time & size totals for full & diff */

            raiserror ('Get time & size totals for full & diff', 0, 1) with nowait;

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							UPDATE #RTORecoveryPoints
							    SET full_time_seconds = DATEDIFF(ss,bFull.backup_start_date, bFull.backup_finish_date)
							    , full_file_size_mb = bFull.backup_size / 1048576.0
							    , diff_backup_set_id = bDiff.backup_set_id
							    , diff_time_seconds = DATEDIFF(ss,bDiff.backup_start_date, bDiff.backup_finish_date)
							    , diff_file_size_mb = bDiff.backup_size / 1048576.0
							FROM #RTORecoveryPoints rp
							INNER JOIN ' + QUOTENAME(@msdbname) + N'.dbo.backupset bFull ON rp.database_guid = bFull.database_guid AND rp.database_name = bFull.database_name AND rp.full_last_lsn = bFull.last_lsn
							LEFT OUTER JOIN ' + QUOTENAME(@msdbname) + N'.dbo.backupset bDiff ON rp.database_guid = bDiff.database_guid AND rp.database_name = bDiff.database_name AND rp.diff_last_lsn = bDiff.last_lsn AND bDiff.last_lsn IS NOT NULL;
							';

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute;


/* Get time & size totals for logs */

            raiserror ('Get time & size totals for logs', 0, 1) with nowait;

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							WITH LogTotals AS (
								 SELECT rp.id, log_time_seconds = SUM(DATEDIFF(ss,bLog.backup_start_date, bLog.backup_finish_date))
								    , log_file_size = SUM(bLog.backup_size)
								    , SUM(1) AS log_backups
								        FROM #RTORecoveryPoints rp
								            INNER JOIN ' + QUOTENAME(@msdbname) + N'.dbo.backupset bLog ON rp.database_guid = bLog.database_guid AND rp.database_name = bLog.database_name AND bLog.type = ''L''
								            AND bLog.first_lsn > COALESCE(rp.diff_last_lsn, rp.full_last_lsn)
								            AND bLog.first_lsn <= rp.log_last_lsn
								        GROUP BY rp.id
								)
								UPDATE #RTORecoveryPoints
								    SET log_time_seconds = lt.log_time_seconds
								    , log_file_size_mb = lt.log_file_size / 1048576.0
								    , log_backups = lt.log_backups
								FROM #RTORecoveryPoints rp
								    INNER JOIN LogTotals lt ON rp.id = lt.id;
									';

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute;

            raiserror ('Gathering RTO worst cases', 0, 1) with nowait;

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							WITH WorstCases AS (
								SELECT rp.*
								  FROM #RTORecoveryPoints rp
								    LEFT OUTER JOIN #RTORecoveryPoints rpNewer
										ON rp.database_guid = rpNewer.database_guid
										AND rp.database_name = rpNewer.database_name
										AND rp.full_last_lsn < rpNewer.full_last_lsn
										AND rpNewer.rto_worst_case_size_mb = (SELECT TOP 1 rto_worst_case_size_mb FROM #RTORecoveryPoints s	WHERE rp.database_guid = s.database_guid AND rp.database_name = s.database_name ORDER BY rto_worst_case_size_mb DESC)
								  WHERE rp.rto_worst_case_size_mb = (SELECT TOP 1 rto_worst_case_size_mb FROM #RTORecoveryPoints s WHERE rp.database_guid = s.database_guid AND rp.database_name = s.database_name ORDER BY rto_worst_case_size_mb DESC)
								    /* OR  rp.rto_worst_case_time_seconds = (SELECT TOP 1 rto_worst_case_time_seconds FROM #RTORecoveryPoints s WHERE rp.database_guid = s.database_guid AND rp.database_name = s.database_name ORDER BY rto_worst_case_time_seconds DESC) */
								  AND rpNewer.database_guid IS NULL
								)
								UPDATE #Backups
										SET RTOWorstCaseMinutes =
                                                                    /* Fulls */
                                                                    (CASE WHEN @RestoreSpeedFullMBps IS NULL
																	   THEN wc.full_time_seconds / 60.0
																	   ELSE @RestoreSpeedFullMBps / wc.full_file_size_mb
																	   END)

                                                                    /* Diffs, which might not have been taken */
                                                                    + (CASE WHEN @RestoreSpeedDiffMBps IS NOT NULL AND wc.diff_file_size_mb IS NOT NULL
                                                                        THEN @RestoreSpeedDiffMBps / wc.diff_file_size_mb
                                                                        ELSE COALESCE(wc.diff_time_seconds,0) / 60.0
                                                                        END)

                                                                    /* Logs, which might not have been taken */
                                                                    + (CASE WHEN @RestoreSpeedLogMBps IS NOT NULL AND wc.log_file_size_mb IS NOT NULL
                                                                        THEN @RestoreSpeedLogMBps / wc.log_file_size_mb
                                                                        ELSE COALESCE(wc.log_time_seconds,0) / 60.0
                                                                        END)
								        , RTOWorstCaseBackupFileSizeMB = wc.rto_worst_case_size_mb
								FROM #Backups b
								INNER JOIN WorstCases wc
								ON b.database_guid = wc.database_guid
									AND b.database_name = wc.database_name;
								';

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute,
                 N'@RestoreSpeedFullMBps INT, @RestoreSpeedDiffMBps INT, @RestoreSpeedLogMBps INT',
                 @restorespeedfullmbps, @restorespeeddiffmbps, @restorespeedlogmbps;


            /*Populating Recoverability*/


            /*Get distinct list of databases*/
            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							 SELECT DISTINCT b.database_name, database_guid
							 FROM   ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b;'

            if @debug = 1
                print @stringtoexecute;

            insert #recoverability (databasename, databaseguid)
                exec sys.sp_executesql @stringtoexecute;


            /*Find most recent recovery model, backup size, and backup date*/
            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
								UPDATE r
								SET r.LastBackupRecoveryModel = ca.recovery_model,
									r.LastFullBackupSizeMB = ca.compressed_backup_size,
									r.LastFullBackupDate = ca.backup_finish_date
								FROM #Recoverability r
									CROSS APPLY (
										SELECT TOP 1 b.recovery_model, (b.compressed_backup_size / 1048576.0) AS compressed_backup_size, b.backup_finish_date
										FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
										WHERE r.DatabaseName = b.database_name
										AND r.DatabaseGUID = b.database_guid
										AND b.type = ''D''
										AND b.backup_finish_date > @StartTime
										ORDER BY b.backup_finish_date DESC
												) ca;'

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute, N'@StartTime DATETIME2', @starttime;

            /*Find first backup size and date*/
            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							UPDATE r
							SET r.FirstFullBackupSizeMB = ca.compressed_backup_size,
								r.FirstFullBackupDate = ca.backup_finish_date
							FROM #Recoverability r
								CROSS APPLY (
									SELECT TOP 1 (b.compressed_backup_size / 1048576.0) AS compressed_backup_size, b.backup_finish_date
									FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
									WHERE r.DatabaseName = b.database_name
									AND r.DatabaseGUID = b.database_guid
									AND b.type = ''D''
									AND b.backup_finish_date > @StartTime
									ORDER BY b.backup_finish_date ASC
											) ca;'

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute, N'@StartTime DATETIME2', @starttime;


            /*Find average backup throughputs for full, diff, and log*/
            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							UPDATE r
							SET r.AvgFullBackupThroughputMB = ca_full.AvgFullSpeed,
								r.AvgDiffBackupThroughputMB = ca_diff.AvgDiffSpeed,
								r.AvgLogBackupThroughputMB = ca_log.AvgLogSpeed,
								r.AvgFullBackupDurationSeconds = AvgFullDuration,
								r.AvgDiffBackupDurationSeconds = AvgDiffDuration,
								r.AvgLogBackupDurationSeconds = AvgLogDuration
							FROM #Recoverability AS r
							OUTER APPLY (
								SELECT b.database_name,
									   AVG( b.compressed_backup_size / ( DATEDIFF(ss, b.backup_start_date, b.backup_finish_date) ) / 1048576.0 ) AS AvgFullSpeed,
									   AVG( DATEDIFF(ss, b.backup_start_date, b.backup_finish_date) ) AS AvgFullDuration
								FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset b
								WHERE r.DatabaseName = b.database_name
								AND r.DatabaseGUID = b.database_guid
								AND b.type = ''D''
								AND DATEDIFF(SECOND, b.backup_start_date, b.backup_finish_date) > 0
								AND b.backup_finish_date > @StartTime
								GROUP BY b.database_name
										) ca_full
							OUTER APPLY (
								SELECT b.database_name,
									   AVG( b.compressed_backup_size / ( DATEDIFF(ss, b.backup_start_date, b.backup_finish_date) ) / 1048576.0 ) AS AvgDiffSpeed,
									   AVG( DATEDIFF(ss, b.backup_start_date, b.backup_finish_date) ) AS AvgDiffDuration
								FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset b
								WHERE r.DatabaseName = b.database_name
								AND r.DatabaseGUID = b.database_guid
								AND b.type = ''I''
								AND DATEDIFF(SECOND, b.backup_start_date, b.backup_finish_date) > 0
								AND b.backup_finish_date > @StartTime
								GROUP BY b.database_name
										) ca_diff
							OUTER APPLY (
								SELECT b.database_name,
									   AVG( b.compressed_backup_size / ( DATEDIFF(ss, b.backup_start_date, b.backup_finish_date) ) / 1048576.0 ) AS AvgLogSpeed,
									   AVG( DATEDIFF(ss, b.backup_start_date, b.backup_finish_date) ) AS AvgLogDuration
								FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset b
								WHERE r.DatabaseName = b.database_name
								AND r.DatabaseGUID = b.database_guid
								AND b.type = ''L''
								AND DATEDIFF(SECOND, b.backup_start_date, b.backup_finish_date) > 0
								AND b.backup_finish_date > @StartTime
								GROUP BY b.database_name
										) ca_log;'

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute, N'@StartTime DATETIME2', @starttime;


            /*Find max and avg diff and log sizes*/
            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							UPDATE r
							 SET r.AvgFullSizeMB = fulls.avg_full_size,
							 	 r.AvgDiffSizeMB = diffs.avg_diff_size,
							 	 r.AvgLogSizeMB = logs.avg_log_size
							 FROM #Recoverability AS r
							 OUTER APPLY (
							 	SELECT b.database_name, AVG(b.compressed_backup_size / 1048576.0) AS avg_full_size
							 	FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
							 	WHERE r.DatabaseName = b.database_name
								AND r.DatabaseGUID = b.database_guid
							 	AND b.type = ''D''
								AND b.backup_finish_date > @StartTime
							 	GROUP BY b.database_name
							 			) AS fulls
							 OUTER APPLY (
							 	SELECT b.database_name, AVG(b.compressed_backup_size / 1048576.0) AS avg_diff_size
							 	FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
							 	WHERE r.DatabaseName = b.database_name
								AND r.DatabaseGUID = b.database_guid
							 	AND b.type = ''I''
								AND b.backup_finish_date > @StartTime
							 	GROUP BY b.database_name
							 			) AS diffs
							 OUTER APPLY (
							 	SELECT b.database_name, AVG(b.compressed_backup_size / 1048576.0) AS avg_log_size
							 	FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
							 	WHERE r.DatabaseName = b.database_name
								AND r.DatabaseGUID = b.database_guid
							 	AND b.type = ''L''
								AND b.backup_finish_date > @StartTime
							 	GROUP BY b.database_name
							 			) AS logs;'

            if @debug = 1
                print @stringtoexecute;

            exec sys.sp_executesql @stringtoexecute, N'@StartTime DATETIME2', @starttime;

/*Trending - only works if backupfile is populated, which means in msdb */
            if @msdbname = N'msdb'
                begin
                    set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' --+ @crlf;

                    set @stringtoexecute += N'
							SELECT  p.DatabaseName,
									p.DatabaseGUID,
									p.[0],
									p.[-1],
									p.[-2],
									p.[-3],
									p.[-4],
									p.[-5],
									p.[-6],
									p.[-7],
									p.[-8],
									p.[-9],
									p.[-10],
									p.[-11],
									p.[-12]
								FROM ( SELECT b.database_name AS DatabaseName,
											  b.database_guid AS DatabaseGUID,
											  DATEDIFF(MONTH, @StartTime, b.backup_start_date) AS MonthsAgo ,
											  CONVERT(DECIMAL(18, 2), AVG(bf.file_size / 1048576.0)) AS AvgSizeMB
										FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
										INNER JOIN ' + QUOTENAME(@msdbname) + N'.dbo.backupfile AS bf
										ON b.backup_set_id = bf.backup_set_id
										WHERE b.database_name NOT IN ( ''master'', ''msdb'', ''model'', ''tempdb'' )
										AND bf.file_type = ''D''
										AND b.backup_start_date >= DATEADD(YEAR, -1, @StartTime)
										AND b.backup_start_date <= SYSDATETIME()
										GROUP BY b.database_name,
												 b.database_guid,
												 DATEDIFF(mm, @StartTime, b.backup_start_date)
									 ) AS bckstat PIVOT ( SUM(bckstat.AvgSizeMB) FOR bckstat.MonthsAgo IN ( [0], [-1], [-2], [-3], [-4], [-5], [-6], [-7], [-8], [-9], [-10], [-11], [-12] ) ) AS p
								ORDER BY p.DatabaseName;
								'

                    if @debug = 1
                        print @stringtoexecute;

                    insert #trending (databasename, databaseguid, [0], [-1], [-2], [-3], [-4], [-5], [-6], [-7], [-8],
                                      [-9], [-10], [-11], [-12])
                        exec sys.sp_executesql @stringtoexecute, N'@StartTime DATETIME2', @starttime;

                end

            /*End Trending*/

/*End populating Recoverability*/

            raiserror ('Returning data', 0, 1) with nowait;

            select b.*
            from #backups as b
            order by b.database_name;

            select r.*,
                   t.[0],
                   t.[-1],
                   t.[-2],
                   t.[-3],
                   t.[-4],
                   t.[-5],
                   t.[-6],
                   t.[-7],
                   t.[-8],
                   t.[-9],
                   t.[-10],
                   t.[-11],
                   t.[-12]
            from #recoverability as r
                     left join #trending t
                               on r.databasename = t.databasename
                                   and r.databaseguid = t.databaseguid
            where r.lastbackuprecoverymodel is not null
            order by r.databasename


            raiserror ('Rules analysis starting', 0, 1) with nowait;

/*Looking for out of band backups by finding most common backup operator user_name and noting backups taken by other user_names*/

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
							WITH common_people AS (
									SELECT TOP 1 b.user_name, COUNT_BIG(*) AS Records
									FROM ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
									GROUP BY b.user_name
									ORDER BY Records DESC
													)
								SELECT
								1 AS CheckId,
								100 AS [Priority],
								b.database_name AS [Database Name],
								''Non-Agent backups taken'' AS [Finding],
								''The database '' + QUOTENAME(b.database_name) + '' has been backed up by '' + QUOTENAME(b.user_name) + '' '' + CONVERT(VARCHAR(10), COUNT(*)) + '' times.'' AS [Warning]
							FROM   ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
							WHERE  b.user_name NOT LIKE ''%Agent%'' AND b.user_name NOT LIKE ''%AGENT%''
							AND NOT EXISTS (
											SELECT 1
											FROM common_people AS cp
											WHERE cp.user_name = b.user_name
											)
							GROUP BY b.database_name, b.user_name
							HAVING COUNT(*) > 1;' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            insert #warnings (checkid, priority, databasename, finding, warning)
                exec sys.sp_executesql @stringtoexecute;

            /*Looking for compatibility level changing. Only looking for databases that have changed more than twice (It''s possible someone may have changed up, had CE problems, and then changed back)*/

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'SELECT
								2 AS CheckId,
								100 AS [Priority],
								b.database_name AS [Database Name],
								''Compatibility level changing'' AS [Finding],
								''The database '' + QUOTENAME(b.database_name) + '' has changed compatibility levels '' + CONVERT(VARCHAR(10), COUNT(DISTINCT b.compatibility_level)) + '' times.'' AS [Warning]
							FROM   ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
							GROUP BY b.database_name
							HAVING COUNT(DISTINCT b.compatibility_level) > 2;' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            insert #warnings (checkid, priority, databasename, finding, warning)
                exec sys.sp_executesql @stringtoexecute;

            /*Looking for password protected backups. This hasn''t been a popular option ever, and was largely replaced by encrypted backups, but it''s simple to check for.*/

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'SELECT
								3 AS CheckId,
								100 AS [Priority],
								b.database_name AS [Database Name],
								''Password backups'' AS [Finding],
								''The database '' + QUOTENAME(b.database_name) + '' has been backed up with a password '' + CONVERT(VARCHAR(10), COUNT(*)) + '' times. Who has the password?'' AS [Warning]
							FROM   ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
							WHERE b.is_password_protected = 1
							GROUP BY b.database_name;' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            insert #warnings (checkid, priority, databasename, finding, warning)
                exec sys.sp_executesql @stringtoexecute;

            /*Looking for snapshot backups. There are legit reasons for these, but we should flag them so the questions get asked. What questions? Good question.*/

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'SELECT
								4 AS CheckId,
								100 AS [Priority],
								b.database_name AS [Database Name],
								''Snapshot backups'' AS [Finding],
								''The database '' + QUOTENAME(b.database_name) + '' has had '' + CONVERT(VARCHAR(10), COUNT(*)) + '' snapshot backups. This message is purely informational.'' AS [Warning]
							FROM   ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
							WHERE b.is_snapshot = 1
							GROUP BY b.database_name;' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            insert #warnings (checkid, priority, databasename, finding, warning)
                exec sys.sp_executesql @stringtoexecute;

            /*It''s fine to take backups of read only databases, but it''s not always necessary (there''s no new data, after all).*/

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'SELECT
								5 AS CheckId,
								100 AS [Priority],
								b.database_name AS [Database Name],
								''Read only state backups'' AS [Finding],
								''The database '' + QUOTENAME(b.database_name) + '' has been backed up '' + CONVERT(VARCHAR(10), COUNT(*)) + '' times while in a read-only state. This can be normal if it''''s a secondary, but a bit odd otherwise.'' AS [Warning]
							FROM   ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
							WHERE b.is_readonly = 1
							GROUP BY b.database_name;' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            insert #warnings (checkid, priority, databasename, finding, warning)
                exec sys.sp_executesql @stringtoexecute;

            /*So, I''ve come across people who think they need to change their database to single user mode to take a backup. Or that doing that will help something. I just need to know, here.*/

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'SELECT
								6 AS CheckId,
								100 AS [Priority],
								b.database_name AS [Database Name],
								''Single user mode backups'' AS [Finding],
								''The database '' + QUOTENAME(b.database_name) + '' has been backed up '' + CONVERT(VARCHAR(10), COUNT(*)) + '' times while in single-user mode. This is really weird! Make sure your backup process doesn''''t include a mode change anywhere.'' AS [Warning]
							FROM   ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
							WHERE b.is_single_user = 1
							GROUP BY b.database_name;' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            insert #warnings (checkid, priority, databasename, finding, warning)
                exec sys.sp_executesql @stringtoexecute;

            /*C''mon, it''s 2017. Take your backups with CHECKSUMS, people.*/

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'SELECT
								7 AS CheckId,
								100 AS [Priority],
								b.database_name AS [Database Name],
								''No CHECKSUMS'' AS [Finding],
								''The database '' + QUOTENAME(b.database_name) + '' has been backed up '' + CONVERT(VARCHAR(10), COUNT(*)) + '' times without CHECKSUMS in the past 30 days. CHECKSUMS can help alert you to corruption errors.'' AS [Warning]
							FROM   ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
							WHERE b.has_backup_checksums = 0
							AND b.backup_finish_date >= DATEADD(DAY, -30, SYSDATETIME())
							GROUP BY b.database_name;' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            insert #warnings (checkid, priority, databasename, finding, warning)
                exec sys.sp_executesql @stringtoexecute;

            /*Damaged is a Black Flag album. You don''t want your backups to be like a Black Flag album. */

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'SELECT
								8 AS CheckId,
								100 AS [Priority],
								b.database_name AS [Database Name],
								''Damaged backups'' AS [Finding],
								''The database '' + QUOTENAME(b.database_name) + '' has had '' + CONVERT(VARCHAR(10), COUNT(*)) + '' damaged backups taken without stopping to throw an error. This is done by specifying CONTINUE_AFTER_ERROR in your BACKUP commands.'' AS [Warning]
							FROM   ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
							WHERE b.is_damaged = 1
							GROUP BY b.database_name;' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            insert #warnings (checkid, priority, databasename, finding, warning)
                exec sys.sp_executesql @stringtoexecute;

            /*Checking for encrypted backups and the last backup of the encryption key.*/

            /*2014 ONLY*/

            if @productversionmajor >= 12
                begin

                    set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

                    set @stringtoexecute += N'SELECT
								9 AS CheckId,
								100 AS [Priority],
								b.database_name AS [Database Name],
								''Encrypted backups'' AS [Finding],
								''The database '' + QUOTENAME(b.database_name) + '' has had '' + CONVERT(VARCHAR(10), COUNT(*)) + '' '' + b.encryptor_type + '' backups, and the last time a certificate was backed up is '
                        + case
                              when LOWER(@msdbname) <> N'msdb'
                                  then + N'...well, that information is on another server, anyway.'' AS [Warning]'
                              else + CONVERT(varchar(30), (select MAX(c.pvt_key_last_backup_date)
                                                           from sys.certificates as c
                                                           where c.name not like '##%')) + N'.'' AS [Warning]'
                                                end +
                                            N'
							FROM   ' + QUOTENAME(@msdbname) + N'.dbo.backupset AS b
							WHERE b.encryptor_type IS NOT NULL
							GROUP BY b.database_name, b.encryptor_type;' + @crlf;

                    if @debug = 1
                        print @stringtoexecute;

                    insert #warnings (checkid, priority, databasename, finding, warning)
                        exec sys.sp_executesql @stringtoexecute;

                end

            /*Looking for backups that have BULK LOGGED data in them -- this can screw up point in time LOG recovery.*/

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'SELECT
		10 AS CheckId,
		100 AS [Priority],
		b.database_name AS [Database Name],
		''Bulk logged backups'' AS [Finding],
		''The database '' + QUOTENAME(b.database_name) + '' has had '' + CONVERT(VARCHAR(10), COUNT(*)) + '' backups with bulk logged data. This can make point in time recovery awkward. '' AS [Warning]
	FROM   ' + QUOTENAME(@msdbname) + '.dbo.backupset AS b
	WHERE b.has_bulk_logged_data = 1
	GROUP BY b.database_name;' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            insert #warnings (checkid, priority, databasename, finding, warning)
                exec sys.sp_executesql @stringtoexecute;

            /*Looking for recovery model being switched between FULL and SIMPLE, because it''s a bad practice.*/

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'SELECT
		11 AS CheckId,
		100 AS [Priority],
		b.database_name AS [Database Name],
		''Recovery model switched'' AS [Finding],
		''The database '' + QUOTENAME(b.database_name) + '' has changed recovery models from between FULL and SIMPLE '' + CONVERT(VARCHAR(10), COUNT(DISTINCT b.recovery_model)) + '' times. This breaks the log chain and is generally a bad idea.'' AS [Warning]
	FROM   ' + QUOTENAME(@msdbname) + '.dbo.backupset AS b
	WHERE b.recovery_model <> ''BULK-LOGGED''
	GROUP BY b.database_name
	HAVING COUNT(DISTINCT b.recovery_model) > 4;' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            insert #warnings (checkid, priority, databasename, finding, warning)
                exec sys.sp_executesql @stringtoexecute;

            /*Looking for uncompressed backups.*/

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'SELECT
		12 AS CheckId,
		100 AS [Priority],
		b.database_name AS [Database Name],
		''Uncompressed backups'' AS [Finding],
		''The database '' + QUOTENAME(b.database_name) + '' has had '' + CONVERT(VARCHAR(10), COUNT(*)) + '' uncompressed backups in the last 30 days. This is a free way to save time and space. And SPACETIME. If your version of SQL supports it.'' AS [Warning]
	FROM   ' + QUOTENAME(@msdbname) + '.dbo.backupset AS b
	WHERE backup_size = compressed_backup_size AND type = ''D''
	AND b.backup_finish_date >= DATEADD(DAY, -30, SYSDATETIME())
	GROUP BY b.database_name;' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            insert #warnings (checkid, priority, databasename, finding, warning)
                exec sys.sp_executesql @stringtoexecute;

            raiserror ('Rules analysis starting on temp tables', 0, 1) with nowait;

            insert #warnings (checkid, priority, databasename, finding, warning)
            select 13                                                                                                     as checkid,
                   100                                                                                                    as priority,
                   r.databasename                                                                                         as [DatabaseName],
                   'Big Diffs'                                                                                            as [Finding],
                   'On average, Differential backups for this database are >=40% of the size of the average Full backup.' as [Warning]
            from #recoverability as r
            where r.isbigdiff = 1

            insert #warnings (checkid, priority, databasename, finding, warning)
            select 13                                                                                            as checkid,
                   100                                                                                           as priority,
                   r.databasename                                                                                as [DatabaseName],
                   'Big Logs'                                                                                    as [Finding],
                   'On average, Log backups for this database are >=20% of the size of the average Full backup.' as [Warning]
            from #recoverability as r
            where r.isbiglog = 1


/*Insert thank you stuff last*/
            insert #warnings (checkid, priority, databasename, finding, warning)

            select 2147483647                                                                                                                                 as [CheckId],
                   2147483647                                                                                                                                 as [Priority],
                   'From Your Community Volunteers'                                                                                                           as [DatabaseName],
                   'sp_BlitzBackups Version: ' + @version + ', Version Date: ' + CONVERT(varchar(30), @versiondate) +
                   '.'                                                                                                                                        as [Finding],
                   'Thanks for using our stored procedure. We hope you find it useful! Check out our other free SQL Server scripts at firstresponderkit.org!' as [Warning];

            raiserror ('Rules analysis finished', 0, 1) with nowait;

            select w.checkid, w.priority, w.databasename, w.finding, w.warning
            from #warnings as w
            order by w.priority, w.checkid;

            drop table #backups, #warnings, #recoverability, #rtorecoverypoints


            return;

            pushbackuphistorytolistener:

            raiserror ('Pushing backup history to listener', 0, 1) with nowait;

            declare @msg nvarchar(4000) = N'';
            declare @remotecheck table
                                 (
                                     c int null
                                 );


            if @writebackupstodatabasename is null
                begin
                    raiserror ('@WriteBackupsToDatabaseName can''t be NULL.', 16, 1) with nowait
                    return;
                end

            if LOWER(@writebackupstodatabasename) = N'msdb'
                begin
                    raiserror ('We can''t write to the real msdb, we have to write to a fake msdb.', 16, 1) with nowait
                    return;
                end

            if @writebackupstolistenername is null
                begin
                    if @agname is null
                        begin
                            raiserror ('@WriteBackupsToListenerName and @AGName can''t both be NULL.', 16, 1) with nowait;
                            return;
                        end
                    else
                        begin
                            select @writebackupstolistenername = dns_name
                            from sys.availability_groups as ag
                                     join sys.availability_group_listeners as agl
                                          on ag.group_id = agl.group_id
                            where name = @agname;
                        end

                end

            if @writebackupstolistenername is not null
                begin
                    if not EXISTS
                        (
                            select *
                            from sys.servers s
                            where name = @writebackupstolistenername
                        )
                        begin
                            set @msg = N'We need a linked server to write data across. Please set one up for ' +
                                       @writebackupstolistenername + N'.';
                            raiserror (@msg, 16, 1) with nowait;
                            return;
                        end
                end

            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'SELECT TOP 1 1 FROM '
                + QUOTENAME(@writebackupstolistenername) +
                                    N'.master.sys.databases d WHERE d.name = @i_WriteBackupsToDatabaseName;'

            if @debug = 1
                print @stringtoexecute;

            insert @remotecheck (c)
                exec sp_executesql @stringtoexecute, N'@i_WriteBackupsToDatabaseName NVARCHAR(256)',
                     @i_writebackupstodatabasename = @writebackupstodatabasename;

            if @@ROWCOUNT = 0
                begin
                    set @msg = N'The database ' + @writebackupstodatabasename +
                               N' doesn''t appear to exist on that server.'
                    raiserror (@msg, 16, 1) with nowait
                    return;
                end


            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'SELECT TOP 1 1 FROM '
                + QUOTENAME(@writebackupstolistenername) + '.' + QUOTENAME(@writebackupstodatabasename) + '.sys.tables WHERE name = ''backupset'' AND SCHEMA_NAME(schema_id) = ''dbo'';
							' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            insert @remotecheck (c)
                exec sp_executesql @stringtoexecute;

            if @@ROWCOUNT = 0
                begin

                    set @msg = N'The database ' + @writebackupstodatabasename +
                               N' doesn''t appear to have a table called dbo.backupset in it.'
                    raiserror (@msg, 0, 1) with nowait
                    raiserror ('Don''t worry, we''ll create it for you!', 0, 1) with nowait

                    set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

                    set @stringtoexecute += N'CREATE TABLE ' + QUOTENAME(@writebackupstodatabasename) + N'.dbo.backupset
											( backup_set_id INT IDENTITY(1, 1), backup_set_uuid UNIQUEIDENTIFIER, media_set_id INT, first_family_number TINYINT, first_media_number SMALLINT,
											  last_family_number TINYINT, last_media_number SMALLINT, catalog_family_number TINYINT, catalog_media_number SMALLINT, position INT, expiration_date DATETIME,
											  software_vendor_id INT, name NVARCHAR(128), description NVARCHAR(255), user_name NVARCHAR(128), software_major_version TINYINT, software_minor_version TINYINT,
											  software_build_version SMALLINT, time_zone SMALLINT, mtf_minor_version TINYINT, first_lsn NUMERIC(25, 0), last_lsn NUMERIC(25, 0), checkpoint_lsn NUMERIC(25, 0),
											  database_backup_lsn NUMERIC(25, 0), database_creation_date DATETIME, backup_start_date DATETIME, backup_finish_date DATETIME, type CHAR(1), sort_order SMALLINT,
											  code_page SMALLINT, compatibility_level TINYINT, database_version INT, backup_size NUMERIC(20, 0), database_name NVARCHAR(128), server_name NVARCHAR(128),
											  machine_name NVARCHAR(128), flags INT, unicode_locale INT, unicode_compare_style INT, collation_name NVARCHAR(128), is_password_protected BIT, recovery_model NVARCHAR(60),
											  has_bulk_logged_data BIT, is_snapshot BIT, is_readonly BIT, is_single_user BIT, has_backup_checksums BIT, is_damaged BIT, begins_log_chain BIT, has_incomplete_metadata BIT,
											  is_force_offline BIT, is_copy_only BIT, first_recovery_fork_guid UNIQUEIDENTIFIER, last_recovery_fork_guid UNIQUEIDENTIFIER, fork_point_lsn NUMERIC(25, 0), database_guid UNIQUEIDENTIFIER,
											  family_guid UNIQUEIDENTIFIER, differential_base_lsn NUMERIC(25, 0), differential_base_guid UNIQUEIDENTIFIER, compressed_backup_size NUMERIC(20, 0), key_algorithm NVARCHAR(32),
											  encryptor_thumbprint VARBINARY(20) , encryptor_type NVARCHAR(32)
											);
								 ' + @crlf;

                    set @innerstringtoexecute =
                                N'EXEC( ''' + @stringtoexecute + ''' ) AT ' + QUOTENAME(@writebackupstolistenername) +
                                N';'

                    if @debug = 1
                        print @innerstringtoexecute;

                    exec sp_executesql @innerstringtoexecute


                    raiserror ('We''ll even make the indexes!', 0, 1) with nowait

                    /*Checking for and creating the PK/CX*/

                    set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

                    set @stringtoexecute += N'

		IF NOT EXISTS (
		SELECT t.name, i.name
		FROM ' + QUOTENAME(@writebackupstodatabasename) + N'.sys.tables AS t
		JOIN ' + QUOTENAME(@writebackupstodatabasename) + N'.sys.indexes AS i
		ON t.object_id = i.object_id
		WHERE t.name = ?
		AND i.name LIKE ?
		)

		BEGIN
		ALTER TABLE ' + QUOTENAME(@writebackupstodatabasename) + N'.[dbo].[backupset] ADD PRIMARY KEY CLUSTERED ([backup_set_id] ASC)
		END
		'

                    set @innerstringtoexecute =
                                N'EXEC( ''' + @stringtoexecute + ''', ''backupset'', ''PK[_][_]%'' ) AT ' +
                                QUOTENAME(@writebackupstolistenername) + N';'

                    if @debug = 1
                        print @innerstringtoexecute;

                    exec sp_executesql @innerstringtoexecute


                    /*Checking for and creating index on backup_set_uuid*/

                    set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

                    set @stringtoexecute += N'IF NOT EXISTS (
		SELECT t.name, i.name
		FROM ' + QUOTENAME(@writebackupstodatabasename) + N'.sys.tables AS t
		JOIN ' + QUOTENAME(@writebackupstodatabasename) + N'.sys.indexes AS i
		ON t.object_id = i.object_id
		WHERE t.name = ?
		AND i.name = ?
		)

		BEGIN
		CREATE NONCLUSTERED INDEX [backupsetuuid] ON ' + QUOTENAME(@writebackupstodatabasename) + N'.[dbo].[backupset] ([backup_set_uuid] ASC)
		END
		'

                    set @innerstringtoexecute =
                                N'EXEC( ''' + @stringtoexecute + ''', ''backupset'', ''backupsetuuid'' ) AT ' +
                                QUOTENAME(@writebackupstolistenername) + N';'

                    if @debug = 1
                        print @innerstringtoexecute;

                    exec sp_executesql @innerstringtoexecute


                    /*Checking for and creating index on media_set_id*/

                    set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

                    set @stringtoexecute += 'IF NOT EXISTS (
		SELECT t.name, i.name
		FROM ' + QUOTENAME(@writebackupstodatabasename) + N'.sys.tables AS t
		JOIN ' + QUOTENAME(@writebackupstodatabasename) + N'.sys.indexes AS i
		ON t.object_id = i.object_id
		WHERE t.name = ?
		AND i.name = ?
		)

		BEGIN
		CREATE NONCLUSTERED INDEX [backupsetMediaSetId] ON ' + QUOTENAME(@writebackupstodatabasename) + N'.[dbo].[backupset] ([media_set_id] ASC)
		END
		'

                    set @innerstringtoexecute =
                                N'EXEC( ''' + @stringtoexecute + ''', ''backupset'', ''backupsetMediaSetId'' ) AT ' +
                                QUOTENAME(@writebackupstolistenername) + N';'

                    if @debug = 1
                        print @innerstringtoexecute;

                    exec sp_executesql @innerstringtoexecute


                    /*Checking for and creating index on backup_finish_date*/

                    set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

                    set @stringtoexecute += N'IF NOT EXISTS (
		SELECT t.name, i.name
		FROM ' + QUOTENAME(@writebackupstodatabasename) + N'.sys.tables AS t
		JOIN ' + QUOTENAME(@writebackupstodatabasename) + N'.sys.indexes AS i
		ON t.object_id = i.object_id
		WHERE t.name = ?
		AND i.name = ?
		)

		BEGIN
		CREATE NONCLUSTERED INDEX [backupsetDate] ON ' + QUOTENAME(@writebackupstodatabasename) + N'.[dbo].[backupset] ([backup_finish_date] ASC)
		END
		'

                    set @innerstringtoexecute =
                                N'EXEC( ''' + @stringtoexecute + ''', ''backupset'', ''backupsetDate'' ) AT ' +
                                QUOTENAME(@writebackupstolistenername) + N';'

                    if @debug = 1
                        print @innerstringtoexecute;

                    exec sp_executesql @innerstringtoexecute


                    /*Checking for and creating index on database_name*/

                    set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

                    set @stringtoexecute += N'IF NOT EXISTS (
		SELECT t.name, i.name
		FROM ' + QUOTENAME(@writebackupstodatabasename) + N'.sys.tables AS t
		JOIN ' + QUOTENAME(@writebackupstodatabasename) + N'.sys.indexes AS i
		ON t.object_id = i.object_id
		WHERE t.name = ?
		AND i.name = ?
		)

		BEGIN
		CREATE NONCLUSTERED INDEX [backupsetDatabaseName] ON ' + QUOTENAME(@writebackupstodatabasename) + N'.[dbo].[backupset] ([database_name] ASC ) INCLUDE ([backup_set_id], [media_set_id])
		END

		'

                    set @innerstringtoexecute =
                                N'EXEC( ''' + @stringtoexecute + ''', ''backupset'', ''backupsetDatabaseName'' ) AT ' +
                                QUOTENAME(@writebackupstolistenername) + N';'

                    if @debug = 1
                        print @innerstringtoexecute;

                    exec sp_executesql @innerstringtoexecute

                    raiserror ('Table and indexes created! You''re welcome!', 0, 1) with nowait
                end


            raiserror ('Beginning inserts', 0, 1) with nowait;
            raiserror (@crlf, 0, 1) with nowait;

            /*
		Batching code comes from the lovely and talented Michael J. Swart
		http://michaeljswart.com/2014/09/take-care-when-scripting-batches/
		If you're ever in Canada, he says you can stay at his house, too.
		*/


            set @stringtoexecute = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;' + @crlf;

            set @stringtoexecute += N'
									DECLARE
										@StartDate DATETIME = DATEADD(HOUR, @i_WriteBackupsLastHours, SYSDATETIME()),
										@StartDateNext DATETIME,
										@RC INT = 1,
										@msg NVARCHAR(4000) = N'''';

									SELECT @StartDate = MIN(b.backup_start_date)
									FROM msdb.dbo.backupset b
									WHERE b.backup_start_date >= @StartDate
									AND  NOT EXISTS (
													SELECT 1
													FROM ' + QUOTENAME(@writebackupstolistenername) + N'.' +
                                    QUOTENAME(@writebackupstodatabasename) + N'.dbo.backupset b2
													WHERE b.backup_set_uuid = b2.backup_set_uuid
													AND b2.backup_start_date >= @StartDate
													)

									SET @StartDateNext = DATEADD(MINUTE, 10, @StartDate);

								 IF
									( @StartDate IS NULL )
										BEGIN
											SET @msg = N''No data to move, exiting.''
											RAISERROR(@msg, 0, 1) WITH NOWAIT

											RETURN;
										END

									RAISERROR(''Starting insert loop'', 0, 1) WITH NOWAIT;

									WHILE EXISTS (
												SELECT 1
												FROM msdb.dbo.backupset b
												WHERE NOT EXISTS (
													SELECT 1
													FROM ' + QUOTENAME(@writebackupstolistenername) + N'.' +
                                    QUOTENAME(@writebackupstodatabasename) + N'.dbo.backupset b2
													WHERE b.backup_set_uuid = b2.backup_set_uuid
													AND b2.backup_start_date >= @StartDate
																)
												)
									BEGIN

									SET @msg = N''Inserting data for '' + CONVERT(NVARCHAR(30), @StartDate) + '' through '' +  + CONVERT(NVARCHAR(30), @StartDateNext) + ''.''
									RAISERROR(@msg, 0, 1) WITH NOWAIT

										'

            set @stringtoexecute += N'INSERT ' + QUOTENAME(@writebackupstolistenername) + N'.' +
                                    QUOTENAME(@writebackupstodatabasename) + N'.dbo.backupset
									'
            set @stringtoexecute += N' (database_name, database_guid, backup_set_uuid, type, backup_size, backup_start_date, backup_finish_date, media_set_id, time_zone,
									compressed_backup_size, recovery_model, server_name, machine_name, first_lsn, last_lsn, user_name, compatibility_level,
									is_password_protected, is_snapshot, is_readonly, is_single_user, has_backup_checksums, is_damaged, ' +
                                    case
                                        when @productversionmajor >= 12
                                            then + N'encryptor_type, has_bulk_logged_data)' + @crlf
                                        else + N'has_bulk_logged_data)' + @crlf
                                        end

            set @stringtoexecute +=N'
									SELECT database_name, database_guid, backup_set_uuid, type, backup_size, backup_start_date, backup_finish_date, media_set_id, time_zone,
									compressed_backup_size, recovery_model, server_name, machine_name, first_lsn, last_lsn, user_name, compatibility_level,
									is_password_protected, is_snapshot, is_readonly, is_single_user, has_backup_checksums, is_damaged, ' +
                                   case
                                       when @productversionmajor >= 12
                                           then + N'encryptor_type, has_bulk_logged_data' + @crlf
                                       else + N'has_bulk_logged_data' + @crlf
                                       end
            set @stringtoexecute +=N'
								 FROM msdb.dbo.backupset b
								 WHERE 1=1
								 AND b.backup_start_date >= @StartDate
								 AND b.backup_start_date < @StartDateNext
								 AND NOT EXISTS (
										SELECT 1
										FROM ' + QUOTENAME(@writebackupstolistenername) + N'.' +
                                   QUOTENAME(@writebackupstodatabasename) + N'.dbo.backupset b2
										WHERE b.backup_set_uuid = b2.backup_set_uuid
										AND b2.backup_start_date >= @StartDate
													)' + @crlf;


            set @stringtoexecute +=N'
								 SET @RC = @@ROWCOUNT;

								SET @msg = N''Inserted '' + CONVERT(NVARCHAR(30), @RC) + '' rows for ''+ CONVERT(NVARCHAR(30), @StartDate) + '' through '' + CONVERT(NVARCHAR(30), @StartDateNext) + ''.''
								RAISERROR(@msg, 0, 1) WITH NOWAIT

								 SET @StartDate = @StartDateNext;
								 SET @StartDateNext = DATEADD(MINUTE, 10, @StartDate);

								 IF
									( @StartDate > SYSDATETIME() )
										BEGIN

											SET @msg = N''No more data to move, exiting.''
											RAISERROR(@msg, 0, 1) WITH NOWAIT

											BREAK;

										END
								 END' + @crlf;

            if @debug = 1
                print @stringtoexecute;

            exec sp_executesql @stringtoexecute, N'@i_WriteBackupsLastHours INT',
                 @i_writebackupslasthours = @writebackupslasthours;

        end;

end;

go
set ansi_nulls on;
set ansi_padding on;
set ansi_warnings on;
set arithabort on;
set concat_null_yields_null on;
set quoted_identifier on;
set statistics io off;
set statistics time off;
go

if (
       select case
                  when CONVERT(nvarchar(128), SERVERPROPERTY('PRODUCTVERSION')) like '8%' then 0
                  when CONVERT(nvarchar(128), SERVERPROPERTY('PRODUCTVERSION')) like '9%' then 0
                  else 1
                  end
   ) = 0
    begin
        declare @msg varchar(8000);
        select @msg =
               'Sorry, sp_BlitzCache doesn''t work on versions of SQL prior to 2008.' + REPLICATE(CHAR(13), 7933);
        print @msg;
        return;
    end;

if OBJECT_ID('dbo.sp_BlitzCache') is null
    exec ('CREATE PROCEDURE dbo.sp_BlitzCache AS RETURN 0;');
go

if OBJECT_ID('dbo.sp_BlitzCache') is not null and OBJECT_ID('tempdb.dbo.##BlitzCacheProcs', 'U') is not null
    exec ('DROP TABLE ##BlitzCacheProcs;');
go

if OBJECT_ID('dbo.sp_BlitzCache') is not null and OBJECT_ID('tempdb.dbo.##BlitzCacheResults', 'U') is not null
    exec ('DROP TABLE ##BlitzCacheResults;');
go

create table ##blitzcacheresults
(
    spid int,
    id int identity (1,1),
    checkid int,
    priority tinyint,
    findingsgroup varchar(50),
    finding varchar(500),
    url varchar(200),
    details varchar(4000)
);

create table ##blitzcacheprocs
(
    spid int,
    querytype nvarchar(258),
    databasename sysname,
    averagecpu decimal(38, 4),
    averagecpuperminute decimal(38, 4),
    totalcpu decimal(38, 4),
    percentcpubytype money,
    percentcpu money,
    averageduration decimal(38, 4),
    totalduration decimal(38, 4),
    percentduration money,
    percentdurationbytype money,
    averagereads bigint,
    totalreads bigint,
    percentreads money,
    percentreadsbytype money,
    executioncount bigint,
    percentexecutions money,
    percentexecutionsbytype money,
    executionsperminute money,
    totalwrites bigint,
    averagewrites money,
    percentwrites money,
    percentwritesbytype money,
    writesperminute money,
    plancreationtime datetime,
    plancreationtimehours as DATEDIFF(hour, plancreationtime, SYSDATETIME()),
    lastexecutiontime datetime,
    lastcompletiontime datetime,
    planhandle varbinary(64),
    [Remove Plan Handle From Cache] as
        case
            when [PlanHandle] is not null
                then 'DBCC FREEPROCCACHE (' + CONVERT(varchar(128), [PlanHandle], 1) + ');'
            else 'N/A' end,
    sqlhandle varbinary(64),
    [Remove SQL Handle From Cache] as
        case
            when [SqlHandle] is not null
                then 'DBCC FREEPROCCACHE (' + CONVERT(varchar(128), [SqlHandle], 1) + ');'
            else 'N/A' end,
    [SQL Handle More Info] as
        case
            when [SqlHandle] is not null
                then 'EXEC sp_BlitzCache @OnlySqlHandles = ''' + CONVERT(varchar(128), [SqlHandle], 1) + '''; '
            else 'N/A' end,
    queryhash binary(8),
    [Query Hash More Info] as
        case
            when [QueryHash] is not null
                then 'EXEC sp_BlitzCache @OnlyQueryHashes = ''' + CONVERT(varchar(32), [QueryHash], 1) + '''; '
            else 'N/A' end,
    queryplanhash binary(8),
    statementstartoffset int,
    statementendoffset int,
    minreturnedrows bigint,
    maxreturnedrows bigint,
    averagereturnedrows money,
    totalreturnedrows bigint,
    lastreturnedrows bigint,
    /*The Memory Grant columns are only supported
		  in certain versions, giggle giggle.
		*/
    mingrantkb bigint,
    maxgrantkb bigint,
    minusedgrantkb bigint,
    maxusedgrantkb bigint,
    percentmemorygrantused money,
    avgmaxmemorygrant money,
    minspills bigint,
    maxspills bigint,
    totalspills bigint,
    avgspills money,
    querytext nvarchar(max),
    queryplan xml,
    /* these next four columns are the total for the type of query.
            don't actually use them for anything apart from math by type.
            */
    totalworkertimefortype bigint,
    totalelapsedtimefortype bigint,
    totalreadsfortype bigint,
    totalexecutioncountfortype bigint,
    totalwritesfortype bigint,
    numberofplans int,
    numberofdistinctplans int,
    serialdesiredmemory float,
    serialrequiredmemory float,
    cachedplansize float,
    compiletime float,
    compilecpu float,
    compilememory float,
    maxcompilememory float,
    min_worker_time bigint,
    max_worker_time bigint,
    is_forced_plan bit,
    is_forced_parameterized bit,
    is_cursor bit,
    is_optimistic_cursor bit,
    is_forward_only_cursor bit,
    is_fast_forward_cursor bit,
    is_cursor_dynamic bit,
    is_parallel bit,
    is_forced_serial bit,
    is_key_lookup_expensive bit,
    key_lookup_cost float,
    is_remote_query_expensive bit,
    remote_query_cost float,
    frequent_execution bit,
    parameter_sniffing bit,
    unparameterized_query bit,
    near_parallel bit,
    plan_warnings bit,
    plan_multiple_plans int,
    long_running bit,
    downlevel_estimator bit,
    implicit_conversions bit,
    busy_loops bit,
    tvf_join bit,
    tvf_estimate bit,
    compile_timeout bit,
    compile_memory_limit_exceeded bit,
    warning_no_join_predicate bit,
    queryplancost float,
    missing_index_count int,
    unmatched_index_count int,
    min_elapsed_time bigint,
    max_elapsed_time bigint,
    age_minutes money,
    age_minutes_lifetime money,
    is_trivial bit,
    trace_flags_session varchar(1000),
    is_unused_grant bit,
    function_count int,
    clr_function_count int,
    is_table_variable bit,
    no_stats_warning bit,
    relop_warnings bit,
    is_table_scan bit,
    backwards_scan bit,
    forced_index bit,
    forced_seek bit,
    forced_scan bit,
    columnstore_row_mode bit,
    is_computed_scalar bit,
    is_sort_expensive bit,
    sort_cost float,
    is_computed_filter bit,
    op_name varchar(100) null,
    index_insert_count int null,
    index_update_count int null,
    index_delete_count int null,
    cx_insert_count int null,
    cx_update_count int null,
    cx_delete_count int null,
    table_insert_count int null,
    table_update_count int null,
    table_delete_count int null,
    index_ops as (index_insert_count + index_update_count + index_delete_count +
                  cx_insert_count + cx_update_count + cx_delete_count +
                  table_insert_count + table_update_count + table_delete_count),
    is_row_level bit,
    is_spatial bit,
    index_dml bit,
    table_dml bit,
    long_running_low_cpu bit,
    low_cost_high_cpu bit,
    stale_stats bit,
    is_adaptive bit,
    index_spool_cost float,
    index_spool_rows float,
    table_spool_cost float,
    table_spool_rows float,
    is_spool_expensive bit,
    is_spool_more_rows bit,
    is_table_spool_expensive bit,
    is_table_spool_more_rows bit,
    estimated_rows float,
    is_bad_estimate bit,
    is_paul_white_electric bit,
    is_row_goal bit,
    is_big_spills bit,
    is_mstvf bit,
    is_mm_join bit,
    is_nonsargable bit,
    select_with_writes bit,
    implicit_conversion_info xml,
    cached_execution_parameters xml,
    missing_indexes xml,
    setoptions varchar(max),
    warnings varchar(max)
);
go

alter procedure dbo.sp_blitzcache @help bit = 0,
                                  @top int = null,
                                  @sortorder varchar(50) = 'CPU',
                                  @usetriggersanyway bit = null,
                                  @exporttoexcel bit = 0,
                                  @expertmode tinyint = 0,
                                  @outputservername nvarchar(258) = null,
                                  @outputdatabasename nvarchar(258) = null,
                                  @outputschemaname nvarchar(258) = null,
                                  @outputtablename nvarchar(258) = null,
                                  @configurationdatabasename nvarchar(128) = null,
                                  @configurationschemaname nvarchar(258) = null,
                                  @configurationtablename nvarchar(258) = null,
                                  @durationfilter decimal(38, 4) = null,
                                  @hidesummary bit = 0,
                                  @ignoresystemdbs bit = 1,
                                  @onlyqueryhashes varchar(max) = null,
                                  @ignorequeryhashes varchar(max) = null,
                                  @onlysqlhandles varchar(max) = null,
                                  @ignoresqlhandles varchar(max) = null,
                                  @queryfilter varchar(10) = 'ALL',
                                  @databasename nvarchar(128) = null,
                                  @storedprocname nvarchar(128) = null,
                                  @slowlysearchplansfor nvarchar(4000) = null,
                                  @reanalyze bit = 0,
                                  @skipanalysis bit = 0,
                                  @bringthepain bit = 0,
                                  @minimumexecutioncount int = 0,
                                  @debug bit = 0,
                                  @checkdateoverride datetimeoffset = null,
                                  @minutesback int = null,
                                  @version varchar(30) = null output,
                                  @versiondate datetime = null output,
                                  @versioncheckmode bit = 0
    with recompile
as
begin
    set nocount on;
    set transaction isolation level read uncommitted;

    select @version = '7.97', @versiondate = '20200712';


    if (@versioncheckmode = 1)
        begin
            return;
        end;

    if @help = 1
        print '
sp_BlitzCache from http://FirstResponderKit.org

This script displays your most resource-intensive queries from the plan cache,
and points to ways you can tune these queries to make them faster.


To learn more, visit http://FirstResponderKit.org where you can download new
versions for free, watch training videos on how it works, get more info on
the findings, contribute your own code, and more.

Known limitations of this version:
 - This query will not run on SQL Server 2005.
 - SQL Server 2008 and 2008R2 have a bug in trigger stats, so that output is
   excluded by default.
 - @IgnoreQueryHashes and @OnlyQueryHashes require a CSV list of hashes
   with no spaces between the hash values.
 - @OutputServerName is not functional yet.

Unknown limitations of this version:
 - May or may not be vulnerable to the wick effect.

Changes - for the full list of improvements and fixes in this version, see:
https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/



MIT License

Copyright (c) 2020 Brent Ozar Unlimited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
';

    declare @nl nvarchar(2) = NCHAR(13) + NCHAR(10);

    if @help = 1
        begin
            select N'@Help'                       as [Parameter Name],
                   N'BIT'                         as [Data Type],
                   N'Displays this help message.' as [Parameter Description]

            union all
            select N'@Top',
                   N'INT',
                   N'The number of records to retrieve and analyze from the plan cache. The following DMVs are used as the plan cache: dm_exec_query_stats, dm_exec_procedure_stats, dm_exec_trigger_stats.'

            union all
            select N'@SortOrder',
                   N'VARCHAR(10)',
                   N'Data processing and display order. @SortOrder will still be used, even when preparing output for a table or for excel. Possible values are: "CPU", "Reads", "Writes", "Duration", "Executions", "Recent Compilations", "Memory Grant", "Spills", "Query Hash". Additionally, the word "Average" or "Avg" can be used to sort on averages rather than total. "Executions per minute" and "Executions / minute" can be used to sort by execution per minute. For the truly lazy, "xpm" can also be used. Note that when you use all or all avg, the only parameters you can use are @Top and @DatabaseName. All others will be ignored.'

            union all
            select N'@UseTriggersAnyway',
                   N'BIT',
                   N'On SQL Server 2008R2 and earlier, trigger execution count is incorrect - trigger execution count is incremented once per execution of a SQL agent job. If you still want to see relative execution count of triggers, then you can force sp_BlitzCache to include this information.'

            union all
            select N'@ExportToExcel',
                   N'BIT',
                   N'Prepare output for exporting to Excel. Newlines and additional whitespace are removed from query text and the execution plan is not displayed.'

            union all
            select N'@ExpertMode',
                   N'TINYINT',
                   N'Default 0. When set to 1, results include more columns. When 2, mode is optimized for Opserver, the open source dashboard.'

            union all
            select N'@OutputDatabaseName',
                   N'NVARCHAR(128)',
                   N'The output database. If this does not exist SQL Server will divide by zero and everything will fall apart.'

            union all
            select N'@OutputSchemaName',
                   N'NVARCHAR(258)',
                   N'The output schema. If this does not exist SQL Server will divide by zero and everything will fall apart.'

            union all
            select N'@OutputTableName',
                   N'NVARCHAR(258)',
                   N'The output table. If this does not exist, it will be created for you.'

            union all
            select N'@DurationFilter',
                   N'DECIMAL(38,4)',
                   N'Excludes queries with an average duration (in seconds) less than @DurationFilter.'

            union all
            select N'@HideSummary',
                   N'BIT',
                   N'Hides the findings summary result set.'

            union all
            select N'@IgnoreSystemDBs',
                   N'BIT',
                   N'Ignores plans found in the system databases (master, model, msdb, tempdb, and resourcedb)'

            union all
            select N'@OnlyQueryHashes',
                   N'VARCHAR(MAX)',
                   N'A list of query hashes to query. All other query hashes will be ignored. Stored procedures and triggers will be ignored.'

            union all
            select N'@IgnoreQueryHashes',
                   N'VARCHAR(MAX)',
                   N'A list of query hashes to ignore.'

            union all
            select N'@OnlySqlHandles',
                   N'VARCHAR(MAX)',
                   N'One or more sql_handles to use for filtering results.'

            union all
            select N'@IgnoreSqlHandles',
                   N'VARCHAR(MAX)',
                   N'One or more sql_handles to ignore.'

            union all
            select N'@DatabaseName',
                   N'NVARCHAR(128)',
                   N'A database name which is used for filtering results.'

            union all
            select N'@StoredProcName',
                   N'NVARCHAR(128)',
                   N'Name of stored procedure you want to find plans for.'

            union all
            select N'@SlowlySearchPlansFor',
                   N'NVARCHAR(4000)',
                   N'String to search for in plan text. % wildcards allowed.'

            union all
            select N'@BringThePain',
                   N'BIT',
                   N'When using @SortOrder = ''all'' and @Top > 10, we require you to set @BringThePain = 1 so you understand that sp_BlitzCache will take a while to run.'

            union all
            select N'@QueryFilter',
                   N'VARCHAR(10)',
                   N'Filter out stored procedures or statements. The default value is ''ALL''. Allowed values are ''procedures'', ''statements'', ''functions'', or ''all'' (any variation in capitalization is acceptable).'

            union all
            select N'@Reanalyze',
                   N'BIT',
                   N'The default is 0. When set to 0, sp_BlitzCache will re-evalute the plan cache. Set this to 1 to reanalyze existing results'

            union all
            select N'@MinimumExecutionCount',
                   N'INT',
                   N'Queries with fewer than this number of executions will be omitted from results.'

            union all
            select N'@Debug',
                   N'BIT',
                   N'Setting this to 1 will print dynamic SQL and select data from all tables used.'

            union all
            select N'@MinutesBack',
                   N'INT',
                   N'How many minutes back to begin plan cache analysis. If you put in a positive number, we''ll flip it to negtive.';


            /* Column definitions */
            select N'# Executions'                                                                                                                                      as [Column Name],
                   N'BIGINT'                                                                                                                                            as [Data Type],
                   N'The number of executions of this particular query. This is computed across statements, procedures, and triggers and aggregated by the SQL handle.' as [Column Description]

            union all
            select N'Executions / Minute',
                   N'MONEY',
                   N'Number of executions per minute - calculated for the life of the current plan. Plan life is the last execution time minus the plan creation time.'

            union all
            select N'Execution Weight',
                   N'MONEY',
                   N'An arbitrary metric of total "execution-ness". A weight of 2 is "one more" than a weight of 1.'

            union all
            select N'Database',
                   N'sysname',
                   N'The name of the database where the plan was encountered. If the database name cannot be determined for some reason, a value of NA will be substituted. A value of 32767 indicates the plan comes from ResourceDB.'

            union all
            select N'Total CPU',
                   N'BIGINT',
                   N'Total CPU time, reported in milliseconds, that was consumed by all executions of this query since the last compilation.'

            union all
            select N'Avg CPU',
                   N'BIGINT',
                   N'Average CPU time, reported in milliseconds, consumed by each execution of this query since the last compilation.'

            union all
            select N'CPU Weight',
                   N'MONEY',
                   N'An arbitrary metric of total "CPU-ness". A weight of 2 is "one more" than a weight of 1.'

            union all
            select N'Total Duration',
                   N'BIGINT',
                   N'Total elapsed time, reported in milliseconds, consumed by all executions of this query since last compilation.'

            union all
            select N'Avg Duration',
                   N'BIGINT',
                   N'Average elapsed time, reported in milliseconds, consumed by each execution of this query since the last compilation.'

            union all
            select N'Duration Weight',
                   N'MONEY',
                   N'An arbitrary metric of total "Duration-ness". A weight of 2 is "one more" than a weight of 1.'

            union all
            select N'Total Reads',
                   N'BIGINT',
                   N'Total logical reads performed by this query since last compilation.'

            union all
            select N'Average Reads',
                   N'BIGINT',
                   N'Average logical reads performed by each execution of this query since the last compilation.'

            union all
            select N'Read Weight',
                   N'MONEY',
                   N'An arbitrary metric of "Read-ness". A weight of 2 is "one more" than a weight of 1.'

            union all
            select N'Total Writes',
                   N'BIGINT',
                   N'Total logical writes performed by this query since last compilation.'

            union all
            select N'Average Writes',
                   N'BIGINT',
                   N'Average logical writes performed by each execution this query since last compilation.'

            union all
            select N'Write Weight',
                   N'MONEY',
                   N'An arbitrary metric of "Write-ness". A weight of 2 is "one more" than a weight of 1.'

            union all
            select N'Query Type',
                   N'NVARCHAR(258)',
                   N'The type of query being examined. This can be "Procedure", "Statement", or "Trigger".'

            union all
            select N'Query Text',
                   N'NVARCHAR(4000)',
                   N'The text of the query. This may be truncated by either SQL Server or by sp_BlitzCache(tm) for display purposes.'

            union all
            select N'% Executions (Type)',
                   N'MONEY',
                   N'Percent of executions relative to the type of query - e.g. 17.2% of all stored procedure executions.'

            union all
            select N'% CPU (Type)',
                   N'MONEY',
                   N'Percent of CPU time consumed by this query for a given type of query - e.g. 22% of CPU of all stored procedures executed.'

            union all
            select N'% Duration (Type)',
                   N'MONEY',
                   N'Percent of elapsed time consumed by this query for a given type of query - e.g. 12% of all statements executed.'

            union all
            select N'% Reads (Type)',
                   N'MONEY',
                   N'Percent of reads consumed by this query for a given type of query - e.g. 34.2% of all stored procedures executed.'

            union all
            select N'% Writes (Type)',
                   N'MONEY',
                   N'Percent of writes performed by this query for a given type of query - e.g. 43.2% of all statements executed.'

            union all
            select N'Total Rows',
                   N'BIGINT',
                   N'Total number of rows returned for all executions of this query. This only applies to query level stats, not stored procedures or triggers.'

            union all
            select N'Average Rows',
                   N'MONEY',
                   N'Average number of rows returned by each execution of the query.'

            union all
            select N'Min Rows',
                   N'BIGINT',
                   N'The minimum number of rows returned by any execution of this query.'

            union all
            select N'Max Rows',
                   N'BIGINT',
                   N'The maximum number of rows returned by any execution of this query.'

            union all
            select N'MinGrantKB',
                   N'BIGINT',
                   N'The minimum memory grant the query received in kb.'

            union all
            select N'MaxGrantKB',
                   N'BIGINT',
                   N'The maximum memory grant the query received in kb.'

            union all
            select N'MinUsedGrantKB',
                   N'BIGINT',
                   N'The minimum used memory grant the query received in kb.'

            union all
            select N'MaxUsedGrantKB',
                   N'BIGINT',
                   N'The maximum used memory grant the query received in kb.'

            union all
            select N'MinSpills',
                   N'BIGINT',
                   N'The minimum amount this query has spilled to tempdb in 8k pages.'

            union all
            select N'MaxSpills',
                   N'BIGINT',
                   N'The maximum amount this query has spilled to tempdb in 8k pages.'

            union all
            select N'TotalSpills',
                   N'BIGINT',
                   N'The total amount this query has spilled to tempdb in 8k pages.'

            union all
            select N'AvgSpills',
                   N'BIGINT',
                   N'The average amount this query has spilled to tempdb in 8k pages.'

            union all
            select N'PercentMemoryGrantUsed',
                   N'MONEY',
                   N'Result of dividing the maximum grant used by the minimum granted.'

            union all
            select N'AvgMaxMemoryGrant',
                   N'MONEY',
                   N'The average maximum memory grant for a query.'

            union all
            select N'# Plans',
                   N'INT',
                   N'The total number of execution plans found that match a given query.'

            union all
            select N'# Distinct Plans',
                   N'INT',
                   N'The number of distinct execution plans that match a given query. '
                       + NCHAR(13) + NCHAR(10)
                       +
                   N'This may be caused by running the same query across multiple databases or because of a lack of proper parameterization in the database.'

            union all
            select N'Created At',
                   N'DATETIME',
                   N'Time that the execution plan was last compiled.'

            union all
            select N'Last Execution',
                   N'DATETIME',
                   N'The last time that this query was executed.'

            union all
            select N'Query Plan',
                   N'XML',
                   N'The query plan. Click to display a graphical plan or, if you need to patch SSMS, a pile of XML.'

            union all
            select N'Plan Handle',
                   N'VARBINARY(64)',
                   N'An arbitrary identifier referring to the compiled plan this query is a part of.'

            union all
            select N'SQL Handle',
                   N'VARBINARY(64)',
                   N'An arbitrary identifier referring to a batch or stored procedure that this query is a part of.'

            union all
            select N'Query Hash',
                   N'BINARY(8)',
                   N'A hash of the query. Queries with the same query hash have similar logic but only differ by literal values or database.'

            union all
            select N'Warnings',
                   N'VARCHAR(MAX)',
                   N'A list of individual warnings generated by this query.';


            /* Configuration table description */
            select N'Frequent Execution Threshold'                                                      as [Configuration Parameter],
                   N'100'                                                                               as [Default Value],
                   N'Executions / Minute'                                                               as [Unit of Measure],
                   N'Executions / Minute before a "Frequent Execution Threshold" warning is triggered.' as [Description]

            union all
            select N'Parameter Sniffing Variance Percent',
                   N'30',
                   N'Percent',
                   N'Variance required between min/max values and average values before a "Parameter Sniffing" warning is triggered. Applies to worker time and returned rows.'

            union all
            select N'Parameter Sniffing IO Threshold',
                   N'100,000',
                   N'Logical reads',
                   N'Minimum number of average logical reads before parameter sniffing checks are evaluated.'

            union all
            select N'Cost Threshold for Parallelism Warning' as [Configuration Parameter],
                   N'10',
                   N'Percent',
                   N'Trigger a "Nearly Parallel" warning when a query''s cost is within X percent of the cost threshold for parallelism.'

            union all
            select N'Long Running Query Warning' as [Configuration Parameter],
                   N'300',
                   N'Seconds',
                   N'Triggers a "Long Running Query Warning" when average duration, max CPU time, or max clock time is higher than this number.'

            union all
            select N'Unused Memory Grant Warning' as [Configuration Parameter],
                   N'10',
                   N'Percent',
                   N'Triggers an "Unused Memory Grant Warning" when a query uses >= X percent of its memory grant.';
            return;
        end;

/*Validate version*/
    if (
           select case
                      when CONVERT(nvarchar(128), SERVERPROPERTY('PRODUCTVERSION')) like '8%' then 0
                      when CONVERT(nvarchar(128), SERVERPROPERTY('PRODUCTVERSION')) like '9%' then 0
                      else 1
                      end
       ) = 0
        begin
            declare @version_msg varchar(8000);
            select @version_msg =
                   'Sorry, sp_BlitzCache doesn''t work on versions of SQL prior to 2008.' + REPLICATE(CHAR(13), 7933);
            print @version_msg;
            return;
        end;

/* If they want to sort by query hash, populate the @OnlyQueryHashes list for them */
    if @sortorder like 'query hash%'
        begin
            raiserror ('Beginning query hash sort', 0, 1) with nowait;

            select qs.query_hash,
                   MAX(qs.max_worker_time) as max_worker_time,
                   COUNT_BIG(*)            as records
            into #query_hash_grouped
            from sys.dm_exec_query_stats as qs
                     cross apply (select pa.value
                                  from sys.dm_exec_plan_attributes(qs.plan_handle) as pa
                                  where pa.attribute = 'dbid') as ca
            group by qs.query_hash, ca.value
            having COUNT_BIG(*) > 1
            order by max_worker_time desc,
                     records desc;

            select top (1) @onlyqueryhashes = STUFF((select distinct N',' + CONVERT(nvarchar(max), qhg.query_hash, 1)
                                                     from #query_hash_grouped as qhg
                                                     where qhg.query_hash <> 0x00
                                                     for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 1,
                                                    N'')
            option (recompile);

            /* When they ran it, @SortOrder probably looked like 'query hash, cpu', so strip the first sort order out: */
            select @sortorder = LTRIM(REPLACE(REPLACE(@sortorder, 'query hash', ''), ',', ''));

            /* If they just called it with @SortOrder = 'query hash', set it to 'cpu' for backwards compatibility: */
            if @sortorder = '' set @sortorder = 'cpu';

        end


/* Set @Top based on sort */
    if (
            @top is null
            and LOWER(@sortorder) in ('all', 'all sort')
        )
        begin
            set @top = 5;
        end;

    if (
            @top is null
            and LOWER(@sortorder) not in ('all', 'all sort')
        )
        begin
            set @top = 10;
        end;

/* validate user inputs */
    if @top is null
        or @sortorder is null
        or @queryfilter is null
        or @reanalyze is null
        begin
            raiserror (N'Several parameters (@Top, @SortOrder, @QueryFilter, @renalyze) are required. Do not set them to NULL. Please try again.', 16, 1) with nowait;
            return;
        end;

    raiserror (N'Checking @MinutesBack validity.', 0, 1) with nowait;
    if @minutesback is not null
        begin
            if @minutesback > 0
                begin
                    raiserror (N'Setting @MinutesBack to a negative number', 0, 1) with nowait;
                    set @minutesback *= -1;
                end;
            if @minutesback = 0
                begin
                    raiserror (N'@MinutesBack can''t be 0, setting to -1', 0, 1) with nowait;
                    set @minutesback = -1;
                end;
        end;


    raiserror (N'Creating temp tables for results and warnings.', 0, 1) with nowait;


    if OBJECT_ID('tempdb.dbo.##BlitzCacheResults') is null
        begin
            create table ##blitzcacheresults
            (
                spid int,
                id int identity (1,1),
                checkid int,
                priority tinyint,
                findingsgroup varchar(50),
                finding varchar(500),
                url varchar(200),
                details varchar(4000)
            );
        end;

    if OBJECT_ID('tempdb.dbo.##BlitzCacheProcs') is null
        begin
            create table ##blitzcacheprocs
            (
                spid int,
                querytype nvarchar(258),
                databasename sysname,
                averagecpu decimal(38, 4),
                averagecpuperminute decimal(38, 4),
                totalcpu decimal(38, 4),
                percentcpubytype money,
                percentcpu money,
                averageduration decimal(38, 4),
                totalduration decimal(38, 4),
                percentduration money,
                percentdurationbytype money,
                averagereads bigint,
                totalreads bigint,
                percentreads money,
                percentreadsbytype money,
                executioncount bigint,
                percentexecutions money,
                percentexecutionsbytype money,
                executionsperminute money,
                totalwrites bigint,
                averagewrites money,
                percentwrites money,
                percentwritesbytype money,
                writesperminute money,
                plancreationtime datetime,
                plancreationtimehours as DATEDIFF(hour, plancreationtime, SYSDATETIME()),
                lastexecutiontime datetime,
                lastcompletiontime datetime,
                planhandle varbinary(64),
                [Remove Plan Handle From Cache] as
                    case
                        when [PlanHandle] is not null
                            then 'DBCC FREEPROCCACHE (' + CONVERT(varchar(128), [PlanHandle], 1) + ');'
                        else 'N/A' end,
                sqlhandle varbinary(64),
                [Remove SQL Handle From Cache] as
                    case
                        when [SqlHandle] is not null
                            then 'DBCC FREEPROCCACHE (' + CONVERT(varchar(128), [SqlHandle], 1) + ');'
                        else 'N/A' end,
                [SQL Handle More Info] as
                    case
                        when [SqlHandle] is not null
                            then 'EXEC sp_BlitzCache @OnlySqlHandles = ''' + CONVERT(varchar(128), [SqlHandle], 1) +
                                 '''; '
                        else 'N/A' end,
                queryhash binary(8),
                [Query Hash More Info] as
                    case
                        when [QueryHash] is not null
                            then 'EXEC sp_BlitzCache @OnlyQueryHashes = ''' + CONVERT(varchar(32), [QueryHash], 1) +
                                 '''; '
                        else 'N/A' end,
                queryplanhash binary(8),
                statementstartoffset int,
                statementendoffset int,
                minreturnedrows bigint,
                maxreturnedrows bigint,
                averagereturnedrows money,
                totalreturnedrows bigint,
                lastreturnedrows bigint,
                mingrantkb bigint,
                maxgrantkb bigint,
                minusedgrantkb bigint,
                maxusedgrantkb bigint,
                percentmemorygrantused money,
                avgmaxmemorygrant money,
                minspills bigint,
                maxspills bigint,
                totalspills bigint,
                avgspills money,
                querytext nvarchar(max),
                queryplan xml,
                /* these next four columns are the total for the type of query.
            don't actually use them for anything apart from math by type.
            */
                totalworkertimefortype bigint,
                totalelapsedtimefortype bigint,
                totalreadsfortype bigint,
                totalexecutioncountfortype bigint,
                totalwritesfortype bigint,
                numberofplans int,
                numberofdistinctplans int,
                serialdesiredmemory float,
                serialrequiredmemory float,
                cachedplansize float,
                compiletime float,
                compilecpu float,
                compilememory float,
                maxcompilememory float,
                min_worker_time bigint,
                max_worker_time bigint,
                is_forced_plan bit,
                is_forced_parameterized bit,
                is_cursor bit,
                is_optimistic_cursor bit,
                is_forward_only_cursor bit,
                is_fast_forward_cursor bit,
                is_cursor_dynamic bit,
                is_parallel bit,
                is_forced_serial bit,
                is_key_lookup_expensive bit,
                key_lookup_cost float,
                is_remote_query_expensive bit,
                remote_query_cost float,
                frequent_execution bit,
                parameter_sniffing bit,
                unparameterized_query bit,
                near_parallel bit,
                plan_warnings bit,
                plan_multiple_plans int,
                long_running bit,
                downlevel_estimator bit,
                implicit_conversions bit,
                busy_loops bit,
                tvf_join bit,
                tvf_estimate bit,
                compile_timeout bit,
                compile_memory_limit_exceeded bit,
                warning_no_join_predicate bit,
                queryplancost float,
                missing_index_count int,
                unmatched_index_count int,
                min_elapsed_time bigint,
                max_elapsed_time bigint,
                age_minutes money,
                age_minutes_lifetime money,
                is_trivial bit,
                trace_flags_session varchar(1000),
                is_unused_grant bit,
                function_count int,
                clr_function_count int,
                is_table_variable bit,
                no_stats_warning bit,
                relop_warnings bit,
                is_table_scan bit,
                backwards_scan bit,
                forced_index bit,
                forced_seek bit,
                forced_scan bit,
                columnstore_row_mode bit,
                is_computed_scalar bit,
                is_sort_expensive bit,
                sort_cost float,
                is_computed_filter bit,
                op_name varchar(100) null,
                index_insert_count int null,
                index_update_count int null,
                index_delete_count int null,
                cx_insert_count int null,
                cx_update_count int null,
                cx_delete_count int null,
                table_insert_count int null,
                table_update_count int null,
                table_delete_count int null,
                index_ops as (index_insert_count + index_update_count + index_delete_count +
                              cx_insert_count + cx_update_count + cx_delete_count +
                              table_insert_count + table_update_count + table_delete_count),
                is_row_level bit,
                is_spatial bit,
                index_dml bit,
                table_dml bit,
                long_running_low_cpu bit,
                low_cost_high_cpu bit,
                stale_stats bit,
                is_adaptive bit,
                index_spool_cost float,
                index_spool_rows float,
                table_spool_cost float,
                table_spool_rows float,
                is_spool_expensive bit,
                is_spool_more_rows bit,
                is_table_spool_expensive bit,
                is_table_spool_more_rows bit,
                estimated_rows float,
                is_bad_estimate bit,
                is_paul_white_electric bit,
                is_row_goal bit,
                is_big_spills bit,
                is_mstvf bit,
                is_mm_join bit,
                is_nonsargable bit,
                select_with_writes bit,
                implicit_conversion_info xml,
                cached_execution_parameters xml,
                missing_indexes xml,
                setoptions varchar(max),
                warnings varchar(max)
            );
        end;

    declare @durationfilter_i int,
        @minmemoryperquery int,
        @msg nvarchar(4000),
        @noobsaibot bit = 0,
        @versionshowsairquoteactualplans bit,
        @objectfullname nvarchar(2000),
        @user_perm_sql nvarchar(max) = N'',
        @user_perm_gb_out decimal(10, 2),
        @common_version decimal(10, 2),
        @buffer_pool_memory_gb decimal(10, 2),
        @user_perm_percent decimal(10, 2),
        @is_tokenstore_big bit = 0;


    if @sortorder = 'sp_BlitzIndex'
        begin
            raiserror (N'OUTSTANDING!', 0, 1) with nowait;
            set @sortorder = 'reads';
            set @noobsaibot = 1;

        end


/* Change duration from seconds to milliseconds */
    if @durationfilter is not null
        begin
            raiserror (N'Converting Duration Filter to milliseconds', 0, 1) with nowait;
            set @durationfilter_i = CAST((@durationfilter * 1000.0) as int);
        end;

    raiserror (N'Checking database validity', 0, 1) with nowait;
    set @databasename = LTRIM(RTRIM(@databasename));

    if SERVERPROPERTY('EngineEdition') in (5, 6) and DB_NAME() <> @databasename
        begin
            raiserror ('You specified a database name other than the current database, but Azure SQL DB does not allow you to change databases. Execute sp_BlitzCache from the database you want to analyze.', 16, 1);
            return;
        end;
    if (DB_ID(@databasename)) is null and @databasename <> N''
        begin
            raiserror ('The database you specified does not exist. Please check the name and try again.', 16, 1);
            return;
        end;
    if (select DATABASEPROPERTYEX(ISNULL(@databasename, 'master'), 'Collation')) is null and
       SERVERPROPERTY('EngineEdition') not in (5, 6, 8)
        begin
            raiserror ('The database you specified is not readable. Please check the name and try again. Better yet, check your server.', 16, 1);
            return;
        end;

    select @minmemoryperquery = CONVERT(int, c.value)
    from sys.configurations as c
    where c.name = 'min memory per query (KB)';

    set @sortorder = LOWER(@sortorder);
    set @sortorder = REPLACE(REPLACE(@sortorder, 'average', 'avg'), '.', '');

    set @sortorder = case
                         when @sortorder in ('executions per minute', 'execution per minute', 'executions / minute',
                                             'execution / minute', 'xpm') then 'avg executions'
                         when @sortorder in ('recent compilations', 'recent compilation', 'compile') then 'compiles'
                         when @sortorder in ('read') then 'reads'
                         when @sortorder in ('avg read') then 'avg reads'
                         when @sortorder in ('write') then 'writes'
                         when @sortorder in ('avg write') then 'avg writes'
                         when @sortorder in ('memory grants') then 'memory grant'
                         when @sortorder in ('avg memory grants') then 'avg memory grant'
                         when @sortorder in ('spill') then 'spills'
                         when @sortorder in ('avg spill') then 'avg spills'
                         when @sortorder in ('execution') then 'executions'
                         else @sortorder end

    raiserror (N'Checking sort order', 0, 1) with nowait;
    if @sortorder not in ('cpu', 'avg cpu', 'reads', 'avg reads', 'writes', 'avg writes',
                          'duration', 'avg duration', 'executions', 'avg executions',
                          'compiles', 'memory grant', 'avg memory grant',
                          'spills', 'avg spills', 'all', 'all avg', 'sp_BlitzIndex',
                          'query hash')
        begin
            raiserror (N'Invalid sort order chosen, reverting to cpu', 16, 1) with nowait;
            set @sortorder = 'cpu';
        end;

    set @queryfilter = LOWER(@queryfilter);

    if LEFT(@queryfilter, 3) not in ('all', 'sta', 'pro', 'fun')
        begin
            raiserror (N'Invalid query filter chosen. Reverting to all.', 0, 1) with nowait;
            set @queryfilter = 'all';
        end;

    if @skipanalysis = 1
        begin
            raiserror (N'Skip Analysis set to 1, hiding Summary', 0, 1) with nowait;
            set @hidesummary = 1;
        end;

    declare @allsortsql nvarchar(max) = N'';
    declare @versionshowsmemorygrants bit;
    if EXISTS(select *
              from sys.all_columns
              where object_id = OBJECT_ID('sys.dm_exec_query_stats') and name = 'max_grant_kb')
        set @versionshowsmemorygrants = 1;
    else
        set @versionshowsmemorygrants = 0;

    declare @versionshowsspills bit;
    if EXISTS(select *
              from sys.all_columns
              where object_id = OBJECT_ID('sys.dm_exec_query_stats') and name = 'max_spills')
        set @versionshowsspills = 1;
    else
        set @versionshowsspills = 0;

    if EXISTS(select *
              from sys.all_columns
              where object_id = OBJECT_ID('sys.dm_exec_query_plan_stats') and name = 'query_plan')
        set @versionshowsairquoteactualplans = 1;
    else
        set @versionshowsairquoteactualplans = 0;

    if @reanalyze = 1 and OBJECT_ID('tempdb..##BlitzCacheResults') is null
        begin
            raiserror (N'##BlitzCacheResults does not exist, can''t reanalyze', 0, 1) with nowait;
            set @reanalyze = 0;
        end;

    if @reanalyze = 0
        begin
            raiserror (N'Cleaning up old warnings for your SPID', 0, 1) with nowait;
            delete ##blitzcacheresults
            where spid = @@SPID
            option (recompile);
            raiserror (N'Cleaning up old plans for your SPID', 0, 1) with nowait;
            delete ##blitzcacheprocs
            where spid = @@SPID
            option (recompile);
        end;

    if @reanalyze = 1
        begin
            raiserror (N'Reanalyzing current data, skipping to results', 0, 1) with nowait;
            goto results;
        end;


    if @sortorder in ('all', 'all avg')
        begin
            raiserror (N'Checking all sort orders, please be patient', 0, 1) with nowait;
            goto allsorts;
        end;

    raiserror (N'Creating temp tables for internal processing', 0, 1) with nowait;
    if OBJECT_ID('tempdb..#only_query_hashes') is not null
        drop table #only_query_hashes ;

    if OBJECT_ID('tempdb..#ignore_query_hashes') is not null
        drop table #ignore_query_hashes ;

    if OBJECT_ID('tempdb..#only_sql_handles') is not null
        drop table #only_sql_handles ;

    if OBJECT_ID('tempdb..#ignore_sql_handles') is not null
        drop table #ignore_sql_handles ;

    if OBJECT_ID('tempdb..#p') is not null
        drop table #p;

    if OBJECT_ID('tempdb..#checkversion') is not null
        drop table #checkversion;

    if OBJECT_ID('tempdb..#configuration') is not null
        drop table #configuration;

    if OBJECT_ID('tempdb..#stored_proc_info') is not null
        drop table #stored_proc_info;

    if OBJECT_ID('tempdb..#plan_creation') is not null
        drop table #plan_creation;

    if OBJECT_ID('tempdb..#est_rows') is not null
        drop table #est_rows;

    if OBJECT_ID('tempdb..#plan_cost') is not null
        drop table #plan_cost;

    if OBJECT_ID('tempdb..#proc_costs') is not null
        drop table #proc_costs;

    if OBJECT_ID('tempdb..#stats_agg') is not null
        drop table #stats_agg;

    if OBJECT_ID('tempdb..#trace_flags') is not null
        drop table #trace_flags;

    if OBJECT_ID('tempdb..#variable_info') is not null
        drop table #variable_info;

    if OBJECT_ID('tempdb..#conversion_info') is not null
        drop table #conversion_info;

    if OBJECT_ID('tempdb..#missing_index_xml') is not null
        drop table #missing_index_xml;

    if OBJECT_ID('tempdb..#missing_index_schema') is not null
        drop table #missing_index_schema;

    if OBJECT_ID('tempdb..#missing_index_usage') is not null
        drop table #missing_index_usage;

    if OBJECT_ID('tempdb..#missing_index_detail') is not null
        drop table #missing_index_detail;

    if OBJECT_ID('tempdb..#missing_index_pretty') is not null
        drop table #missing_index_pretty;

    if OBJECT_ID('tempdb..#index_spool_ugly') is not null
        drop table #index_spool_ugly;

    if OBJECT_ID('tempdb..#ReadableDBs') is not null
        drop table #readabledbs;

    if OBJECT_ID('tempdb..#plan_usage') is not null
        drop table #plan_usage;

    create table #only_query_hashes
    (
        query_hash binary(8)
    );

    create table #ignore_query_hashes
    (
        query_hash binary(8)
    );

    create table #only_sql_handles
    (
        sql_handle varbinary(64)
    );

    create table #ignore_sql_handles
    (
        sql_handle varbinary(64)
    );

    create table #p
    (
        sqlhandle varbinary(64),
        totalcpu bigint,
        totalduration bigint,
        totalreads bigint,
        totalwrites bigint,
        executioncount bigint
    );

    create table #checkversion
    (
        version nvarchar(128),
        common_version as SUBSTRING(version, 1, CHARINDEX('.', version) + 1),
        major as PARSENAME(CONVERT(varchar(32), version), 4),
        minor as PARSENAME(CONVERT(varchar(32), version), 3),
        build as PARSENAME(CONVERT(varchar(32), version), 2),
        revision as PARSENAME(CONVERT(varchar(32), version), 1)
    );

    create table #configuration
    (
        parameter_name varchar(100),
        value decimal(38, 0)
    );

    create table #plan_creation
    (
        percent_24 decimal(5, 2),
        percent_4 decimal(5, 2),
        percent_1 decimal(5, 2),
        total_plans int,
        spid int
    );

    create table #est_rows
    (
        queryhash binary(8),
        estimated_rows float
    );

    create table #plan_cost
    (
        queryplancost float,
        sqlhandle varbinary(64),
        planhandle varbinary(64),
        queryhash binary(8),
        queryplanhash binary(8)
    );

    create table #proc_costs
    (
        plantotalquery float,
        planhandle varbinary(64),
        sqlhandle varbinary(64)
    );

    create table #stats_agg
    (
        sqlhandle varbinary(64),
        lastupdate datetime2(7),
        modificationcount bigint,
        samplingpercent float,
        [Statistics] nvarchar(258),
        [Table] nvarchar(258),
        [Schema] nvarchar(258),
        [Database] nvarchar(258),
    );

    create table #trace_flags
    (
        sqlhandle varbinary(64),
        queryhash binary(8),
        global_trace_flags varchar(1000),
        session_trace_flags varchar(1000)
    );

    create table #stored_proc_info
    (
        spid int,
        sqlhandle varbinary(64),
        queryhash binary(8),
        variable_name nvarchar(258),
        variable_datatype nvarchar(258),
        converted_column_name nvarchar(258),
        compile_time_value nvarchar(258),
        proc_name nvarchar(1000),
        column_name nvarchar(4000),
        converted_to nvarchar(258),
        set_options nvarchar(1000)
    );

    create table #variable_info
    (
        spid int,
        queryhash binary(8),
        sqlhandle varbinary(64),
        proc_name nvarchar(1000),
        variable_name nvarchar(258),
        variable_datatype nvarchar(258),
        compile_time_value nvarchar(258)
    );

    create table #conversion_info
    (
        spid int,
        queryhash binary(8),
        sqlhandle varbinary(64),
        proc_name nvarchar(258),
        expression nvarchar(4000),
        at_charindex as CHARINDEX('@', expression),
        bracket_charindex as CHARINDEX(']', expression, CHARINDEX('@', expression)) - CHARINDEX('@', expression),
        comma_charindex as CHARINDEX(',', expression) + 1,
        second_comma_charindex as
                CHARINDEX(',', expression, CHARINDEX(',', expression) + 1) - CHARINDEX(',', expression) - 1,
        equal_charindex as CHARINDEX('=', expression) + 1,
        paren_charindex as CHARINDEX('(', expression) + 1,
        comma_paren_charindex as
                CHARINDEX(',', expression, CHARINDEX('(', expression) + 1) - CHARINDEX('(', expression) - 1,
        convert_implicit_charindex as CHARINDEX('=CONVERT_IMPLICIT', expression)
    );


    create table #missing_index_xml
    (
        queryhash binary(8),
        sqlhandle varbinary(64),
        impact float,
        index_xml xml
    );


    create table #missing_index_schema
    (
        queryhash binary(8),
        sqlhandle varbinary(64),
        impact float,
        database_name nvarchar(128),
        schema_name nvarchar(128),
        table_name nvarchar(128),
        index_xml xml
    );


    create table #missing_index_usage
    (
        queryhash binary(8),
        sqlhandle varbinary(64),
        impact float,
        database_name nvarchar(128),
        schema_name nvarchar(128),
        table_name nvarchar(128),
        usage nvarchar(128),
        index_xml xml
    );


    create table #missing_index_detail
    (
        queryhash binary(8),
        sqlhandle varbinary(64),
        impact float,
        database_name nvarchar(128),
        schema_name nvarchar(128),
        table_name nvarchar(128),
        usage nvarchar(128),
        column_name nvarchar(128)
    );


    create table #missing_index_pretty
    (
        queryhash binary(8),
        sqlhandle varbinary(64),
        impact float,
        database_name nvarchar(128),
        schema_name nvarchar(128),
        table_name nvarchar(128),
        equality nvarchar(max),
        inequality nvarchar(max),
        [include] nvarchar(max),
        executions nvarchar(128),
        query_cost nvarchar(128),
        creation_hours nvarchar(128),
        is_spool bit,
        details as N'/* '
            + CHAR(10)
            + case is_spool
                  when 0
                      then N'The Query Processor estimates that implementing the '
                  else N'We estimate that implementing the '
                       end
            + N'following index could improve query cost (' + query_cost + N')'
            + CHAR(10)
            + N'by '
            + CONVERT(nvarchar(30), impact)
            + N'% for ' + executions + N' executions of the query'
            + N' over the last ' +
                   case
                       when creation_hours < 24
                           then creation_hours + N' hours.'
                       when creation_hours = 24
                           then ' 1 day.'
                       when creation_hours > 24
                           then (CONVERT(nvarchar(128), creation_hours / 24)) + N' days.'
                       else N''
                       end
            + CHAR(10)
            + N'*/'
            + CHAR(10) + CHAR(13)
            + N'/* '
            + CHAR(10)
            + N'USE '
            + database_name
            + CHAR(10)
            + N'GO'
            + CHAR(10) + CHAR(13)
            + N'CREATE NONCLUSTERED INDEX ix_'
            + ISNULL(REPLACE(REPLACE(REPLACE(equality, '[', ''), ']', ''), ', ', '_'), '')
            + ISNULL(REPLACE(REPLACE(REPLACE(inequality, '[', ''), ']', ''), ', ', '_'), '')
            + case when [include] is not null then + N'_Includes' else N'' end
            + CHAR(10)
            + N' ON '
            + schema_name
            + N'.'
            + table_name
            + N' (' +
                   + case
                         when equality is not null
                             then equality
                             + case
                                   when inequality is not null
                                       then N', ' + inequality
                                   else N''
                                      end
                         else inequality
                       end
            + N')'
            + CHAR(10)
            + case
                  when include is not null
                      then N'INCLUDE (' + include +
                           N') WITH (FILLFACTOR=100, ONLINE=?, SORT_IN_TEMPDB=?, DATA_COMPRESSION=?);'
                  else N' WITH (FILLFACTOR=100, ONLINE=?, SORT_IN_TEMPDB=?, DATA_COMPRESSION=?);'
                       end
            + CHAR(10)
            + N'GO'
            + CHAR(10)
            + N'*/'
    );


    create table #index_spool_ugly
    (
        queryhash binary(8),
        sqlhandle varbinary(64),
        impact float,
        database_name nvarchar(128),
        schema_name nvarchar(128),
        table_name nvarchar(128),
        equality nvarchar(max),
        inequality nvarchar(max),
        [include] nvarchar(max),
        executions nvarchar(128),
        query_cost nvarchar(128),
        creation_hours nvarchar(128)
    );


    create table #readabledbs
    (
        database_id int
    );


    create table #plan_usage
    (
        duplicate_plan_handles bigint null,
        percent_duplicate numeric(7, 2) null,
        single_use_plan_count bigint null,
        percent_single numeric(7, 2) null,
        total_plans bigint null,
        spid int
    );


    if EXISTS(select * from sys.all_objects o where o.name = 'dm_hadr_database_replica_states')
        begin
            raiserror ('Checking for Read intent databases to exclude',0,0) with nowait;

            exec ('INSERT INTO #ReadableDBs (database_id) SELECT DBs.database_id FROM sys.databases DBs INNER JOIN sys.availability_replicas Replicas ON DBs.replica_id = Replicas.replica_id WHERE replica_server_name NOT IN (SELECT DISTINCT primary_replica FROM sys.dm_hadr_availability_group_states States) AND Replicas.secondary_role_allow_connections_desc = ''READ_ONLY'' AND replica_server_name = @@SERVERNAME OPTION (RECOMPILE);');
        end

    raiserror (N'Checking plan cache age', 0, 1) with nowait;
    with x as (
        select SUM(case when DATEDIFF(hour, deqs.creation_time, SYSDATETIME()) <= 24 then 1 else 0 end) as [plans_24],
               SUM(case when DATEDIFF(hour, deqs.creation_time, SYSDATETIME()) <= 4 then 1 else 0 end)  as [plans_4],
               SUM(case when DATEDIFF(hour, deqs.creation_time, SYSDATETIME()) <= 1 then 1 else 0 end)  as [plans_1],
               COUNT(deqs.creation_time)                                                                as [total_plans]
        from sys.dm_exec_query_stats as deqs
    )
    insert
    into #plan_creation (percent_24, percent_4, percent_1, total_plans, spid)
    select CONVERT(decimal(5, 2), NULLIF(x.plans_24, 0) / (1. * NULLIF(x.total_plans, 0))) * 100 as [percent_24],
           CONVERT(decimal(5, 2), NULLIF(x.plans_4, 0) / (1. * NULLIF(x.total_plans, 0))) * 100  as [percent_4],
           CONVERT(decimal(5, 2), NULLIF(x.plans_1, 0) / (1. * NULLIF(x.total_plans, 0))) * 100  as [percent_1],
           x.total_plans,
           @@SPID                                                                                as spid
    from x
    option (recompile);


    raiserror (N'Checking for single use plans and plans with many queries', 0, 1) with nowait;
    with total_plans as
             (
                 select COUNT_BIG(*) as total_plans
                 from sys.dm_exec_query_stats as deqs
             ),
         many_plans as
             (
                 select SUM(x.duplicate_plan_handles) as duplicate_plan_handles
                 from (
                          select COUNT_BIG(distinct plan_handle) as duplicate_plan_handles
                          from sys.dm_exec_query_stats qs
                                   cross apply sys.dm_exec_plan_attributes(qs.plan_handle) pa
                          where pa.attribute = N'dbid'
                          group by qs.query_hash, pa.value
                          having COUNT_BIG(distinct plan_handle) > 5
                      ) as x
             ),
         single_use_plans as
             (
                 select COUNT_BIG(*) as single_use_plan_count
                 from sys.dm_exec_cached_plans as cp
                 where cp.usecounts = 1
                   and cp.objtype = N'Adhoc'
                   and EXISTS(select 1 / 0
                              from sys.configurations as c
                              where c.name = N'optimize for ad hoc workloads'
                                and c.value_in_use = 0)
                 having COUNT_BIG(*) > 1
             )
    insert
    #plan_usage
    (
    duplicate_plan_handles
    ,
    percent_duplicate
    ,
    single_use_plan_count
    ,
    percent_single
    ,
    total_plans
    ,
    spid
    )
    select m.duplicate_plan_handles,
           CONVERT(decimal(5, 2), m.duplicate_plan_handles / (1. * NULLIF(t.total_plans, 0))) *
           100.                                                                                     as percent_duplicate,
           s.single_use_plan_count,
           CONVERT(decimal(5, 2), s.single_use_plan_count / (1. * NULLIF(t.total_plans, 0))) * 100. as percent_single,
           t.total_plans,
           @@SPID
    from many_plans as m,
         single_use_plans as s,
         total_plans as t;


    set @onlysqlhandles = LTRIM(RTRIM(@onlysqlhandles));
    set @onlyqueryhashes = LTRIM(RTRIM(@onlyqueryhashes));
    set @ignorequeryhashes = LTRIM(RTRIM(@ignorequeryhashes));

    declare @individual varchar(100);

    if (@onlysqlhandles is not null and @ignoresqlhandles is not null)
        begin
            raiserror ('You shouldn''t need to ignore and filter on SqlHandle at the same time.', 0, 1) with nowait;
            return;
        end;

    if (@storedprocname is not null and (@onlysqlhandles is not null or @ignoresqlhandles is not null))
        begin
            raiserror ('You can''t filter on stored procedure name and SQL Handle.', 0, 1) with nowait;
            return;
        end;

    if @onlysqlhandles is not null
        and LEN(@onlysqlhandles) > 0
        begin
            raiserror (N'Processing SQL Handles', 0, 1) with nowait;
            set @individual = '';

            while LEN(@onlysqlhandles) > 0
                begin
                    if PATINDEX('%,%', @onlysqlhandles) > 0
                        begin
                            set @individual = SUBSTRING(@onlysqlhandles, 0, PATINDEX('%,%', @onlysqlhandles));

                            insert into #only_sql_handles
                            select CAST('' as xml).value(
                                           'xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )',
                                           'varbinary(max)')
                            from (select case SUBSTRING(@individual, 1, 2) when '0x' then 3 else 0 end) as t(pos)
                            option (recompile);

                            --SELECT CAST(SUBSTRING(@individual, 1, 2) AS BINARY(8));

                            set @onlysqlhandles =
                                    SUBSTRING(@onlysqlhandles, LEN(@individual + ',') + 1, LEN(@onlysqlhandles));
                        end;
                    else
                        begin
                            set @individual = @onlysqlhandles;
                            set @onlysqlhandles = null;

                            insert into #only_sql_handles
                            select CAST('' as xml).value(
                                           'xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )',
                                           'varbinary(max)')
                            from (select case SUBSTRING(@individual, 1, 2) when '0x' then 3 else 0 end) as t(pos)
                            option (recompile);

                            --SELECT CAST(SUBSTRING(@individual, 1, 2) AS VARBINARY(MAX)) ;
                        end;
                end;
        end;

    if @ignoresqlhandles is not null
        and LEN(@ignoresqlhandles) > 0
        begin
            raiserror (N'Processing SQL Handles To Ignore', 0, 1) with nowait;
            set @individual = '';

            while LEN(@ignoresqlhandles) > 0
                begin
                    if PATINDEX('%,%', @ignoresqlhandles) > 0
                        begin
                            set @individual = SUBSTRING(@ignoresqlhandles, 0, PATINDEX('%,%', @ignoresqlhandles));

                            insert into #ignore_sql_handles
                            select CAST('' as xml).value(
                                           'xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )',
                                           'varbinary(max)')
                            from (select case SUBSTRING(@individual, 1, 2) when '0x' then 3 else 0 end) as t(pos)
                            option (recompile);

                            --SELECT CAST(SUBSTRING(@individual, 1, 2) AS BINARY(8));

                            set @ignoresqlhandles =
                                    SUBSTRING(@ignoresqlhandles, LEN(@individual + ',') + 1, LEN(@ignoresqlhandles));
                        end;
                    else
                        begin
                            set @individual = @ignoresqlhandles;
                            set @ignoresqlhandles = null;

                            insert into #ignore_sql_handles
                            select CAST('' as xml).value(
                                           'xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )',
                                           'varbinary(max)')
                            from (select case SUBSTRING(@individual, 1, 2) when '0x' then 3 else 0 end) as t(pos)
                            option (recompile);

                            --SELECT CAST(SUBSTRING(@individual, 1, 2) AS VARBINARY(MAX)) ;
                        end;
                end;
        end;

    if @storedprocname is not null and @storedprocname <> N''
        begin
            raiserror (N'Setting up filter for stored procedure name', 0, 1) with nowait;

            declare @function_search_sql nvarchar(max) = N''

            insert #only_sql_handles
                (sql_handle)
            select ISNULL(deps.sql_handle, CONVERT(varbinary(64),
                    '0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'))
            from sys.dm_exec_procedure_stats as deps
            where OBJECT_NAME(deps.object_id, deps.database_id) = @storedprocname

            union all

            select ISNULL(dets.sql_handle, CONVERT(varbinary(64),
                    '0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'))
            from sys.dm_exec_trigger_stats as dets
            where OBJECT_NAME(dets.object_id, dets.database_id) = @storedprocname
            option (recompile);

            if EXISTS(select 1 / 0 from sys.all_objects as o where o.name = 'dm_exec_function_stats')
                begin
                    set @function_search_sql = @function_search_sql + N'
         SELECT  ISNULL(defs.sql_handle, CONVERT(VARBINARY(64),''0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000''))
	     FROM sys.dm_exec_function_stats AS defs
	     WHERE OBJECT_NAME(defs.object_id, defs.database_id) = @i_StoredProcName
         OPTION (RECOMPILE);
         '
                    insert #only_sql_handles (sql_handle)
                        exec sys.sp_executesql @function_search_sql, N'@i_StoredProcName NVARCHAR(128)', @storedprocname
                end

            if (select COUNT(*) from #only_sql_handles) = 0
                begin
                    raiserror (N'No information for that stored procedure was found.', 0, 1) with nowait;
                    return;
                end;

        end;


    if ((@onlyqueryhashes is not null and LEN(@onlyqueryhashes) > 0)
        or (@ignorequeryhashes is not null and LEN(@ignorequeryhashes) > 0))
        and LEFT(@queryfilter, 3) in ('pro', 'fun')
        begin
            raiserror ('You cannot limit by query hash and filter by stored procedure', 16, 1);
            return;
        end;

/* If the user is attempting to limit by query hash, set up the
   #only_query_hashes temp table. This will be used to narrow down
   results.

   Just a reminder: Using @OnlyQueryHashes will ignore stored
   procedures and triggers.
 */
    if @onlyqueryhashes is not null
        and LEN(@onlyqueryhashes) > 0
        begin
            raiserror (N'Setting up filter for Query Hashes', 0, 1) with nowait;
            set @individual = '';

            while LEN(@onlyqueryhashes) > 0
                begin
                    if PATINDEX('%,%', @onlyqueryhashes) > 0
                        begin
                            set @individual = SUBSTRING(@onlyqueryhashes, 0, PATINDEX('%,%', @onlyqueryhashes));

                            insert into #only_query_hashes
                            select CAST('' as xml).value(
                                           'xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )',
                                           'varbinary(max)')
                            from (select case SUBSTRING(@individual, 1, 2) when '0x' then 3 else 0 end) as t(pos)
                            option (recompile);

                            --SELECT CAST(SUBSTRING(@individual, 1, 2) AS BINARY(8));

                            set @onlyqueryhashes =
                                    SUBSTRING(@onlyqueryhashes, LEN(@individual + ',') + 1, LEN(@onlyqueryhashes));
                        end;
                    else
                        begin
                            set @individual = @onlyqueryhashes;
                            set @onlyqueryhashes = null;

                            insert into #only_query_hashes
                            select CAST('' as xml).value(
                                           'xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )',
                                           'varbinary(max)')
                            from (select case SUBSTRING(@individual, 1, 2) when '0x' then 3 else 0 end) as t(pos)
                            option (recompile);

                            --SELECT CAST(SUBSTRING(@individual, 1, 2) AS VARBINARY(MAX)) ;
                        end;
                end;
        end;

/* If the user is setting up a list of query hashes to ignore, those
   values will be inserted into #ignore_query_hashes. This is used to
   exclude values from query results.

   Just a reminder: Using @IgnoreQueryHashes will ignore stored
   procedures and triggers.
 */
    if @ignorequeryhashes is not null
        and LEN(@ignorequeryhashes) > 0
        begin
            raiserror (N'Setting up filter to ignore query hashes', 0, 1) with nowait;
            set @individual = '';

            while LEN(@ignorequeryhashes) > 0
                begin
                    if PATINDEX('%,%', @ignorequeryhashes) > 0
                        begin
                            set @individual = SUBSTRING(@ignorequeryhashes, 0, PATINDEX('%,%', @ignorequeryhashes));

                            insert into #ignore_query_hashes
                            select CAST('' as xml).value(
                                           'xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )',
                                           'varbinary(max)')
                            from (select case SUBSTRING(@individual, 1, 2) when '0x' then 3 else 0 end) as t(pos)
                            option (recompile);

                            set @ignorequeryhashes =
                                    SUBSTRING(@ignorequeryhashes, LEN(@individual + ',') + 1, LEN(@ignorequeryhashes));
                        end;
                    else
                        begin
                            set @individual = @ignorequeryhashes;
                            set @ignorequeryhashes = null;

                            insert into #ignore_query_hashes
                            select CAST('' as xml).value(
                                           'xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )',
                                           'varbinary(max)')
                            from (select case SUBSTRING(@individual, 1, 2) when '0x' then 3 else 0 end) as t(pos)
                            option (recompile);
                        end;
                end;
        end;

    if @configurationdatabasename is not null
        begin
            raiserror (N'Reading values from Configuration Database', 0, 1) with nowait;
            declare @config_sql nvarchar(max) = N'INSERT INTO #configuration SELECT parameter_name, value FROM '
                + QUOTENAME(@configurationdatabasename)
                + '.' + QUOTENAME(@configurationschemaname)
                + '.' + QUOTENAME(@configurationtablename)
                + ' ; ';
            exec (@config_sql);
        end;

    raiserror (N'Setting up variables', 0, 1) with nowait;
    declare @sql nvarchar(max) = N'',
        @insert_list nvarchar(max) = N'',
        @plans_triggers_select_list nvarchar(max) = N'',
        @body nvarchar(max) = N'',
        @body_where nvarchar(max) = N'WHERE 1 = 1 ' + @nl,
        @body_order nvarchar(max) = N'ORDER BY #sortable# DESC OPTION (RECOMPILE) ',

        @q nvarchar(1) = N'''',
        @pv varchar(20),
        @pos tinyint,
        @v decimal(6, 2),
        @build int;


    raiserror (N'Determining SQL Server version.',0,1) with nowait;

    insert into #checkversion (version)
    select CAST(SERVERPROPERTY('ProductVersion') as nvarchar(128))
    option (recompile);


    select @v = common_version,
           @build = build
    from #checkversion
    option (recompile);

    if (@sortorder in ('memory grant', 'avg memory grant')) and @versionshowsmemorygrants = 0
        begin
            raiserror ('Your version of SQL does not support sorting by memory grant or average memory grant. Please use another sort order.', 16, 1);
            return;
        end;

    if (@sortorder in ('spills', 'avg spills') and @versionshowsspills = 0)
        begin
            raiserror ('Your version of SQL does not support sorting by spills. Please use another sort order.', 16, 1);
            return;
        end;

    if ((LEFT(@queryfilter, 3) = 'fun') and (@v < 13))
        begin
            raiserror ('Your version of SQL does not support filtering by functions. Please use another filter.', 16, 1);
            return;
        end;

    raiserror (N'Creating dynamic SQL based on SQL Server version.',0,1) with nowait;

    set @insert_list += N'
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
INSERT INTO ##BlitzCacheProcs (SPID, QueryType, DatabaseName, AverageCPU, TotalCPU, AverageCPUPerMinute, PercentCPUByType, PercentDurationByType,
                    PercentReadsByType, PercentExecutionsByType, AverageDuration, TotalDuration, AverageReads, TotalReads, ExecutionCount,
                    ExecutionsPerMinute, TotalWrites, AverageWrites, PercentWritesByType, WritesPerMinute, PlanCreationTime,
                    LastExecutionTime, LastCompletionTime, StatementStartOffset, StatementEndOffset, MinReturnedRows, MaxReturnedRows, AverageReturnedRows, TotalReturnedRows,
                    LastReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB, MaxUsedGrantKB, PercentMemoryGrantUsed, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills,
					QueryText, QueryPlan, TotalWorkerTimeForType, TotalElapsedTimeForType, TotalReadsForType,
                    TotalExecutionCountForType, TotalWritesForType, SqlHandle, PlanHandle, QueryHash, QueryPlanHash,
                    min_worker_time, max_worker_time, is_parallel, min_elapsed_time, max_elapsed_time, age_minutes, age_minutes_lifetime) ';

    set @body += N'
FROM   (SELECT TOP (@Top) x.*, xpa.*,
               CAST((CASE WHEN DATEDIFF(mi, cached_time, GETDATE()) > 0 AND execution_count > 1
                          THEN DATEDIFF(mi, cached_time, GETDATE())
                          ELSE NULL END) as MONEY) as age_minutes,
               CAST((CASE WHEN DATEDIFF(mi, cached_time, last_execution_time) > 0 AND execution_count > 1
                          THEN DATEDIFF(mi, cached_time, last_execution_time)
                          ELSE Null END) as MONEY) as age_minutes_lifetime
        FROM   sys.#view# x
               CROSS APPLY (SELECT * FROM sys.dm_exec_plan_attributes(x.plan_handle) AS ixpa
                            WHERE ixpa.attribute = ''dbid'') AS xpa ' + @nl;


    if @versionshowsairquoteactualplans = 1
        begin
            set @body += N'     CROSS APPLY sys.dm_exec_query_plan_stats(x.plan_handle) AS deqps ' + @nl;
        end

    set @body += N'        WHERE  1 = 1 ' + @nl;

    if EXISTS(select * from sys.all_objects o where o.name = 'dm_hadr_database_replica_states')
        begin
            raiserror (N'Ignoring readable secondaries databases by default', 0, 1) with nowait;
            set @body += N'               AND CAST(xpa.value AS INT) NOT IN (SELECT database_id FROM #ReadableDBs)' +
                         @nl;
        end

    if @ignoresystemdbs = 1
        begin
            raiserror (N'Ignoring system databases by default', 0, 1) with nowait;
            set @body +=
                    N'               AND COALESCE(DB_NAME(CAST(xpa.value AS INT)), '''') NOT IN (''master'', ''model'', ''msdb'', ''tempdb'', ''32767'') AND COALESCE(DB_NAME(CAST(xpa.value AS INT)), '''') NOT IN (SELECT name FROM sys.databases WHERE is_distributor = 1)' +
                    @nl;
        end;

    if @databasename is not null or @databasename <> N''
        begin
            raiserror (N'Filtering database name chosen', 0, 1) with nowait;
            set @body += N'               AND CAST(xpa.value AS BIGINT) = DB_ID(N'
                + QUOTENAME(@databasename, N'''')
                + N') ' + @nl;
        end;

    if (select COUNT(*) from #only_sql_handles) > 0
        begin
            raiserror (N'Including only chosen SQL Handles', 0, 1) with nowait;
            set @body +=
                    N'               AND EXISTS(SELECT 1/0 FROM #only_sql_handles q WHERE q.sql_handle = x.sql_handle) ' +
                    @nl;
        end;

    if (select COUNT(*) from #ignore_sql_handles) > 0
        begin
            raiserror (N'Including only chosen SQL Handles', 0, 1) with nowait;
            set @body +=
                    N'               AND NOT EXISTS(SELECT 1/0 FROM #ignore_sql_handles q WHERE q.sql_handle = x.sql_handle) ' +
                    @nl;
        end;

    if (select COUNT(*) from #only_query_hashes) > 0
        and (select COUNT(*) from #ignore_query_hashes) = 0
        and (select COUNT(*) from #only_sql_handles) = 0
        and (select COUNT(*) from #ignore_sql_handles) = 0
        begin
            raiserror (N'Including only chosen Query Hashes', 0, 1) with nowait;
            set @body +=
                    N'               AND EXISTS(SELECT 1/0 FROM #only_query_hashes q WHERE q.query_hash = x.query_hash) ' +
                    @nl;
        end;

/* filtering for query hashes */
    if (select COUNT(*) from #ignore_query_hashes) > 0
        and (select COUNT(*) from #only_query_hashes) = 0
        begin
            raiserror (N'Excluding chosen Query Hashes', 0, 1) with nowait;
            set @body +=
                    N'               AND NOT EXISTS(SELECT 1/0 FROM #ignore_query_hashes iq WHERE iq.query_hash = x.query_hash) ' +
                    @nl;
        end;
/* end filtering for query hashes */


    if @durationfilter is not null
        begin
            raiserror (N'Setting duration filter', 0, 1) with nowait;
            set @body += N'       AND (total_elapsed_time / 1000.0) / execution_count > @min_duration ' + @nl;
        end;

    if @minutesback is not null
        begin
            raiserror (N'Setting minutes back filter', 0, 1) with nowait;
            set @body +=
                    N'       AND DATEADD(MILLISECOND, (x.last_elapsed_time / 1000.), x.last_execution_time) >= DATEADD(MINUTE, @min_back, GETDATE()) ' +
                    @nl;
        end;

    if @slowlysearchplansfor is not null
        begin
            raiserror (N'Setting string search for @SlowlySearchPlansFor, so remember, this is gonna be slow', 0, 1) with nowait;
            set @slowlysearchplansfor =
                    REPLACE((REPLACE((REPLACE((REPLACE(@slowlysearchplansfor, N'[', N'_')), N']', N'_')), N'^', N'_')),
                            N'''', N'''''');
            set @body_where += N'       AND CAST(qp.query_plan AS NVARCHAR(MAX)) LIKE N''%' + @slowlysearchplansfor +
                               N'%'' ' + @nl;
        end


/* Apply the sort order here to only grab relevant plans.
   This should make it faster to process since we'll be pulling back fewer
   plans for processing.
 */
    raiserror (N'Applying chosen sort order', 0, 1) with nowait;
    select @body += N'        ORDER BY ' +
                    case @sortorder
                        when N'cpu' then N'total_worker_time'
                        when N'reads' then N'total_logical_reads'
                        when N'writes' then N'total_logical_writes'
                        when N'duration' then N'total_elapsed_time'
                        when N'executions' then N'execution_count'
                        when N'compiles' then N'cached_time'
                        when N'memory grant' then N'max_grant_kb'
                        when N'spills' then N'max_spills'
                        /* And now the averages */
                        when N'avg cpu' then N'total_worker_time / execution_count'
                        when N'avg reads' then N'total_logical_reads / execution_count'
                        when N'avg writes' then N'total_logical_writes / execution_count'
                        when N'avg duration' then N'total_elapsed_time / execution_count'
                        when N'avg memory grant'
                            then N'CASE WHEN max_grant_kb = 0 THEN 0 ELSE max_grant_kb / execution_count END'
                        when N'avg spills'
                            then N'CASE WHEN total_spills = 0 THEN 0 ELSE total_spills / execution_count END'
                        when N'avg executions' then 'CASE WHEN execution_count = 0 THEN 0
            WHEN COALESCE(CAST((CASE WHEN DATEDIFF(mi, cached_time, GETDATE()) > 0 AND execution_count > 1
                          THEN DATEDIFF(mi, cached_time, GETDATE())
                          ELSE NULL END) as MONEY), CAST((CASE WHEN DATEDIFF(mi, cached_time, last_execution_time) > 0 AND execution_count > 1
                          THEN DATEDIFF(mi, cached_time, last_execution_time)
                          ELSE Null END) as MONEY), 0) = 0 THEN 0
            ELSE CAST((1.00 * execution_count / COALESCE(CAST((CASE WHEN DATEDIFF(mi, cached_time, GETDATE()) > 0 AND execution_count > 1
                          THEN DATEDIFF(mi, cached_time, GETDATE())
                          ELSE NULL END) as MONEY), CAST((CASE WHEN DATEDIFF(mi, cached_time, last_execution_time) > 0 AND execution_count > 1
                          THEN DATEDIFF(mi, cached_time, last_execution_time)
                          ELSE Null END) as MONEY))) AS money)
            END '
                        end + N' DESC ' + @nl;


    set @body += N') AS qs
	   CROSS JOIN(SELECT SUM(execution_count) AS t_TotalExecs,
                         SUM(CAST(total_elapsed_time AS BIGINT) / 1000.0) AS t_TotalElapsed,
                         SUM(CAST(total_worker_time AS BIGINT) / 1000.0) AS t_TotalWorker,
                         SUM(CAST(total_logical_reads AS BIGINT)) AS t_TotalReads,
                         SUM(CAST(total_logical_writes AS BIGINT)) AS t_TotalWrites
                  FROM   sys.#view#) AS t
       CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) AS pa
       CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
       CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) AS qp ' + @nl;

    if @versionshowsairquoteactualplans = 1
        begin
            set @body += N'     CROSS APPLY sys.dm_exec_query_plan_stats(qs.plan_handle) AS deqps ' + @nl;
        end

    set @body_where += N'       AND pa.attribute = ' + QUOTENAME('dbid', @q) + @nl;


    if @noobsaibot = 1
        begin
            set @body_where +=
                    N'       AND qp.query_plan.exist(''declare namespace p="http://schemas.microsoft.com/sqlserver/2004/07/showplan";//p:StmtSimple//p:MissingIndex'') = 1' +
                    @nl;
        end

    set @plans_triggers_select_list += N'
SELECT TOP (@Top)
       @@SPID ,
       ''Procedure or Function: ''
	   + QUOTENAME(COALESCE(OBJECT_SCHEMA_NAME(qs.object_id, qs.database_id),''''))
	   + ''.''
	   + QUOTENAME(COALESCE(OBJECT_NAME(qs.object_id, qs.database_id),'''')) AS QueryType,
       COALESCE(DB_NAME(database_id), CAST(pa.value AS sysname), N''-- N/A --'') AS DatabaseName,
       (total_worker_time / 1000.0) / execution_count AS AvgCPU ,
       (total_worker_time / 1000.0) AS TotalCPU ,
       CASE WHEN total_worker_time = 0 THEN 0
            WHEN COALESCE(age_minutes, DATEDIFF(mi, qs.cached_time, qs.last_execution_time), 0) = 0 THEN 0
            ELSE CAST((total_worker_time / 1000.0) / COALESCE(age_minutes, DATEDIFF(mi, qs.cached_time, qs.last_execution_time)) AS MONEY)
            END AS AverageCPUPerMinute ,
       CASE WHEN t.t_TotalWorker = 0 THEN 0
            ELSE CAST(ROUND(100.00 * (total_worker_time / 1000.0) / t.t_TotalWorker, 2) AS MONEY)
            END AS PercentCPUByType,
       CASE WHEN t.t_TotalElapsed = 0 THEN 0
            ELSE CAST(ROUND(100.00 * (total_elapsed_time / 1000.0) / t.t_TotalElapsed, 2) AS MONEY)
            END AS PercentDurationByType,
       CASE WHEN t.t_TotalReads = 0 THEN 0
            ELSE CAST(ROUND(100.00 * total_logical_reads / t.t_TotalReads, 2) AS MONEY)
            END AS PercentReadsByType,
       CASE WHEN t.t_TotalExecs = 0 THEN 0
            ELSE CAST(ROUND(100.00 * execution_count / t.t_TotalExecs, 2) AS MONEY)
            END AS PercentExecutionsByType,
       (total_elapsed_time / 1000.0) / execution_count AS AvgDuration ,
       (total_elapsed_time / 1000.0) AS TotalDuration ,
       total_logical_reads / execution_count AS AvgReads ,
       total_logical_reads AS TotalReads ,
       execution_count AS ExecutionCount ,
       CASE WHEN execution_count = 0 THEN 0
            WHEN COALESCE(age_minutes, DATEDIFF(mi, qs.cached_time, qs.last_execution_time), 0) = 0 THEN 0
            ELSE CAST((1.00 * execution_count / COALESCE(age_minutes, DATEDIFF(mi, qs.cached_time, qs.last_execution_time))) AS money)
            END AS ExecutionsPerMinute ,
       total_logical_writes AS TotalWrites ,
       total_logical_writes / execution_count AS AverageWrites ,
       CASE WHEN t.t_TotalWrites = 0 THEN 0
            ELSE CAST(ROUND(100.00 * total_logical_writes / t.t_TotalWrites, 2) AS MONEY)
            END AS PercentWritesByType,
       CASE WHEN total_logical_writes = 0 THEN 0
            WHEN COALESCE(age_minutes, DATEDIFF(mi, qs.cached_time, qs.last_execution_time), 0) = 0 THEN 0
            ELSE CAST((1.00 * total_logical_writes / COALESCE(age_minutes, DATEDIFF(mi, qs.cached_time, qs.last_execution_time), 0)) AS money)
            END AS WritesPerMinute,
       qs.cached_time AS PlanCreationTime,
       qs.last_execution_time AS LastExecutionTime,
	   DATEADD(MILLISECOND, (qs.last_elapsed_time / 1000.), qs.last_execution_time) AS LastCompletionTime,
       NULL AS StatementStartOffset,
       NULL AS StatementEndOffset,
       NULL AS MinReturnedRows,
       NULL AS MaxReturnedRows,
       NULL AS AvgReturnedRows,
       NULL AS TotalReturnedRows,
       NULL AS LastReturnedRows,
       NULL AS MinGrantKB,
       NULL AS MaxGrantKB,
       NULL AS MinUsedGrantKB,
	   NULL AS MaxUsedGrantKB,
	   NULL AS PercentMemoryGrantUsed,
	   NULL AS AvgMaxMemoryGrant,';

    if @versionshowsspills = 1
        begin
            raiserror (N'Getting spill information for newer versions of SQL', 0, 1) with nowait;
            set @plans_triggers_select_list += N'
           min_spills AS MinSpills,
           max_spills AS MaxSpills,
           total_spills AS TotalSpills,
		   CAST(ISNULL(NULLIF(( total_spills * 1. ), 0) / NULLIF(execution_count, 0), 0) AS MONEY) AS AvgSpills, ';
        end;
    else
        begin
            raiserror (N'Substituting NULLs for spill columns in older versions of SQL', 0, 1) with nowait;
            set @plans_triggers_select_list += N'
           NULL AS MinSpills,
           NULL AS MaxSpills,
           NULL AS TotalSpills,
		   NULL AS AvgSpills, ';
        end;

    set @plans_triggers_select_list +=
        N'st.text AS QueryText ,';

    if @versionshowsairquoteactualplans = 1
        begin
            set @plans_triggers_select_list +=
                    N' CASE WHEN DATALENGTH(COALESCE(deqps.query_plan,'''')) > DATALENGTH(COALESCE(qp.query_plan,'''')) THEN deqps.query_plan ELSE qp.query_plan END AS QueryPlan, ' +
                    @nl;
        end;
    else
        begin
            set @plans_triggers_select_list += N' qp.query_plan AS QueryPlan, ' + @nl;
        end;

    set @plans_triggers_select_list +=
        N't.t_TotalWorker,
       t.t_TotalElapsed,
       t.t_TotalReads,
       t.t_TotalExecs,
       t.t_TotalWrites,
       qs.sql_handle AS SqlHandle,
       qs.plan_handle AS PlanHandle,
       NULL AS QueryHash,
       NULL AS QueryPlanHash,
       qs.min_worker_time / 1000.0,
       qs.max_worker_time / 1000.0,
       CASE WHEN qp.query_plan.value(''declare namespace p="http://schemas.microsoft.com/sqlserver/2004/07/showplan";max(//p:RelOp/@Parallel)'', ''float'')  > 0 THEN 1 ELSE 0 END,
       qs.min_elapsed_time / 1000.0,
       qs.max_elapsed_time / 1000.0,
       age_minutes,
       age_minutes_lifetime ';


    if LEFT(@queryfilter, 3) in ('all', 'sta')
        begin
            set @sql += @insert_list;

            set @sql += N'
    SELECT TOP (@Top)
           @@SPID ,
           ''Statement'' AS QueryType,
           COALESCE(DB_NAME(CAST(pa.value AS INT)), N''-- N/A --'') AS DatabaseName,
           (total_worker_time / 1000.0) / execution_count AS AvgCPU ,
           (total_worker_time / 1000.0) AS TotalCPU ,
           CASE WHEN total_worker_time = 0 THEN 0
                WHEN COALESCE(age_minutes, DATEDIFF(mi, qs.creation_time, qs.last_execution_time), 0) = 0 THEN 0
                ELSE CAST((total_worker_time / 1000.0) / COALESCE(age_minutes, DATEDIFF(mi, qs.creation_time, qs.last_execution_time)) AS MONEY)
                END AS AverageCPUPerMinute ,
           CASE WHEN t.t_TotalWorker = 0 THEN 0
                ELSE CAST(ROUND(100.00 * total_worker_time / t.t_TotalWorker, 2) AS MONEY)
                END AS PercentCPUByType,
           CASE WHEN t.t_TotalElapsed = 0 THEN 0
                ELSE CAST(ROUND(100.00 * total_elapsed_time / t.t_TotalElapsed, 2) AS MONEY)
                END AS PercentDurationByType,
           CASE WHEN t.t_TotalReads = 0 THEN 0
                ELSE CAST(ROUND(100.00 * total_logical_reads / t.t_TotalReads, 2) AS MONEY)
                END AS PercentReadsByType,
           CAST(ROUND(100.00 * execution_count / t.t_TotalExecs, 2) AS MONEY) AS PercentExecutionsByType,
           (total_elapsed_time / 1000.0) / execution_count AS AvgDuration ,
           (total_elapsed_time / 1000.0) AS TotalDuration ,
           total_logical_reads / execution_count AS AvgReads ,
           total_logical_reads AS TotalReads ,
           execution_count AS ExecutionCount ,
           CASE WHEN execution_count = 0 THEN 0
                WHEN COALESCE(age_minutes, DATEDIFF(mi, qs.creation_time, qs.last_execution_time), 0) = 0 THEN 0
                ELSE CAST((1.00 * execution_count / COALESCE(age_minutes, DATEDIFF(mi, qs.creation_time, qs.last_execution_time))) AS money)
                END AS ExecutionsPerMinute ,
           total_logical_writes AS TotalWrites ,
           total_logical_writes / execution_count AS AverageWrites ,
           CASE WHEN t.t_TotalWrites = 0 THEN 0
                ELSE CAST(ROUND(100.00 * total_logical_writes / t.t_TotalWrites, 2) AS MONEY)
                END AS PercentWritesByType,
           CASE WHEN total_logical_writes = 0 THEN 0
                WHEN COALESCE(age_minutes, DATEDIFF(mi, qs.creation_time, qs.last_execution_time), 0) = 0 THEN 0
                ELSE CAST((1.00 * total_logical_writes / COALESCE(age_minutes, DATEDIFF(mi, qs.creation_time, qs.last_execution_time), 0)) AS money)
                END AS WritesPerMinute,
           qs.creation_time AS PlanCreationTime,
           qs.last_execution_time AS LastExecutionTime,
		   DATEADD(MILLISECOND, (qs.last_elapsed_time / 1000.), qs.last_execution_time) AS LastCompletionTime,
           qs.statement_start_offset AS StatementStartOffset,
           qs.statement_end_offset AS StatementEndOffset, ';

            if (@v >= 11) or (@v >= 10.5 and @build >= 2500)
                begin
                    raiserror (N'Adding additional info columns for newer versions of SQL', 0, 1) with nowait;
                    set @sql += N'
           qs.min_rows AS MinReturnedRows,
           qs.max_rows AS MaxReturnedRows,
           CAST(qs.total_rows as MONEY) / execution_count AS AvgReturnedRows,
           qs.total_rows AS TotalReturnedRows,
           qs.last_rows AS LastReturnedRows, ';
                end;
            else
                begin
                    raiserror (N'Substituting NULLs for more info columns in older versions of SQL', 0, 1) with nowait;
                    set @sql += N'
           NULL AS MinReturnedRows,
           NULL AS MaxReturnedRows,
           NULL AS AvgReturnedRows,
           NULL AS TotalReturnedRows,
           NULL AS LastReturnedRows, ';
                end;

            if @versionshowsmemorygrants = 1
                begin
                    raiserror (N'Getting memory grant information for newer versions of SQL', 0, 1) with nowait;
                    set @sql += N'
           min_grant_kb AS MinGrantKB,
           max_grant_kb AS MaxGrantKB,
           min_used_grant_kb AS MinUsedGrantKB,
           max_used_grant_kb AS MaxUsedGrantKB,
           CAST(ISNULL(NULLIF(( max_used_grant_kb * 1.00 ), 0) / NULLIF(min_grant_kb, 0), 0) * 100. AS MONEY) AS PercentMemoryGrantUsed,
		   CAST(ISNULL(NULLIF(( max_grant_kb * 1. ), 0) / NULLIF(execution_count, 0), 0) AS MONEY) AS AvgMaxMemoryGrant, ';
                end;
            else
                begin
                    raiserror (N'Substituting NULLs for memory grant columns in older versions of SQL', 0, 1) with nowait;
                    set @sql += N'
           NULL AS MinGrantKB,
           NULL AS MaxGrantKB,
           NULL AS MinUsedGrantKB,
		   NULL AS MaxUsedGrantKB,
		   NULL AS PercentMemoryGrantUsed,
		   NULL AS AvgMaxMemoryGrant, ';
                end;

            if @versionshowsspills = 1
                begin
                    raiserror (N'Getting spill information for newer versions of SQL', 0, 1) with nowait;
                    set @sql += N'
           min_spills AS MinSpills,
           max_spills AS MaxSpills,
           total_spills AS TotalSpills,
		   CAST(ISNULL(NULLIF(( total_spills * 1. ), 0) / NULLIF(execution_count, 0), 0) AS MONEY) AS AvgSpills,';
                end;
            else
                begin
                    raiserror (N'Substituting NULLs for spill columns in older versions of SQL', 0, 1) with nowait;
                    set @sql += N'
           NULL AS MinSpills,
           NULL AS MaxSpills,
           NULL AS TotalSpills,
		   NULL AS AvgSpills, ';
                end;

            set @sql += N'
           SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                            WHEN -1 THEN DATALENGTH(st.text)
                                                                            ELSE qs.statement_end_offset
                                                                          END - qs.statement_start_offset ) / 2 ) + 1) AS QueryText , ' +
                        @nl;


            if @versionshowsairquoteactualplans = 1
                begin
                    set @sql +=
                            N'           CASE WHEN DATALENGTH(COALESCE(deqps.query_plan,'''')) > DATALENGTH(COALESCE(qp.query_plan,'''')) THEN deqps.query_plan ELSE qp.query_plan END AS QueryPlan, ' +
                            @nl;
                end
            else
                begin
                    set @sql += N'           query_plan AS QueryPlan, ' + @nl ;
                end

            set @sql += N'
           t.t_TotalWorker,
           t.t_TotalElapsed,
           t.t_TotalReads,
           t.t_TotalExecs,
           t.t_TotalWrites,
           qs.sql_handle AS SqlHandle,
           qs.plan_handle AS PlanHandle,
           qs.query_hash AS QueryHash,
           qs.query_plan_hash AS QueryPlanHash,
           qs.min_worker_time / 1000.0,
           qs.max_worker_time / 1000.0,
           CASE WHEN qp.query_plan.value(''declare namespace p="http://schemas.microsoft.com/sqlserver/2004/07/showplan";max(//p:RelOp/@Parallel)'', ''float'')  > 0 THEN 1 ELSE 0 END,
           qs.min_elapsed_time / 1000.0,
           qs.max_worker_time  / 1000.0,
           age_minutes,
           age_minutes_lifetime ';

            set @sql += REPLACE(REPLACE(@body, '#view#', 'dm_exec_query_stats'), 'cached_time', 'creation_time');

            set @sql += REPLACE(@body_where, 'cached_time', 'creation_time');

            set @sql += @body_order + @nl + @nl + @nl;

            if @sortorder = 'compiles'
                begin
                    raiserror (N'Sorting by compiles', 0, 1) with nowait;
                    set @sql = REPLACE(@sql, '#sortable#', 'creation_time');
                end;
        end;


    if (@queryfilter = 'all'
        and (select COUNT(*) from #only_query_hashes) = 0
        and (select COUNT(*) from #ignore_query_hashes) = 0)
           and (@sortorder not in ('memory grant', 'avg memory grant'))
        or (LEFT(@queryfilter, 3) = 'pro')
        begin
            set @sql += @insert_list;
            set @sql += REPLACE(@plans_triggers_select_list, '#query_type#', 'Stored Procedure');

            set @sql += REPLACE(@body, '#view#', 'dm_exec_procedure_stats');
            set @sql += @body_where;

            if @ignoresystemdbs = 1
                set @sql +=
                        N' AND COALESCE(DB_NAME(database_id), CAST(pa.value AS sysname), '''') NOT IN (''master'', ''model'', ''msdb'', ''tempdb'', ''32767'') AND COALESCE(DB_NAME(database_id), CAST(pa.value AS sysname), '''') NOT IN (SELECT name FROM sys.databases WHERE is_distributor = 1)' +
                        @nl;

            set @sql += @body_order + @nl + @nl + @nl;
        end;

    if (@v >= 13
        and @queryfilter = 'all'
        and (select COUNT(*) from #only_query_hashes) = 0
        and (select COUNT(*) from #ignore_query_hashes) = 0)
           and (@sortorder not in ('memory grant', 'avg memory grant'))
           and (@sortorder not in ('spills', 'avg spills'))
        or (LEFT(@queryfilter, 3) = 'fun')
        begin
            set @sql += @insert_list;
            set @sql += REPLACE(REPLACE(@plans_triggers_select_list, '#query_type#', 'Function')
                , N'
           min_spills AS MinSpills,
           max_spills AS MaxSpills,
           total_spills AS TotalSpills,
		   CAST(ISNULL(NULLIF(( total_spills * 1. ), 0) / NULLIF(execution_count, 0), 0) AS MONEY) AS AvgSpills, ',
                                N'
           NULL AS MinSpills,
           NULL AS MaxSpills,
           NULL AS TotalSpills,
		   NULL AS AvgSpills, ');

            set @sql += REPLACE(@body, '#view#', 'dm_exec_function_stats');
            set @sql += @body_where;

            if @ignoresystemdbs = 1
                set @sql +=
                        N' AND COALESCE(DB_NAME(database_id), CAST(pa.value AS sysname), '''') NOT IN (''master'', ''model'', ''msdb'', ''tempdb'', ''32767'') AND COALESCE(DB_NAME(database_id), CAST(pa.value AS sysname), '''') NOT IN (SELECT name FROM sys.databases WHERE is_distributor = 1)' +
                        @nl;

            set @sql += @body_order + @nl + @nl + @nl;
        end;

/*******************************************************************************
 *
 * Because the trigger execution count in SQL Server 2008R2 and earlier is not
 * correct, we ignore triggers for these versions of SQL Server. If you'd like
 * to include trigger numbers, just know that the ExecutionCount,
 * PercentExecutions, and ExecutionsPerMinute are wildly inaccurate for
 * triggers on these versions of SQL Server.
 *
 * This is why we can't have nice things.
 *
 ******************************************************************************/
    if (@usetriggersanyway = 1 or @v >= 11)
        and (select COUNT(*) from #only_query_hashes) = 0
        and (select COUNT(*) from #ignore_query_hashes) = 0
        and (@queryfilter = 'all')
        and (@sortorder not in ('memory grant', 'avg memory grant'))
        begin
            raiserror (N'Adding SQL to collect trigger stats.',0,1) with nowait;

            /* Trigger level information from the plan cache */
            set @sql += @insert_list;

            set @sql += REPLACE(@plans_triggers_select_list, '#query_type#', 'Trigger');

            set @sql += REPLACE(@body, '#view#', 'dm_exec_trigger_stats');

            set @sql += @body_where;

            if @ignoresystemdbs = 1
                set @sql +=
                        N' AND COALESCE(DB_NAME(database_id), CAST(pa.value AS sysname), '''') NOT IN (''master'', ''model'', ''msdb'', ''tempdb'', ''32767'') AND COALESCE(DB_NAME(database_id), CAST(pa.value AS sysname), '''') NOT IN (SELECT name FROM sys.databases WHERE is_distributor = 1)' +
                        @nl;

            set @sql += @body_order + @nl + @nl + @nl;
        end;

    declare @sort nvarchar(max);

    select @sort = case @sortorder
                       when N'cpu' then N'total_worker_time'
                       when N'reads' then N'total_logical_reads'
                       when N'writes' then N'total_logical_writes'
                       when N'duration' then N'total_elapsed_time'
                       when N'executions' then N'execution_count'
                       when N'compiles' then N'cached_time'
                       when N'memory grant' then N'max_grant_kb'
                       when N'spills' then N'max_spills'
        /* And now the averages */
                       when N'avg cpu' then N'total_worker_time / execution_count'
                       when N'avg reads' then N'total_logical_reads / execution_count'
                       when N'avg writes' then N'total_logical_writes / execution_count'
                       when N'avg duration' then N'total_elapsed_time / execution_count'
                       when N'avg memory grant'
                           then N'CASE WHEN max_grant_kb = 0 THEN 0 ELSE max_grant_kb / execution_count END'
                       when N'avg spills'
                           then N'CASE WHEN total_spills = 0 THEN 0 ELSE total_spills / execution_count END'
                       when N'avg executions' then N'CASE WHEN execution_count = 0 THEN 0
            WHEN COALESCE(age_minutes, age_minutes_lifetime, 0) = 0 THEN 0
            ELSE CAST((1.00 * execution_count / COALESCE(age_minutes, age_minutes_lifetime)) AS money)
            END'
        end;

    select @sql = REPLACE(@sql, '#sortable#', @sort);

    set @sql += N'
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
INSERT INTO #p (SqlHandle, TotalCPU, TotalReads, TotalDuration, TotalWrites, ExecutionCount)
SELECT  SqlHandle,
        TotalCPU,
        TotalReads,
        TotalDuration,
        TotalWrites,
        ExecutionCount
FROM    (SELECT  SqlHandle,
                 TotalCPU,
                 TotalReads,
                 TotalDuration,
                 TotalWrites,
                 ExecutionCount,
                 ROW_NUMBER() OVER (PARTITION BY SqlHandle ORDER BY #sortable# DESC) AS rn
         FROM    ##BlitzCacheProcs
		 WHERE SPID = @@SPID) AS x
WHERE x.rn = 1
OPTION (RECOMPILE);

/*
    This block was used to delete duplicate queries, but has been removed.
    For more info: https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/2026
WITH d AS (
SELECT  SPID,
        ROW_NUMBER() OVER (PARTITION BY SqlHandle, QueryHash ORDER BY #sortable# DESC) AS rn
FROM    ##BlitzCacheProcs
WHERE SPID = @@SPID
)
DELETE d
WHERE d.rn > 1
AND SPID = @@SPID
OPTION (RECOMPILE);
*/
';

    select @sort = case @sortorder
                       when N'cpu' then N'TotalCPU'
                       when N'reads' then N'TotalReads'
                       when N'writes' then N'TotalWrites'
                       when N'duration' then N'TotalDuration'
                       when N'executions' then N'ExecutionCount'
                       when N'compiles' then N'PlanCreationTime'
                       when N'memory grant' then N'MaxGrantKB'
                       when N'spills' then N'MaxSpills'
        /* And now the averages */
                       when N'avg cpu' then N'TotalCPU / ExecutionCount'
                       when N'avg reads' then N'TotalReads / ExecutionCount'
                       when N'avg writes' then N'TotalWrites / ExecutionCount'
                       when N'avg duration' then N'TotalDuration / ExecutionCount'
                       when N'avg memory grant' then N'AvgMaxMemoryGrant'
                       when N'avg spills' then N'AvgSpills'
                       when N'avg executions' then N'CASE WHEN ExecutionCount = 0 THEN 0
            WHEN COALESCE(age_minutes, age_minutes_lifetime, 0) = 0 THEN 0
            ELSE CAST((1.00 * ExecutionCount / COALESCE(age_minutes, age_minutes_lifetime)) AS money)
            END'
        end;

    select @sql = REPLACE(@sql, '#sortable#', @sort);


    if @debug = 1
        begin
            print SUBSTRING(@sql, 0, 4000);
            print SUBSTRING(@sql, 4000, 8000);
            print SUBSTRING(@sql, 8000, 12000);
            print SUBSTRING(@sql, 12000, 16000);
            print SUBSTRING(@sql, 16000, 20000);
            print SUBSTRING(@sql, 20000, 24000);
            print SUBSTRING(@sql, 24000, 28000);
            print SUBSTRING(@sql, 28000, 32000);
            print SUBSTRING(@sql, 32000, 36000);
            print SUBSTRING(@sql, 36000, 40000);
        end;

    if @reanalyze = 0
        begin
            raiserror ('Collecting execution plan information.', 0, 1) with nowait;

            exec sp_executesql @sql, N'@Top INT, @min_duration INT, @min_back INT', @top, @durationfilter_i,
                 @minutesback;
        end;

    if @skipanalysis = 1
        begin
            raiserror (N'Skipping analysis, going to results', 0, 1) with nowait;
            goto results;
        end;


/* Update ##BlitzCacheProcs to get Stored Proc info
 * This should get totals for all statements in a Stored Proc
 */
    raiserror (N'Attempting to aggregate stored proc info from separate statements', 0, 1) with nowait;
    ;
    with agg as (
        select b.sqlhandle,
               SUM(b.minreturnedrows)     as minreturnedrows,
               SUM(b.maxreturnedrows)     as maxreturnedrows,
               SUM(b.averagereturnedrows) as averagereturnedrows,
               SUM(b.totalreturnedrows)   as totalreturnedrows,
               SUM(b.lastreturnedrows)    as lastreturnedrows,
               SUM(b.mingrantkb)          as mingrantkb,
               SUM(b.maxgrantkb)          as maxgrantkb,
               SUM(b.minusedgrantkb)      as minusedgrantkb,
               SUM(b.maxusedgrantkb)      as maxusedgrantkb,
               SUM(b.minspills)           as minspills,
               SUM(b.maxspills)           as maxspills,
               SUM(b.totalspills)         as totalspills
        from ##blitzcacheprocs b
        where b.spid = @@SPID
          and b.queryhash is not null
        group by b.sqlhandle
    )
    update b
    set b.minreturnedrows     = b2.minreturnedrows,
        b.maxreturnedrows     = b2.maxreturnedrows,
        b.averagereturnedrows = b2.averagereturnedrows,
        b.totalreturnedrows   = b2.totalreturnedrows,
        b.lastreturnedrows    = b2.lastreturnedrows,
        b.mingrantkb          = b2.mingrantkb,
        b.maxgrantkb          = b2.maxgrantkb,
        b.minusedgrantkb      = b2.minusedgrantkb,
        b.maxusedgrantkb      = b2.maxusedgrantkb,
        b.minspills           = b2.minspills,
        b.maxspills           = b2.maxspills,
        b.totalspills         = b2.totalspills
    from ##blitzcacheprocs b
             join agg b2
                  on b2.sqlhandle = b.sqlhandle
    where b.queryhash is null
      and b.spid = @@SPID
    option (recompile);

/* Compute the total CPU, etc across our active set of the plan cache.
 * Yes, there's a flaw - this doesn't include anything outside of our @Top
 * metric.
 */
    raiserror ('Computing CPU, duration, read, and write metrics', 0, 1) with nowait;
    declare @total_duration bigint,
        @total_cpu bigint,
        @total_reads bigint,
        @total_writes bigint,
        @total_execution_count bigint;

    select @total_cpu = SUM(totalcpu),
           @total_duration = SUM(totalduration),
           @total_reads = SUM(totalreads),
           @total_writes = SUM(totalwrites),
           @total_execution_count = SUM(executioncount)
    from #p
    option (recompile);

    declare @cr nvarchar(1) = NCHAR(13);
    declare @lf nvarchar(1) = NCHAR(10);
    declare @tab nvarchar(1) = NCHAR(9);

/* Update CPU percentage for stored procedures */
    raiserror (N'Update CPU percentage for stored procedures', 0, 1) with nowait;
    update ##blitzcacheprocs
    set percentcpu          = y.percentcpu,
        percentduration     = y.percentduration,
        percentreads        = y.percentreads,
        percentwrites       = y.percentwrites,
        percentexecutions   = y.percentexecutions,
        executionsperminute = y.executionsperminute,
        /* Strip newlines and tabs. Tabs are replaced with multiple spaces
           so that the later whitespace trim will completely eliminate them
         */
        querytext           = REPLACE(REPLACE(REPLACE(querytext, @cr, ' '), @lf, ' '), @tab, '  ')
    from (
             select planhandle,
                    case @total_cpu
                        when 0 then 0
                        else CAST((100. * totalcpu) / @total_cpu as money) end                   as percentcpu,
                    case @total_duration
                        when 0 then 0
                        else CAST((100. * totalduration) / @total_duration as money) end         as percentduration,
                    case @total_reads
                        when 0 then 0
                        else CAST((100. * totalreads) / @total_reads as money) end               as percentreads,
                    case @total_writes
                        when 0 then 0
                        else CAST((100. * totalwrites) / @total_writes as money) end             as percentwrites,
                    case @total_execution_count
                        when 0 then 0
                        else CAST((100. * executioncount) / @total_execution_count as money) end as percentexecutions,
                    case DATEDIFF(mi, plancreationtime, lastexecutiontime)
                        when 0 then 0
                        else CAST((1.00 * executioncount / DATEDIFF(mi, plancreationtime, lastexecutiontime)) as money)
                        end                                                                      as executionsperminute
             from (
                      select planhandle,
                             totalcpu,
                             totalduration,
                             totalreads,
                             totalwrites,
                             executioncount,
                             plancreationtime,
                             lastexecutiontime
                      from ##blitzcacheprocs
                      where planhandle is not null
                        and spid = @@SPID
                      group by planhandle,
                               totalcpu,
                               totalduration,
                               totalreads,
                               totalwrites,
                               executioncount,
                               plancreationtime,
                               lastexecutiontime
                  ) as x
         ) as y
    where ##blitzcacheprocs.planhandle = y.planhandle
      and ##blitzcacheprocs.planhandle is not null
      and ##blitzcacheprocs.spid = @@SPID
    option (recompile);


    raiserror (N'Gather percentage information from grouped results', 0, 1) with nowait;
    update ##blitzcacheprocs
    set percentcpu          = y.percentcpu,
        percentduration     = y.percentduration,
        percentreads        = y.percentreads,
        percentwrites       = y.percentwrites,
        percentexecutions   = y.percentexecutions,
        executionsperminute = y.executionsperminute,
        /* Strip newlines and tabs. Tabs are replaced with multiple spaces
           so that the later whitespace trim will completely eliminate them
         */
        querytext           = REPLACE(REPLACE(REPLACE(querytext, @cr, ' '), @lf, ' '), @tab, '  ')
    from (
             select databasename,
                    sqlhandle,
                    queryhash,
                    case @total_cpu
                        when 0 then 0
                        else CAST((100. * totalcpu) / @total_cpu as money) end                   as percentcpu,
                    case @total_duration
                        when 0 then 0
                        else CAST((100. * totalduration) / @total_duration as money) end         as percentduration,
                    case @total_reads
                        when 0 then 0
                        else CAST((100. * totalreads) / @total_reads as money) end               as percentreads,
                    case @total_writes
                        when 0 then 0
                        else CAST((100. * totalwrites) / @total_writes as money) end             as percentwrites,
                    case @total_execution_count
                        when 0 then 0
                        else CAST((100. * executioncount) / @total_execution_count as money) end as percentexecutions,
                    case DATEDIFF(mi, plancreationtime, lastexecutiontime)
                        when 0 then 0
                        else CAST((1.00 * executioncount / DATEDIFF(mi, plancreationtime, lastexecutiontime)) as money)
                        end                                                                      as executionsperminute
             from (
                      select databasename,
                             sqlhandle,
                             queryhash,
                             totalcpu,
                             totalduration,
                             totalreads,
                             totalwrites,
                             executioncount,
                             plancreationtime,
                             lastexecutiontime
                      from ##blitzcacheprocs
                      where spid = @@SPID
                      group by databasename,
                               sqlhandle,
                               queryhash,
                               totalcpu,
                               totalduration,
                               totalreads,
                               totalwrites,
                               executioncount,
                               plancreationtime,
                               lastexecutiontime
                  ) as x
         ) as y
    where ##blitzcacheprocs.sqlhandle = y.sqlhandle
      and ##blitzcacheprocs.queryhash = y.queryhash
      and ##blitzcacheprocs.databasename = y.databasename
      and ##blitzcacheprocs.planhandle is null
    option (recompile);


/* Testing using XML nodes to speed up processing */
    raiserror (N'Begin XML nodes processing', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    select queryhash,
           sqlhandle,
           planhandle,
           q.n.query('.') as statement,
           0              as is_cursor
    into #statements
    from ##blitzcacheprocs p
             cross apply p.queryplan.nodes('//p:StmtSimple') as q(n)
    where p.spid = @@SPID
    option (recompile);

    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    insert
    #statements
    select queryhash,
           sqlhandle,
           planhandle,
           q.n.query('.') as statement,
           1              as is_cursor
    from ##blitzcacheprocs p
             cross apply p.queryplan.nodes('//p:StmtCursor') as q(n)
    where p.spid = @@SPID
    option (recompile);

    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    select queryhash,
           sqlhandle,
           q.n.query('.') as query_plan
    into #query_plan
    from #statements p
             cross apply p.statement.nodes('//p:QueryPlan') as q(n)
    option (recompile);

    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    select queryhash,
           sqlhandle,
           q.n.query('.') as relop
    into #relop
    from #query_plan p
             cross apply p.query_plan.nodes('//p:RelOp') as q(n)
    option (recompile);

-- high level plan stuff
    raiserror (N'Gathering high level plan information', 0, 1) with nowait;
    update ##blitzcacheprocs
    set numberofdistinctplans = distinct_plan_count,
        numberofplans         = number_of_plans,
        plan_multiple_plans   = case when distinct_plan_count < number_of_plans then number_of_plans end
    from (
             select COUNT(distinct queryhash) as distinct_plan_count,
                    COUNT(queryhash)          as number_of_plans,
                    queryhash
             from ##blitzcacheprocs
             where spid = @@SPID
             group by queryhash
         ) as x
    where ##blitzcacheprocs.queryhash = x.queryhash
    option (recompile);

-- query level checks
    raiserror (N'Performing query level checks', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update ##blitzcacheprocs
    set missing_index_count   = query_plan.value('count(//p:QueryPlan/p:MissingIndexes/p:MissingIndexGroup)', 'int'),
        unmatched_index_count = case
                                    when is_trivial <> 1 then query_plan.value(
                                            'count(//p:QueryPlan/p:UnmatchedIndexes/p:Parameterization/p:Object)',
                                            'int') end,
        serialdesiredmemory   = query_plan.value('sum(//p:QueryPlan/p:MemoryGrantInfo/@SerialDesiredMemory)', 'float'),
        serialrequiredmemory  = query_plan.value('sum(//p:QueryPlan/p:MemoryGrantInfo/@SerialRequiredMemory)', 'float'),
        cachedplansize        = query_plan.value('sum(//p:QueryPlan/@CachedPlanSize)', 'float'),
        compiletime           = query_plan.value('sum(//p:QueryPlan/@CompileTime)', 'float'),
        compilecpu            = query_plan.value('sum(//p:QueryPlan/@CompileCPU)', 'float'),
        compilememory         = query_plan.value('sum(//p:QueryPlan/@CompileMemory)', 'float'),
        maxcompilememory      = query_plan.value(
                'sum(//p:QueryPlan/p:OptimizerHardwareDependentProperties/@MaxCompileMemory)', 'float')
    from #query_plan qp
    where qp.queryhash = ##blitzcacheprocs.queryhash
      and qp.sqlhandle = ##blitzcacheprocs.sqlhandle
      and spid = @@SPID
    option (recompile);

-- statement level checks
    raiserror (N'Performing compile timeout checks', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update b
    set compile_timeout = 1
    from #statements s
             join ##blitzcacheprocs b
                  on s.queryhash = b.queryhash
                      and spid = @@SPID
    where statement.exist('/p:StmtSimple/@StatementOptmEarlyAbortReason[.="TimeOut"]') = 1
    option (recompile);

    raiserror (N'Performing compile memory limit exceeded checks', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update b
    set compile_memory_limit_exceeded = 1
    from #statements s
             join ##blitzcacheprocs b
                  on s.queryhash = b.queryhash
                      and spid = @@SPID
    where statement.exist('/p:StmtSimple/@StatementOptmEarlyAbortReason[.="MemoryLimitExceeded"]') = 1
    option (recompile);

    if @expertmode > 0
        begin
            raiserror (N'Performing unparameterized query checks', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p),
                unparameterized_query as (
                select s.QueryHash,
                unparameterized_query = case when statement.exist('//p:StmtSimple[@StatementOptmLevel[.="FULL"]]/p:QueryPlan/p:ParameterList') = 1 and
                statement.exist('//p:StmtSimple[@StatementOptmLevel[.="FULL"]]/p:QueryPlan/p:ParameterList/p:ColumnReference') = 0 then 1
                when statement.exist('//p:StmtSimple[@StatementOptmLevel[.="FULL"]]/p:QueryPlan/p:ParameterList') = 0 and
                statement.exist('//p:StmtSimple[@StatementOptmLevel[.="FULL"]]/*/p:RelOp/descendant::p:ScalarOperator/p:Identifier/p:ColumnReference[contains(@Column, "@")]') = 1 then 1
                end
                from #statements as s
                )
            update b
            set b.unparameterized_query = u.unparameterized_query
            from ##blitzcacheprocs b
                     join unparameterized_query u
                          on u.queryhash = b.queryhash
                              and spid = @@SPID
            where u.unparameterized_query = 1
            option (recompile);
        end;


    if @expertmode > 0
        begin
            raiserror (N'Performing index DML checks', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p),
                index_dml as (
                select s.QueryHash,
                index_dml = case when statement.exist('//p:StmtSimple/@StatementType[.="CREATE INDEX"]') = 1 then 1
                when statement.exist('//p:StmtSimple/@StatementType[.="DROP INDEX"]') = 1 then 1
                end
                from #statements s
                )
            update b
            set b.index_dml = i.index_dml
            from ##blitzcacheprocs as b
                     join index_dml i
                          on i.queryhash = b.queryhash
            where i.index_dml = 1
              and b.spid = @@SPID
            option (recompile);
        end;


    if @expertmode > 0
        begin
            raiserror (N'Performing table DML checks', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p),
                table_dml as (
                select s.QueryHash,
                table_dml = case when statement.exist('//p:StmtSimple/@StatementType[.="CREATE TABLE"]') = 1 then 1
                when statement.exist('//p:StmtSimple/@StatementType[.="DROP OBJECT"]') = 1 then 1
                end
                from #statements as s
                )
            update b
            set b.table_dml = t.table_dml
            from ##blitzcacheprocs as b
                     join table_dml t
                          on t.queryhash = b.queryhash
            where t.table_dml = 1
              and b.spid = @@SPID
            option (recompile);
        end;


    if @expertmode > 0
        begin
            raiserror (N'Gathering row estimates', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p )
            insert
            into #est_rows
            select distinct CONVERT(binary(8),
                                    RIGHT('0000000000000000' + SUBSTRING(c.n.value('@QueryHash', 'VARCHAR(18)'), 3, 18),
                                          16), 2)                                      as queryhash,
                            c.n.value('(/p:StmtSimple/@StatementEstRows)[1]', 'FLOAT') as estimated_rows
            from #statements as s
                     cross apply s.statement.nodes('/p:StmtSimple') as c(n)
            where c.n.exist('/p:StmtSimple[@StatementEstRows > 0]') = 1;

            update b
            set b.estimated_rows = er.estimated_rows
            from ##blitzcacheprocs as b
                     join #est_rows er
                          on er.queryhash = b.queryhash
            where b.spid = @@SPID
              and b.querytype = 'Statement'
            option (recompile);
        end;

    raiserror (N'Gathering trivial plans', 0, 1) with nowait;
    with xmlnamespaces ( 'http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p )
    update b
    set b.is_trivial = 1
    from ##blitzcacheprocs as b
             join (
        select s.sqlhandle
        from #statements as s
                 join (select r.sqlhandle
                       from #relop as r
                       where r.relop.exist('//p:RelOp[contains(@LogicalOp, "Scan")]') = 1) as r
                      on r.sqlhandle = s.sqlhandle
        where s.statement.exist('//p:StmtSimple[@StatementOptmLevel[.="TRIVIAL"]]/p:QueryPlan/p:ParameterList') = 1
    ) as s
                  on b.sqlhandle = s.sqlhandle
    option (recompile);


--Gather costs
    raiserror (N'Gathering statement costs', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    insert
    into #plan_cost (queryplancost, sqlhandle, planhandle, queryhash, queryplanhash)
    select distinct statement.value('sum(/p:StmtSimple/@StatementSubTreeCost)', 'float') queryplancost,
                    s.sqlhandle,
                    s.planhandle,
                    CONVERT(binary(8),
                            RIGHT('0000000000000000' + SUBSTRING(q.n.value('@QueryHash', 'VARCHAR(18)'), 3, 18), 16),
                            2)            as                                             queryhash,
                    CONVERT(binary(8),
                            RIGHT('0000000000000000' + SUBSTRING(q.n.value('@QueryPlanHash', 'VARCHAR(18)'), 3, 18),
                                  16), 2) as                                             queryplanhash
    from #statements s
             cross apply s.statement.nodes('/p:StmtSimple') as q(n)
    where statement.value('sum(/p:StmtSimple/@StatementSubTreeCost)', 'float') > 0
    option (recompile);

    raiserror (N'Updating statement costs', 0, 1) with nowait;
    with pc as (
        select SUM(distinct pc.queryplancost) as queryplancostsum,
               pc.queryhash,
               pc.queryplanhash,
               pc.sqlhandle,
               pc.planhandle
        from #plan_cost as pc
        group by pc.queryhash, pc.queryplanhash, pc.sqlhandle, pc.planhandle
    )
    update b
    set b.queryplancost = ISNULL(pc.queryplancostsum, 0)
    from pc
             join ##blitzcacheprocs b
                  on b.sqlhandle = pc.sqlhandle
                      and b.queryhash = pc.queryhash
    where b.querytype not like '%Procedure%'
    option (recompile);

    if EXISTS(
            select 1
            from ##blitzcacheprocs as b
            where b.querytype like 'Procedure%'
        )
        begin

            raiserror (N'Gathering stored procedure costs', 0, 1) with nowait;
            ;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
               , QueryCost as (
                select
                distinct
                statement.value('sum(/p:StmtSimple/@StatementSubTreeCost)'
               , 'float') as SubTreeCost
               , s.PlanHandle
               , s.SqlHandle
                from #statements as s
                where PlanHandle is not null
                )
               , QueryCostUpdate as (
                select
                sum (qc.SubTreeCost) over (partition by SqlHandle
               , PlanHandle) PlanTotalQuery
               , qc.PlanHandle
               , qc.SqlHandle
                from QueryCost qc
                )
            insert into #proc_costs
            select qcu.plantotalquery, planhandle, sqlhandle
            from querycostupdate as qcu
            option (recompile);


            update b
            set b.queryplancost = ca.plantotalquery
            from ##blitzcacheprocs as b
                     cross apply (
                select top 1 plantotalquery
                from #proc_costs qcu
                where qcu.planhandle = b.planhandle
                order by plantotalquery desc
            ) ca
            where b.querytype like 'Procedure%'
              and b.spid = @@SPID
            option (recompile);

        end;

    update b
    set b.queryplancost = 0.0
    from ##blitzcacheprocs b
    where b.queryplancost is null
      and b.spid = @@SPID
    option (recompile);

    raiserror (N'Checking for plan warnings', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update ##blitzcacheprocs
    set plan_warnings = 1
    from #query_plan qp
    where qp.sqlhandle = ##blitzcacheprocs.sqlhandle
      and spid = @@SPID
      and query_plan.exist('/p:QueryPlan/p:Warnings') = 1
    option (recompile);

    raiserror (N'Checking for implicit conversion', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update ##blitzcacheprocs
    set implicit_conversions = 1
    from #query_plan qp
    where qp.sqlhandle = ##blitzcacheprocs.sqlhandle
      and spid = @@SPID
      and query_plan.exist(
                  '/p:QueryPlan/p:Warnings/p:PlanAffectingConvert/@Expression[contains(., "CONVERT_IMPLICIT")]') = 1
    option (recompile);

-- operator level checks
    if @expertmode > 0
        begin
            raiserror (N'Performing busy loops checks', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            update p
            set busy_loops = case when (x.estimated_executions / 100.0) > x.estimated_rows then 1 end
            from ##blitzcacheprocs p
                     join (
                select qs.sqlhandle,
                       relop.value('sum(/p:RelOp/@EstimateRows)', 'float')          as estimated_rows,
                       relop.value('sum(/p:RelOp/@EstimateRewinds)', 'float') +
                       relop.value('sum(/p:RelOp/@EstimateRebinds)', 'float') + 1.0 as estimated_executions
                from #relop qs
            ) as x on p.sqlhandle = x.sqlhandle
            where spid = @@SPID
            option (recompile);
        end;


    raiserror (N'Performing TVF join check', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update p
    set p.tvf_join = case when x.tvf_join = 1 then 1 end
    from ##blitzcacheprocs p
             join (
        select r.sqlhandle,
               1 as tvf_join
        from #relop as r
        where r.relop.exist('//p:RelOp[(@LogicalOp[.="Table-valued function"])]') = 1
          and r.relop.exist('//p:RelOp[contains(@LogicalOp, "Join")]') = 1
    ) as x on p.sqlhandle = x.sqlhandle
    where spid = @@SPID
    option (recompile);

    if @expertmode > 0
        begin
            raiserror (N'Checking for operator warnings', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
               , x as (
                select r.SqlHandle
               , c.n.exist('//p:Warnings[(@NoJoinPredicate[.="1"])]') as warning_no_join_predicate
               , c.n.exist('//p:ColumnsWithNoStatistics') as no_stats_warning
               , c.n.exist('//p:Warnings') as relop_warnings
                from #relop as r
                cross apply r.relop.nodes('/p:RelOp/p:Warnings') as c(n)
                )
            update p
            set p.warning_no_join_predicate = x.warning_no_join_predicate,
                p.no_stats_warning          = x.no_stats_warning,
                p.relop_warnings            = x.relop_warnings
            from ##blitzcacheprocs as p
                     join x on x.sqlhandle = p.sqlhandle
                and spid = @@SPID
            option (recompile);
        end;


    raiserror (N'Checking for table variables', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
       , x as (
        select r.SqlHandle
       , c.n.value('substring(@Table, 2, 1)'
       , 'VARCHAR(100)') as first_char
        from #relop r
        cross apply r.relop.nodes('//p:Object') as c(n)
        )
    update p
    set is_table_variable = 1
    from ##blitzcacheprocs as p
             join x on x.sqlhandle = p.sqlhandle
        and spid = @@SPID
    where x.first_char = '@'
    option (recompile);

    if @expertmode > 0
        begin
            raiserror (N'Checking for functions', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
               , x as (
                select qs.SqlHandle
               , n.fn.value('count(distinct-values(//p:UserDefinedFunction[not(@IsClrFunction)]))'
               , 'INT') as function_count
               , n.fn.value('count(distinct-values(//p:UserDefinedFunction[@IsClrFunction = "1"]))'
               , 'INT') as clr_function_count
                from #relop qs
                cross apply relop.nodes('/p:RelOp/p:ComputeScalar/p:DefinedValues/p:DefinedValue/p:ScalarOperator') n (fn)
                )
            update p
            set p.function_count     = x.function_count,
                p.clr_function_count = x.clr_function_count
            from ##blitzcacheprocs as p
                     join x on x.sqlhandle = p.sqlhandle
                and spid = @@SPID
            option (recompile);
        end;


    raiserror (N'Checking for expensive key lookups', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update ##blitzcacheprocs
    set key_lookup_cost = x.key_lookup_cost
    from (
             select qs.sqlhandle,
                    MAX(relop.value('sum(/p:RelOp/@EstimatedTotalSubtreeCost)', 'float')) as key_lookup_cost
             from #relop qs
             where [relop].exist('/p:RelOp/p:IndexScan[(@Lookup[.="1"])]') = 1
             group by qs.sqlhandle
         ) as x
    where ##blitzcacheprocs.sqlhandle = x.sqlhandle
      and spid = @@SPID
    option (recompile);


    raiserror (N'Checking for expensive remote queries', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update ##blitzcacheprocs
    set remote_query_cost = x.remote_query_cost
    from (
             select qs.sqlhandle,
                    MAX(relop.value('sum(/p:RelOp/@EstimatedTotalSubtreeCost)', 'float')) as remote_query_cost
             from #relop qs
             where [relop].exist('/p:RelOp[(@PhysicalOp[contains(., "Remote")])]') = 1
             group by qs.sqlhandle
         ) as x
    where ##blitzcacheprocs.sqlhandle = x.sqlhandle
      and spid = @@SPID
    option (recompile);

    raiserror (N'Checking for expensive sorts', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update ##blitzcacheprocs
    set sort_cost = y.max_sort_cost
    from (
             select x.sqlhandle, MAX((x.sort_io + x.sort_cpu)) as max_sort_cost
             from (
                      select qs.sqlhandle,
                             relop.value('sum(/p:RelOp/@EstimateIO)', 'float')  as sort_io,
                             relop.value('sum(/p:RelOp/@EstimateCPU)', 'float') as sort_cpu
                      from #relop qs
                      where [relop].exist('/p:RelOp[(@PhysicalOp[.="Sort"])]') = 1
                  ) as x
             group by x.sqlhandle
         ) as y
    where ##blitzcacheprocs.sqlhandle = y.sqlhandle
      and spid = @@SPID
    option (recompile);

    if not EXISTS(select 1 / 0 from #statements as s where s.is_cursor = 1)
        begin

            raiserror (N'No cursor plans found, skipping', 0, 1) with nowait;

        end

    if EXISTS(select 1 / 0 from #statements as s where s.is_cursor = 1)
        begin

            raiserror (N'Cursor plans found, investigating', 0, 1) with nowait;

            raiserror (N'Checking for Optimistic cursors', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            update b
            set b.is_optimistic_cursor = 1
            from ##blitzcacheprocs b
                     join #statements as qs
                          on b.sqlhandle = qs.sqlhandle
                     cross apply qs.statement.nodes('/p:StmtCursor') as n1(fn)
            where spid = @@SPID
              and n1.fn.exist('//p:CursorPlan/@CursorConcurrency[.="Optimistic"]') = 1
              and qs.is_cursor = 1
            option (recompile);


            raiserror (N'Checking if cursor is Forward Only', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            update b
            set b.is_forward_only_cursor = 1
            from ##blitzcacheprocs b
                     join #statements as qs
                          on b.sqlhandle = qs.sqlhandle
                     cross apply qs.statement.nodes('/p:StmtCursor') as n1(fn)
            where spid = @@SPID
              and n1.fn.exist('//p:CursorPlan/@ForwardOnly[.="true"]') = 1
              and qs.is_cursor = 1
            option (recompile);

            raiserror (N'Checking if cursor is Fast Forward', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            update b
            set b.is_fast_forward_cursor = 1
            from ##blitzcacheprocs b
                     join #statements as qs
                          on b.sqlhandle = qs.sqlhandle
                     cross apply qs.statement.nodes('/p:StmtCursor') as n1(fn)
            where spid = @@SPID
              and n1.fn.exist('//p:CursorPlan/@CursorActualType[.="FastForward"]') = 1
              and qs.is_cursor = 1
            option (recompile);


            raiserror (N'Checking for Dynamic cursors', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            update b
            set b.is_cursor_dynamic = 1
            from ##blitzcacheprocs b
                     join #statements as qs
                          on b.sqlhandle = qs.sqlhandle
                     cross apply qs.statement.nodes('/p:StmtCursor') as n1(fn)
            where spid = @@SPID
              and n1.fn.exist('//p:CursorPlan/@CursorActualType[.="Dynamic"]') = 1
              and qs.is_cursor = 1
            option (recompile);

        end

    if @expertmode > 0
        begin
            raiserror (N'Checking for bad scans and plan forcing', 0, 1) with nowait;
            ;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            update b
            set b.is_table_scan  = x.is_table_scan,
                b.backwards_scan = x.backwards_scan,
                b.forced_index   = x.forced_index,
                b.forced_seek    = x.forced_seek,
                b.forced_scan    = x.forced_scan
            from ##blitzcacheprocs b
                     join (
                select qs.sqlhandle,
                       0                                         as is_table_scan,
                       q.n.exist('@ScanDirection[.="BACKWARD"]') as backwards_scan,
                       q.n.value('@ForcedIndex', 'bit')          as forced_index,
                       q.n.value('@ForceSeek', 'bit')            as forced_seek,
                       q.n.value('@ForceScan', 'bit')            as forced_scan
                from #relop qs
                         cross apply qs.relop.nodes('//p:IndexScan') as q(n)
                union all
                select qs.sqlhandle,
                       1                                         as is_table_scan,
                       q.n.exist('@ScanDirection[.="BACKWARD"]') as backwards_scan,
                       q.n.value('@ForcedIndex', 'bit')          as forced_index,
                       q.n.value('@ForceSeek', 'bit')            as forced_seek,
                       q.n.value('@ForceScan', 'bit')            as forced_scan
                from #relop qs
                         cross apply qs.relop.nodes('//p:TableScan') as q(n)
            ) as x on b.sqlhandle = x.sqlhandle
            where spid = @@SPID
            option (recompile);
        end;


    if @expertmode > 0
        begin
            raiserror (N'Checking for computed columns that reference scalar UDFs', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            update ##blitzcacheprocs
            set is_computed_scalar = x.computed_column_function
            from (
                     select qs.sqlhandle,
                            n.fn.value('count(distinct-values(//p:UserDefinedFunction[not(@IsClrFunction)]))',
                                       'INT') as computed_column_function
                     from #relop qs
                              cross apply relop.nodes(
                             '/p:RelOp/p:ComputeScalar/p:DefinedValues/p:DefinedValue/p:ScalarOperator') n(fn)
                     where n.fn.exist(
                                   '/p:RelOp/p:ComputeScalar/p:DefinedValues/p:DefinedValue/p:ColumnReference[(@ComputedColumn[.="1"])]') =
                           1
                 ) as x
            where ##blitzcacheprocs.sqlhandle = x.sqlhandle
              and spid = @@SPID
            option (recompile);
        end;


    raiserror (N'Checking for filters that reference scalar UDFs', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update ##blitzcacheprocs
    set is_computed_filter = x.filter_function
    from (
             select r.sqlhandle,
                    c.n.value('count(distinct-values(//p:UserDefinedFunction[not(@IsClrFunction)]))',
                              'INT') as filter_function
             from #relop as r
                      cross apply r.relop.nodes(
                     '/p:RelOp/p:Filter/p:Predicate/p:ScalarOperator/p:Compare/p:ScalarOperator/p:UserDefinedFunction') c(n)
         ) x
    where ##blitzcacheprocs.sqlhandle = x.sqlhandle
      and spid = @@SPID
    option (recompile);

    if @expertmode > 0
        begin
            raiserror (N'Checking modification queries that hit lots of indexes', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p),
                IndexOps as
                (
                select
                r.QueryHash,
                c.n.value('@PhysicalOp', 'VARCHAR(100)') as op_name,
                c.n.exist('@PhysicalOp[.="Index Insert"]') as ii,
                c.n.exist('@PhysicalOp[.="Index Update"]') as iu,
                c.n.exist('@PhysicalOp[.="Index Delete"]') as id,
                c.n.exist('@PhysicalOp[.="Clustered Index Insert"]') as cii,
                c.n.exist('@PhysicalOp[.="Clustered Index Update"]') as ciu,
                c.n.exist('@PhysicalOp[.="Clustered Index Delete"]') as cid,
                c.n.exist('@PhysicalOp[.="Table Insert"]') as ti,
                c.n.exist('@PhysicalOp[.="Table Update"]') as tu,
                c.n.exist('@PhysicalOp[.="Table Delete"]') as td
                from #relop as r
                cross apply r.relop.nodes('/p:RelOp') c(n)
                outer apply r.relop.nodes('/p:RelOp/p:ScalarInsert/p:Object') q (n)
                outer apply r.relop.nodes('/p:RelOp/p:Update/p:Object') o2(n)
                outer apply r.relop.nodes('/p:RelOp/p:SimpleUpdate/p:Object') o3(n)
                ), iops as
                (
                select ios.QueryHash,
                sum (convert (tinyint, ios.ii)) as index_insert_count,
                sum (convert (tinyint, ios.iu)) as index_update_count,
                sum (convert (tinyint, ios.id)) as index_delete_count,
                sum (convert (tinyint, ios.cii)) as cx_insert_count,
                sum (convert (tinyint, ios.ciu)) as cx_update_count,
                sum (convert (tinyint, ios.cid)) as cx_delete_count,
                sum (convert (tinyint, ios.ti)) as table_insert_count,
                sum (convert (tinyint, ios.tu)) as table_update_count,
                sum (convert (tinyint, ios.td)) as table_delete_count
                from IndexOps as ios
                where ios.op_name in ('Index Insert', 'Index Delete', 'Index Update',
                'Clustered Index Insert', 'Clustered Index Delete', 'Clustered Index Update',
                'Table Insert', 'Table Delete', 'Table Update')
                group by ios.QueryHash)
            update b
            set b.index_insert_count = iops.index_insert_count,
                b.index_update_count = iops.index_update_count,
                b.index_delete_count = iops.index_delete_count,
                b.cx_insert_count    = iops.cx_insert_count,
                b.cx_update_count    = iops.cx_update_count,
                b.cx_delete_count    = iops.cx_delete_count,
                b.table_insert_count = iops.table_insert_count,
                b.table_update_count = iops.table_update_count,
                b.table_delete_count = iops.table_delete_count
            from ##blitzcacheprocs as b
                     join iops on iops.queryhash = b.queryhash
            where spid = @@SPID
            option (recompile);
        end;


    if @expertmode > 0
        begin
            raiserror (N'Checking for Spatial index use', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            update ##blitzcacheprocs
            set is_spatial = x.is_spatial
            from (
                     select qs.sqlhandle,
                            1 as is_spatial
                     from #relop qs
                              cross apply relop.nodes('/p:RelOp//p:Object') n(fn)
                     where n.fn.exist('(@IndexKind[.="Spatial"])') = 1
                 ) as x
            where ##blitzcacheprocs.sqlhandle = x.sqlhandle
              and spid = @@SPID
            option (recompile);
        end;


    raiserror ('Checking for wonky Index Spools', 0, 1) with nowait;
    with xmlnamespaces ( 'http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p )
       , selects
        as ( select s.QueryHash
        from #statements as s
        where s.statement.exist('/p:StmtSimple/@StatementType[.="SELECT"]') = 1 )
       , spools
        as ( select distinct r.QueryHash
       , c.n.value('@EstimateRows'
       , 'FLOAT') as estimated_rows
       , c.n.value('@EstimateIO'
       , 'FLOAT') as estimated_io
       , c.n.value('@EstimateCPU'
       , 'FLOAT') as estimated_cpu
       , c.n.value('@EstimateRebinds'
       , 'FLOAT') as estimated_rebinds
        from #relop as r
        join selects as s
        on s.QueryHash = r.QueryHash
        cross apply r.relop.nodes('/p:RelOp') as c(n)
        where r.relop.exist('/p:RelOp[@PhysicalOp="Index Spool" and @LogicalOp="Eager Spool"]') = 1
        )
    update b
    set b.index_spool_rows = sp.estimated_rows,
        b.index_spool_cost = ((sp.estimated_io * sp.estimated_cpu) *
                              case when sp.estimated_rebinds < 1 then 1 else sp.estimated_rebinds end)
    from ##blitzcacheprocs b
             join spools sp
                  on sp.queryhash = b.queryhash
    option (recompile);

    raiserror ('Checking for wonky Table Spools', 0, 1) with nowait;
    with xmlnamespaces ( 'http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p )
       , selects
        as ( select s.QueryHash
        from #statements as s
        where s.statement.exist('/p:StmtSimple/@StatementType[.="SELECT"]') = 1 )
       , spools
        as ( select distinct r.QueryHash
       , c.n.value('@EstimateRows'
       , 'FLOAT') as estimated_rows
       , c.n.value('@EstimateIO'
       , 'FLOAT') as estimated_io
       , c.n.value('@EstimateCPU'
       , 'FLOAT') as estimated_cpu
       , c.n.value('@EstimateRebinds'
       , 'FLOAT') as estimated_rebinds
        from #relop as r
        join selects as s
        on s.QueryHash = r.QueryHash
        cross apply r.relop.nodes('/p:RelOp') as c(n)
        where r.relop.exist('/p:RelOp[@PhysicalOp="Table Spool" and @LogicalOp="Lazy Spool"]') = 1
        )
    update b
    set b.table_spool_rows = (sp.estimated_rows * sp.estimated_rebinds),
        b.table_spool_cost = ((sp.estimated_io * sp.estimated_cpu * sp.estimated_rows) *
                              case when sp.estimated_rebinds < 1 then 1 else sp.estimated_rebinds end)
    from ##blitzcacheprocs b
             join spools sp
                  on sp.queryhash = b.queryhash
    option (recompile);


    raiserror ('Checking for selects that cause non-spill and index spool writes', 0, 1) with nowait;
    with xmlnamespaces ( 'http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p )
       , selects
        as ( select convert (binary (8)
       , right ('0000000000000000'
        + SUBSTRING(s.statement.value('(/p:StmtSimple/@QueryHash)[1]'
       , 'VARCHAR(18)')
       , 3
       , 18)
       , 16)
       , 2) as QueryHash
        from #statements as s
        join ##BlitzCacheProcs b
        on s.QueryHash = b.QueryHash
        where b.index_spool_rows is null
        and b.index_spool_cost is null
        and b.table_spool_cost is null
        and b.table_spool_rows is null
        and b.is_big_spills is null
        and b.AverageWrites
       > 1024.
        and s.statement.exist('/p:StmtSimple/@StatementType[.="SELECT"]') = 1
        )
    update b
    set b.select_with_writes = 1
    from ##blitzcacheprocs b
             join selects as s
                  on s.queryhash = b.queryhash
                      and b.averagewrites > 1024.;

/* 2012+ only */
    if @v >= 11
        begin

            raiserror (N'Checking for forced serialization', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            update ##blitzcacheprocs
            set is_forced_serial = 1
            from #query_plan qp
            where qp.sqlhandle = ##blitzcacheprocs.sqlhandle
              and spid = @@SPID
              and query_plan.exist('/p:QueryPlan/@NonParallelPlanReason') = 1
              and (##blitzcacheprocs.is_parallel = 0 or ##blitzcacheprocs.is_parallel is null)
            option (recompile);

            if @expertmode > 0
                begin
                    raiserror (N'Checking for ColumnStore queries operating in Row Mode instead of Batch Mode', 0, 1) with nowait;
                    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
                    update ##blitzcacheprocs
                    set columnstore_row_mode = x.is_row_mode
                    from (
                             select qs.sqlhandle,
                                    relop.exist('/p:RelOp[(@EstimatedExecutionMode[.="Row"])]') as is_row_mode
                             from #relop qs
                             where [relop].exist('/p:RelOp/p:IndexScan[(@Storage[.="ColumnStore"])]') = 1
                         ) as x
                    where ##blitzcacheprocs.sqlhandle = x.sqlhandle
                      and spid = @@SPID
                    option (recompile);
                end;

        end;

/* 2014+ only */
    if @v >= 12
        begin
            raiserror ('Checking for downlevel cardinality estimators being used on SQL Server 2014.', 0, 1) with nowait;

            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            update p
            set downlevel_estimator = case
                                          when statement.value('min(//p:StmtSimple/@CardinalityEstimationModelVersion)',
                                                               'int') < (@v * 10) then 1 end
            from ##blitzcacheprocs p
                     join #statements s on p.queryhash = s.queryhash
            where spid = @@SPID
            option (recompile);
        end;

/* 2016+ only */
    if @v >= 13 and @expertmode > 0
        begin
            raiserror ('Checking for row level security in 2016 only', 0, 1) with nowait;

            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            update p
            set p.is_row_level = 1
            from ##blitzcacheprocs p
                     join #statements s on p.queryhash = s.queryhash
            where spid = @@SPID
              and statement.exist('/p:StmtSimple/@SecurityPolicyApplied[.="true"]') = 1
            option (recompile);
        end;

/* 2017+ only */
    if @v >= 14 or (@v = 13 and @build >= 5026)
        begin

            if @expertmode > 0
                begin
                    raiserror ('Gathering stats information', 0, 1) with nowait;
                    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
                    insert
                    into #stats_agg
                    select qp.sqlhandle,
                           x.c.value('@LastUpdate', 'DATETIME2(7)')  as lastupdate,
                           x.c.value('@ModificationCount', 'BIGINT') as modificationcount,
                           x.c.value('@SamplingPercent', 'FLOAT')    as samplingpercent,
                           x.c.value('@Statistics', 'NVARCHAR(258)') as [Statistics],
                           x.c.value('@Table', 'NVARCHAR(258)')      as [Table],
                           x.c.value('@Schema', 'NVARCHAR(258)')     as [Schema],
                           x.c.value('@Database', 'NVARCHAR(258)')   as [Database]
                    from #query_plan as qp
                             cross apply qp.query_plan.nodes('//p:OptimizerStatsUsage/p:StatisticsInfo') x (c)
                    option (recompile);


                    raiserror ('Checking for stale stats', 0, 1) with nowait;
                    with stale_stats as (
                        select sa.sqlhandle
                        from #stats_agg as sa
                        group by sa.sqlhandle
                        having MAX(sa.lastupdate) <= DATEADD(day, -7, SYSDATETIME())
                           and AVG(sa.modificationcount) >= 100000
                    )
                    update b
                    set stale_stats = 1
                    from ##blitzcacheprocs b
                             join stale_stats os
                                  on b.sqlhandle = os.sqlhandle
                                      and b.spid = @@SPID
                    option (recompile);
                end;

            if @v >= 14 and @expertmode > 0
                begin
                    raiserror ('Checking for adaptive joins', 0, 1) with nowait;
                    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p),
                        aj as (
                        select
                        SqlHandle
                        from #relop as r
                        cross apply r.relop.nodes('//p:RelOp') x(c)
                        where x.c.exist('@IsAdaptive[.=1]') = 1
                        )
                    update b
                    set b.is_adaptive = 1
                    from ##blitzcacheprocs b
                             join aj
                                  on b.sqlhandle = aj.sqlhandle
                                      and b.spid = @@SPID
                    option (recompile);
                end;

            if ((@v >= 14
                or (@v = 13 and @build >= 5026)
                or (@v = 12 and @build >= 6024))
                and @expertmode > 0)
                begin
                    ;
                    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p),
                        row_goals as (
                        select qs.QueryHash
                        from #relop qs
                        where relop.value('sum(/p:RelOp/@EstimateRowsWithoutRowGoal)', 'float') > 0
                        )
                    update b
                    set b.is_row_goal = 1
                    from ##blitzcacheprocs b
                             join row_goals
                                  on b.queryhash = row_goals.queryhash
                                      and b.spid = @@SPID
                    option (recompile);
                end;

        end;


/* END Testing using XML nodes to speed up processing */
    raiserror (N'Gathering additional plan level information', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update ##blitzcacheprocs
    set numberofdistinctplans = distinct_plan_count,
        numberofplans         = number_of_plans,
        plan_multiple_plans   = case when distinct_plan_count < number_of_plans then number_of_plans end
    from (
             select COUNT(distinct queryhash) as distinct_plan_count,
                    COUNT(queryhash)          as number_of_plans,
                    queryhash
             from ##blitzcacheprocs
             where spid = @@SPID
             group by queryhash
         ) as x
    where ##blitzcacheprocs.queryhash = x.queryhash
    option (recompile);

/* Update to grab stored procedure name for individual statements */
    raiserror (N'Attempting to get stored procedure name for individual statements', 0, 1) with nowait;
    update p
    set querytype = querytype + ' (parent ' +
                    + QUOTENAME(OBJECT_SCHEMA_NAME(s.object_id, s.database_id))
        + '.'
        + QUOTENAME(OBJECT_NAME(s.object_id, s.database_id)) + ')'
    from ##blitzcacheprocs p
             join sys.dm_exec_procedure_stats s on p.sqlhandle = s.sql_handle
    where querytype = 'Statement'
      and spid = @@SPID
    option (recompile);

    raiserror (N'Attempting to get function name for individual statements', 0, 1) with nowait;
    declare @function_update_sql nvarchar(max) = N''
    if EXISTS(select 1 / 0 from sys.all_objects as o where o.name = 'dm_exec_function_stats')
        begin
            set @function_update_sql = @function_update_sql + N'
     UPDATE  p
     SET     QueryType = QueryType + '' (parent '' +
                         + QUOTENAME(OBJECT_SCHEMA_NAME(s.object_id, s.database_id))
                         + ''.''
                         + QUOTENAME(OBJECT_NAME(s.object_id, s.database_id)) + '')''
     FROM    ##BlitzCacheProcs p
             JOIN sys.dm_exec_function_stats s ON p.SqlHandle = s.sql_handle
     WHERE   QueryType = ''Statement''
     AND SPID = @@SPID
     OPTION (RECOMPILE);
     '
            exec sys.sp_executesql @function_update_sql
        end


/* Trace Flag Checks 2012 SP3, 2014 SP2 and 2016 SP1 only)*/
    if @v >= 11
        begin

            raiserror (N'Trace flag checks', 0, 1) with nowait;
            ;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
               , tf_pretty as (
                select qp.QueryHash
               , qp.SqlHandle
               , q.n.value('@Value'
               , 'INT') as trace_flag
               , q.n.value('@Scope'
               , 'VARCHAR(10)') as scope
                from #query_plan qp
                cross apply qp.query_plan.nodes('/p:QueryPlan/p:TraceFlags/p:TraceFlag') as q (n)
                )
            insert into #trace_flags
            select distinct tf1.sqlhandle,
                            tf1.queryhash,
                            STUFF((
                                      select distinct ', ' + CONVERT(varchar(5), tf2.trace_flag)
                                      from tf_pretty as tf2
                                      where tf1.sqlhandle = tf2.sqlhandle
                                        and tf1.queryhash = tf2.queryhash
                                        and tf2.scope = 'Global'
                                      for xml path(N'')), 1, 2, N''
                                ) as global_trace_flags,
                            STUFF((
                                      select distinct ', ' + CONVERT(varchar(5), tf2.trace_flag)
                                      from tf_pretty as tf2
                                      where tf1.sqlhandle = tf2.sqlhandle
                                        and tf1.queryhash = tf2.queryhash
                                        and tf2.scope = 'Session'
                                      for xml path(N'')), 1, 2, N''
                                ) as session_trace_flags
            from tf_pretty as tf1
            option (recompile);

            update p
            set p.trace_flags_session = tf.session_trace_flags
            from ##blitzcacheprocs p
                     join #trace_flags tf on tf.queryhash = p.queryhash
            where spid = @@SPID
            option (recompile);

        end;


    raiserror (N'Checking for MSTVFs', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update b
    set b.is_mstvf = 1
    from #relop as r
             join ##blitzcacheprocs as b
                  on b.sqlhandle = r.sqlhandle
    where r.relop.exist('/p:RelOp[(@EstimateRows="100" or @EstimateRows="1") and @LogicalOp="Table-valued function"]') =
          1
    option (recompile);


    if @expertmode > 0
        begin
            raiserror (N'Checking for many to many merge joins', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            update b
            set b.is_mm_join = 1
            from #relop as r
                     join ##blitzcacheprocs as b
                          on b.sqlhandle = r.sqlhandle
            where r.relop.exist('/p:RelOp/p:Merge/@ManyToMany[.="1"]') = 1
            option (recompile);
        end;


    if @expertmode > 0
        begin
            raiserror (N'Is Paul White Electric?', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p),
                is_paul_white_electric as (
                select 1 as [is_paul_white_electric],
                r.SqlHandle
                from #relop as r
                cross apply r.relop.nodes('//p:RelOp') c(n)
                where c.n.exist('@PhysicalOp[.="Switch"]') = 1
                )
            update b
            set b.is_paul_white_electric = ipwe.is_paul_white_electric
            from ##blitzcacheprocs as b
                     join is_paul_white_electric ipwe
                          on ipwe.sqlhandle = b.sqlhandle
            where b.spid = @@SPID
            option (recompile);
        end;


    raiserror (N'Checking for non-sargable predicates', 0, 1) with nowait;
    with xmlnamespaces ( 'http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p )
       , nsarg
        as ( select r.QueryHash
       , 1 as fn
       , 0 as jo
       , 0 as lk
        from #relop as r
        cross apply r.relop.nodes('/p:RelOp/p:IndexScan/p:Predicate/p:ScalarOperator/p:Compare/p:ScalarOperator') as ca(x)
        where ( ca.x.exist('//p:ScalarOperator/p:Intrinsic/@FunctionName') = 1
        or ca.x.exist('//p:ScalarOperator/p:IF') = 1 )
        union all
        select r.QueryHash
       , 0 as fn
       , 1 as jo
       , 0 as lk
        from #relop as r
        cross apply r.relop.nodes('/p:RelOp//p:ScalarOperator') as ca(x)
        where r.relop.exist('/p:RelOp[contains(@LogicalOp, "Join")]') = 1
        and ca.x.exist('//p:ScalarOperator[contains(@ScalarString, "Expr")]') = 1
        union all
        select r.QueryHash
       , 0 as fn
       , 0 as jo
       , 1 as lk
        from #relop as r
        cross apply r.relop.nodes('/p:RelOp/p:IndexScan/p:Predicate/p:ScalarOperator') as ca(x)
        cross apply ca.x.nodes('//p:Const') as co(x)
        where ca.x.exist('//p:ScalarOperator/p:Intrinsic/@FunctionName[.="like"]') = 1
        and ( ( co.x.value('substring(@ConstValue, 1, 1)'
       , 'VARCHAR(100)') <> 'N'
        and co.x.value('substring(@ConstValue, 2, 1)'
       , 'VARCHAR(100)') = '%' )
        or ( co.x.value('substring(@ConstValue, 1, 1)'
       , 'VARCHAR(100)') = 'N'
        and co.x.value('substring(@ConstValue, 3, 1)'
       , 'VARCHAR(100)') = '%' )))
       , d_nsarg
        as ( select distinct
        nsarg.QueryHash
        from nsarg
        where nsarg.fn = 1
        or nsarg.jo = 1
        or nsarg.lk = 1 )
    update b
    set b.is_nonsargable = 1
    from d_nsarg as d
             join ##blitzcacheprocs as b
                  on b.queryhash = d.queryhash
    where b.spid = @@SPID
    option ( recompile );

/*Begin implicit conversion and parameter info */

    raiserror (N'Getting information about implicit conversions and stored proc parameters', 0, 1) with nowait;

    raiserror (N'Getting variable info', 0, 1) with nowait;
    with xmlnamespaces ( 'http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p )
    insert
    #variable_info
    (
    spid
    ,
    queryhash
    ,
    sqlhandle
    ,
    proc_name
    ,
    variable_name
    ,
    variable_datatype
    ,
    compile_time_value
    )
    select distinct @@SPID,
                    qp.queryhash,
                    qp.sqlhandle,
                    b.querytype                                           as proc_name,
                    q.n.value('@Column', 'NVARCHAR(258)')                 as variable_name,
                    q.n.value('@ParameterDataType', 'NVARCHAR(258)')      as variable_datatype,
                    q.n.value('@ParameterCompiledValue', 'NVARCHAR(258)') as compile_time_value
    from #query_plan as qp
             join ##blitzcacheprocs as b
                  on (b.querytype = 'adhoc' and b.queryhash = qp.queryhash)
                      or (b.querytype <> 'adhoc' and b.sqlhandle = qp.sqlhandle)
             cross apply qp.query_plan.nodes('//p:QueryPlan/p:ParameterList/p:ColumnReference') as q(n)
    where b.spid = @@SPID
    option (recompile);


    raiserror (N'Getting conversion info', 0, 1) with nowait;
    with xmlnamespaces ( 'http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p )
    insert
    #conversion_info
    (
    spid
    ,
    queryhash
    ,
    sqlhandle
    ,
    proc_name
    ,
    expression
    )
    select distinct @@SPID,
                    qp.queryhash,
                    qp.sqlhandle,
                    b.querytype                                 as proc_name,
                    qq.c.value('@Expression', 'NVARCHAR(4000)') as expression
    from #query_plan as qp
             join ##blitzcacheprocs as b
                  on (b.querytype = 'adhoc' and b.queryhash = qp.queryhash)
                      or (b.querytype <> 'adhoc' and b.sqlhandle = qp.sqlhandle)
             cross apply qp.query_plan.nodes('//p:QueryPlan/p:Warnings/p:PlanAffectingConvert') as qq(c)
    where qq.c.exist('@ConvertIssue[.="Seek Plan"]') = 1
      and qp.queryhash is not null
      and b.implicit_conversions = 1
      and b.spid = @@SPID
    option (recompile);


    raiserror (N'Parsing conversion info', 0, 1) with nowait;
    insert #stored_proc_info (spid, sqlhandle, queryhash, proc_name, variable_name, variable_datatype,
                              converted_column_name, column_name, converted_to, compile_time_value)
    select @@SPID                                                                                                    as spid,
           ci.sqlhandle,
           ci.queryhash,
           REPLACE(REPLACE(REPLACE(ci.proc_name, ')', ''), 'Statement (parent ', ''), 'Procedure or Function: ',
                   '')                                                                                               as proc_name,
           case
               when ci.at_charindex > 0
                   and ci.bracket_charindex > 0
                   then SUBSTRING(ci.expression, ci.at_charindex, ci.bracket_charindex)
               else N'**no_variable**'
               end                                                                                                   as variable_name,
           N'**no_variable**'                                                                                        as variable_datatype,
           case
               when ci.at_charindex = 0
                   and ci.comma_charindex > 0
                   and ci.second_comma_charindex > 0
                   then SUBSTRING(ci.expression, ci.comma_charindex, ci.second_comma_charindex)
               else N'**no_column**'
               end                                                                                                   as converted_column_name,
           case
               when ci.at_charindex = 0
                   and ci.equal_charindex > 0
                   and ci.convert_implicit_charindex = 0
                   then SUBSTRING(ci.expression, ci.equal_charindex, 4000)
               when ci.at_charindex = 0
                   and (ci.equal_charindex - 1) > 0
                   and ci.convert_implicit_charindex > 0
                   then SUBSTRING(ci.expression, 0, ci.equal_charindex - 1)
               when ci.at_charindex > 0
                   and ci.comma_charindex > 0
                   and ci.second_comma_charindex > 0
                   then SUBSTRING(ci.expression, ci.comma_charindex, ci.second_comma_charindex)
               else N'**no_column **'
               end                                                                                                   as column_name,
           case
               when ci.paren_charindex > 0
                   and ci.comma_paren_charindex > 0
                   then SUBSTRING(ci.expression, ci.paren_charindex, ci.comma_paren_charindex)
               end                                                                                                   as converted_to,
           case
               when ci.at_charindex = 0
                   and ci.convert_implicit_charindex = 0
                   and ci.proc_name = 'Statement'
                   then SUBSTRING(ci.expression, ci.equal_charindex, 4000)
               else '**idk_man**'
               end                                                                                                   as compile_time_value
    from #conversion_info as ci
    option (recompile);


    raiserror (N'Updating variables for inserted procs', 0, 1) with nowait;
    update sp
    set sp.variable_datatype  = vi.variable_datatype,
        sp.compile_time_value = vi.compile_time_value
    from #stored_proc_info as sp
             join #variable_info as vi
                  on (sp.proc_name = 'adhoc' and sp.queryhash = vi.queryhash)
                      or (sp.proc_name <> 'adhoc' and sp.sqlhandle = vi.sqlhandle)
                         and sp.variable_name = vi.variable_name
    option (recompile);


    raiserror (N'Inserting variables for other procs', 0, 1) with nowait;
    insert #stored_proc_info
    (spid, sqlhandle, queryhash, variable_name, variable_datatype, compile_time_value, proc_name)
    select vi.spid,
           vi.sqlhandle,
           vi.queryhash,
           vi.variable_name,
           vi.variable_datatype,
           vi.compile_time_value,
           REPLACE(REPLACE(REPLACE(vi.proc_name, ')', ''), 'Statement (parent ', ''), 'Procedure or Function: ',
                   '') as proc_name
    from #variable_info as vi
    where not EXISTS
        (
            select *
            from #stored_proc_info as sp
            where (sp.proc_name = 'adhoc' and sp.queryhash = vi.queryhash)
               or (sp.proc_name <> 'adhoc' and sp.sqlhandle = vi.sqlhandle)
        )
    option (recompile);


    raiserror (N'Updating procs', 0, 1) with nowait;
    update s
    set s.variable_datatype  = case
                                   when s.variable_datatype like '%(%)%'
                                       then LEFT(s.variable_datatype, CHARINDEX('(', s.variable_datatype) - 1)
                                   else s.variable_datatype
        end,
        s.converted_to       = case
                                   when s.converted_to like '%(%)%'
                                       then LEFT(s.converted_to, CHARINDEX('(', s.converted_to) - 1)
                                   else s.converted_to
            end,
        s.compile_time_value = case
                                   when s.compile_time_value like '%(%)%'
                                       then SUBSTRING(s.compile_time_value,
                                                      CHARINDEX('(', s.compile_time_value) + 1,
                                                      CHARINDEX(')', s.compile_time_value) - 1 -
                                                      CHARINDEX('(', s.compile_time_value)
                                       )
                                   when variable_datatype not in ('bit', 'tinyint', 'smallint', 'int', 'bigint')
                                       and s.variable_datatype not like '%binary%'
                                       and s.compile_time_value not like 'N''%'''
                                       and s.compile_time_value not like '''%'''
                                       and s.compile_time_value <> s.column_name
                                       and s.compile_time_value <> '**idk_man**'
                                       then QUOTENAME(compile_time_value, '''')
                                   else s.compile_time_value
            end
    from #stored_proc_info as s
    option (recompile);


    raiserror (N'Updating SET options', 0, 1) with nowait;
    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update s
    set set_options = set_options.ansi_set_options
    from #stored_proc_info as s
             join (
        select x.sqlhandle,
               N'SET ANSI_NULLS ' + case when [ANSI_NULLS] = 'true' then N'ON ' else N'OFF ' end + NCHAR(10) +
               N'SET ANSI_PADDING ' + case when [ANSI_PADDING] = 'true' then N'ON ' else N'OFF ' end + NCHAR(10) +
               N'SET ANSI_WARNINGS ' + case when [ANSI_WARNINGS] = 'true' then N'ON ' else N'OFF ' end + NCHAR(10) +
               N'SET ARITHABORT ' + case when [ARITHABORT] = 'true' then N'ON ' else N' OFF ' end + NCHAR(10) +
               N'SET CONCAT_NULL_YIELDS_NULL ' +
               case when [CONCAT_NULL_YIELDS_NULL] = 'true' then N'ON ' else N'OFF ' end + NCHAR(10) +
               N'SET NUMERIC_ROUNDABORT ' + case when [NUMERIC_ROUNDABORT] = 'true' then N'ON ' else N'OFF ' end +
               NCHAR(10) +
               N'SET QUOTED_IDENTIFIER ' +
               case when [QUOTED_IDENTIFIER] = 'true' then N'ON ' else N'OFF ' + NCHAR(10) end as [ansi_set_options]
        from (
                 select s.sqlhandle,
                        so.o.value('@ANSI_NULLS', 'NVARCHAR(20)')              as [ANSI_NULLS],
                        so.o.value('@ANSI_PADDING', 'NVARCHAR(20)')            as [ANSI_PADDING],
                        so.o.value('@ANSI_WARNINGS', 'NVARCHAR(20)')           as [ANSI_WARNINGS],
                        so.o.value('@ARITHABORT', 'NVARCHAR(20)')              as [ARITHABORT],
                        so.o.value('@CONCAT_NULL_YIELDS_NULL', 'NVARCHAR(20)') as [CONCAT_NULL_YIELDS_NULL],
                        so.o.value('@NUMERIC_ROUNDABORT', 'NVARCHAR(20)')      as [NUMERIC_ROUNDABORT],
                        so.o.value('@QUOTED_IDENTIFIER', 'NVARCHAR(20)')       as [QUOTED_IDENTIFIER]
                 from #statements as s
                          cross apply s.statement.nodes('//p:StatementSetOptions') as so(o)
             ) as x
    ) as set_options on set_options.sqlhandle = s.sqlhandle
    option (recompile);


    raiserror (N'Updating conversion XML', 0, 1) with nowait;
    with precheck as (
        select spi.spid,
               spi.sqlhandle,
               spi.proc_name,
               (select case
                           when spi.proc_name <> 'Statement'
                               then N'The stored procedure ' + spi.proc_name
                           else N'This ad hoc statement'
                           end
                           + N' had the following implicit conversions: '
                           + CHAR(10)
                           + STUFF((
                                       select distinct @nl
                                                           + case
                                                                 when spi2.variable_name <> N'**no_variable**'
                                                                     then N'The variable '
                                                                 when spi2.variable_name = N'**no_variable**' and
                                                                      (spi2.column_name = spi2.converted_column_name or
                                                                       spi2.column_name like '%CONVERT_IMPLICIT%')
                                                                     then N'The compiled value '
                                                                 when spi2.column_name like '%Expr%'
                                                                     then 'The expression '
                                                                 else N'The column '
                                                           end
                                                           + case
                                                                 when spi2.variable_name <> N'**no_variable**'
                                                                     then spi2.variable_name
                                                                 when spi2.variable_name = N'**no_variable**' and
                                                                      (spi2.column_name = spi2.converted_column_name or
                                                                       spi2.column_name like '%CONVERT_IMPLICIT%')
                                                                     then spi2.compile_time_value
                                                                 else spi2.column_name
                                                           end
                                                           + N' has a data type of '
                                                           + case
                                                                 when spi2.variable_datatype = N'**no_variable**'
                                                                     then spi2.converted_to
                                                                 else spi2.variable_datatype
                                                           end
                                                           + N' which caused implicit conversion on the column '
                                                           + case
                                                                 when spi2.column_name like N'%CONVERT_IMPLICIT%'
                                                                     then spi2.converted_column_name
                                                                 when spi2.column_name = N'**no_column**'
                                                                     then spi2.converted_column_name
                                                                 when spi2.converted_column_name = N'**no_column**'
                                                                     then spi2.column_name
                                                                 when spi2.column_name <> spi2.converted_column_name
                                                                     then spi2.converted_column_name
                                                                 else spi2.column_name
                                                           end
                                                           + case
                                                                 when spi2.variable_name = N'**no_variable**' and
                                                                      (spi2.column_name = spi2.converted_column_name or
                                                                       spi2.column_name like '%CONVERT_IMPLICIT%')
                                                                     then N''
                                                                 when spi2.column_name like '%Expr%'
                                                                     then N''
                                                                 when spi2.compile_time_value not in ('**declared in proc**', '**idk_man**')
                                                                     and spi2.compile_time_value <> spi2.column_name
                                                                     then ' with the value ' + RTRIM(spi2.compile_time_value)
                                                                 else N''
                                                           end
                                                           + '.'
                                       from #stored_proc_info as spi2
                                       where spi.sqlhandle = spi2.sqlhandle
                                       for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 1, N'')
                           as [processing-instruction(ClickMe)]
                for xml path(''), type)
                   as implicit_conversion_info
        from #stored_proc_info as spi
        group by spi.spid, spi.sqlhandle, spi.proc_name
    )
    update b
    set b.implicit_conversion_info = pk.implicit_conversion_info
    from ##blitzcacheprocs as b
             join precheck pk
                  on pk.sqlhandle = b.sqlhandle
                      and pk.spid = b.spid
    option (recompile);


    raiserror (N'Updating cached parameter XML for stored procs', 0, 1) with nowait;
    with precheck as (
        select spi.spid,
               spi.sqlhandle,
               spi.proc_name,
               (select set_options
                           + @nl
                           + @nl
                           + N'EXEC '
                           + spi.proc_name
                           + N' '
                           + STUFF((
                                       select distinct N', '
                                                           + case
                                                                 when spi2.variable_name <> N'**no_variable**' and
                                                                      spi2.compile_time_value <> N'**idk_man**'
                                                                     then spi2.variable_name + N' = '
                                                                 else @nl +
                                                                      N' We could not find any cached parameter values for this stored proc. '
                                                           end
                                                           + case
                                                                 when spi2.variable_name = N'**no_variable**' or
                                                                      spi2.compile_time_value = N'**idk_man**'
                                                                     then @nl + N'More info on possible reasons: https://BrentOzar.com/go/noplans '
                                                                 when spi2.compile_time_value = N'NULL'
                                                                     then spi2.compile_time_value
                                                                 else RTRIM(spi2.compile_time_value)
                                                           end
                                       from #stored_proc_info as spi2
                                       where spi.sqlhandle = spi2.sqlhandle
                                         and spi2.proc_name <> N'Statement'
                                       for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 1, N'')
                           as [processing-instruction(ClickMe)]
                for xml path(''), type)
                   as cached_execution_parameters
        from #stored_proc_info as spi
        group by spi.spid, spi.sqlhandle, spi.proc_name, spi.set_options
    )
    update b
    set b.cached_execution_parameters = pk.cached_execution_parameters
    from ##blitzcacheprocs as b
             join precheck pk
                  on pk.sqlhandle = b.sqlhandle
                      and pk.spid = b.spid
    where b.querytype <> N'Statement'
    option (recompile);


    raiserror (N'Updating cached parameter XML for statements', 0, 1) with nowait;
    with precheck as (
        select spi.spid,
               spi.sqlhandle,
               spi.proc_name,
               (select set_options
                           + @nl
                           + @nl
                           + N' See QueryText column for full query text'
                           + @nl
                           + @nl
                           + STUFF((
                                       select distinct N', '
                                                           + case
                                                                 when spi2.variable_name <> N'**no_variable**' and
                                                                      spi2.compile_time_value <> N'**idk_man**'
                                                                     then spi2.variable_name + N' = '
                                                                 else @nl +
                                                                      N' We could not find any cached parameter values for this stored proc. '
                                                           end
                                                           + case
                                                                 when spi2.variable_name = N'**no_variable**' or
                                                                      spi2.compile_time_value = N'**idk_man**'
                                                                     then @nl +
                                                                          N' More info on possible reasons: https://BrentOzar.com/go/noplans '
                                                                 when spi2.compile_time_value = N'NULL'
                                                                     then spi2.compile_time_value
                                                                 else RTRIM(spi2.compile_time_value)
                                                           end
                                       from #stored_proc_info as spi2
                                       where spi.sqlhandle = spi2.sqlhandle
                                         and spi2.proc_name = N'Statement'
                                         and spi2.variable_name not like N'%msparam%'
                                       for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 1, N'')
                           as [processing-instruction(ClickMe)]
                for xml path(''), type)
                   as cached_execution_parameters
        from #stored_proc_info as spi
        group by spi.spid, spi.sqlhandle, spi.proc_name, spi.set_options
    )
    update b
    set b.cached_execution_parameters = pk.cached_execution_parameters
    from ##blitzcacheprocs as b
             join precheck pk
                  on pk.sqlhandle = b.sqlhandle
                      and pk.spid = b.spid
    where b.querytype = N'Statement'
    option (recompile);

    raiserror (N'Filling in implicit conversion and cached plan parameter info', 0, 1) with nowait;
    update b
    set b.implicit_conversion_info    = case
                                            when b.implicit_conversion_info is null
                                                or CONVERT(nvarchar(max), b.implicit_conversion_info) = N''
                                                then '<?NoNeedToClickMe -- N/A --?>'
                                            else b.implicit_conversion_info end,
        b.cached_execution_parameters = case
                                            when b.cached_execution_parameters is null
                                                or CONVERT(nvarchar(max), b.cached_execution_parameters) = N''
                                                then '<?NoNeedToClickMe -- N/A --?>'
                                            else b.cached_execution_parameters end
    from ##blitzcacheprocs as b
    where b.spid = @@SPID
    option (recompile);

    /*End implicit conversion and parameter info*/

/*Begin Missing Index*/
    if EXISTS(select 1 / 0
              from ##blitzcacheprocs as bbcp
              where bbcp.missing_index_count > 0
                 or bbcp.index_spool_cost > 0
                 or bbcp.index_spool_rows > 0
                  and bbcp.spid = @@SPID)
        begin
            raiserror (N'Inserting to #missing_index_xml', 0, 1) with nowait;
            with xmlnamespaces ( 'http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p )
            insert
            #missing_index_xml
            select qp.queryhash,
                   qp.sqlhandle,
                   c.mg.value('@Impact', 'FLOAT') as impact,
                   c.mg.query('.')                as cmg
            from #query_plan as qp
                     cross apply qp.query_plan.nodes('//p:MissingIndexes/p:MissingIndexGroup') as c(mg)
            where qp.queryhash is not null
            option (recompile);

            raiserror (N'Inserting to #missing_index_schema', 0, 1) with nowait;
            with xmlnamespaces ( 'http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p )
            insert
            #missing_index_schema
            select mix.queryhash,
                   mix.sqlhandle,
                   mix.impact,
                   c.mi.value('@Database', 'NVARCHAR(128)'),
                   c.mi.value('@Schema', 'NVARCHAR(128)'),
                   c.mi.value('@Table', 'NVARCHAR(128)'),
                   c.mi.query('.')
            from #missing_index_xml as mix
                     cross apply mix.index_xml.nodes('//p:MissingIndex') as c(mi)
            option (recompile);

            raiserror (N'Inserting to #missing_index_usage', 0, 1) with nowait;
            with xmlnamespaces ( 'http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p )
            insert
            #missing_index_usage
            select ms.queryhash,
                   ms.sqlhandle,
                   ms.impact,
                   ms.database_name,
                   ms.schema_name,
                   ms.table_name,
                   c.cg.value('@Usage', 'NVARCHAR(128)'),
                   c.cg.query('.')
            from #missing_index_schema ms
                     cross apply ms.index_xml.nodes('//p:ColumnGroup') as c(cg)
            option (recompile);

            raiserror (N'Inserting to #missing_index_detail', 0, 1) with nowait;
            with xmlnamespaces ( 'http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p )
            insert
            #missing_index_detail
            select miu.queryhash,
                   miu.sqlhandle,
                   miu.impact,
                   miu.database_name,
                   miu.schema_name,
                   miu.table_name,
                   miu.usage,
                   c.c.value('@Name', 'NVARCHAR(128)')
            from #missing_index_usage as miu
                     cross apply miu.index_xml.nodes('//p:Column') as c(c)
            option (recompile);

            raiserror (N'Inserting to missing indexes to #missing_index_pretty', 0, 1) with nowait;
            insert #missing_index_pretty
            (queryhash, sqlhandle, impact, database_name, schema_name, table_name, equality, inequality, include,
             executions, query_cost, creation_hours, is_spool)
            select distinct m.queryhash,
                            m.sqlhandle,
                            m.impact,
                            m.database_name,
                            m.schema_name,
                            m.table_name
                    ,
                            STUFF((select distinct N', ' + ISNULL(m2.column_name, '') as column_name
                                   from #missing_index_detail as m2
                                   where m2.usage = 'EQUALITY'
                                     and m.queryhash = m2.queryhash
                                     and m.sqlhandle = m2.sqlhandle
                                     and m.impact = m2.impact
                                     and m.database_name = m2.database_name
                                     and m.schema_name = m2.schema_name
                                     and m.table_name = m2.table_name
                                   for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 2, N'') as equality
                    ,
                            STUFF((select distinct N', ' + ISNULL(m2.column_name, '') as column_name
                                   from #missing_index_detail as m2
                                   where m2.usage = 'INEQUALITY'
                                     and m.queryhash = m2.queryhash
                                     and m.sqlhandle = m2.sqlhandle
                                     and m.impact = m2.impact
                                     and m.database_name = m2.database_name
                                     and m.schema_name = m2.schema_name
                                     and m.table_name = m2.table_name
                                   for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 2, N'') as inequality
                    ,
                            STUFF((select distinct N', ' + ISNULL(m2.column_name, '') as column_name
                                   from #missing_index_detail as m2
                                   where m2.usage = 'INCLUDE'
                                     and m.queryhash = m2.queryhash
                                     and m.sqlhandle = m2.sqlhandle
                                     and m.impact = m2.impact
                                     and m.database_name = m2.database_name
                                     and m.schema_name = m2.schema_name
                                     and m.table_name = m2.table_name
                                   for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 2, N'') as [include],
                            bbcp.executioncount,
                            bbcp.queryplancost,
                            bbcp.plancreationtimehours,
                            0                                                                            as is_spool
            from #missing_index_detail as m
                     join ##blitzcacheprocs as bbcp
                          on m.sqlhandle = bbcp.sqlhandle
                              and m.queryhash = bbcp.queryhash
            option (recompile);

            raiserror (N'Inserting to #index_spool_ugly', 0, 1) with nowait;
            with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
            insert
            #index_spool_ugly
            (
            queryhash
            ,
            sqlhandle
            ,
            impact
            ,
            database_name
            ,
            schema_name
            ,
            table_name
            ,
            equality
            ,
            inequality
            ,
            include
            ,
            executions
            ,
            query_cost
            ,
            creation_hours
            )
            select p.queryhash,
                   p.sqlhandle,
                   (c.n.value('@EstimateIO', 'FLOAT') + (c.n.value('@EstimateCPU', 'FLOAT')))
                       / (1 * NULLIF(p.queryplancost, 0)) * 100 as impact,
                   o.n.value('@Database', 'NVARCHAR(128)')      as output_database,
                   o.n.value('@Schema', 'NVARCHAR(128)')        as output_schema,
                   o.n.value('@Table', 'NVARCHAR(128)')         as output_table,
                   k.n.value('@Column', 'NVARCHAR(128)')        as range_column,
                   e.n.value('@Column', 'NVARCHAR(128)')        as expression_column,
                   o.n.value('@Column', 'NVARCHAR(128)')        as output_column,
                   p.executioncount,
                   p.queryplancost,
                   p.plancreationtimehours
            from #relop as r
                     join ##blitzcacheprocs p
                          on p.queryhash = r.queryhash
                     cross apply r.relop.nodes('/p:RelOp') as c(n)
                     cross apply r.relop.nodes('/p:RelOp/p:OutputList/p:ColumnReference') as o(n)
                     outer apply r.relop.nodes(
                    '/p:RelOp/p:Spool/p:SeekPredicateNew/p:SeekKeys/p:Prefix/p:RangeColumns/p:ColumnReference') as k(n)
                     outer apply r.relop.nodes(
                    '/p:RelOp/p:Spool/p:SeekPredicateNew/p:SeekKeys/p:Prefix/p:RangeExpressions/p:ColumnReference') as e(n)
            where r.relop.exist('/p:RelOp[@PhysicalOp="Index Spool" and @LogicalOp="Eager Spool"]') = 1

            raiserror (N'Inserting to spools to #missing_index_pretty', 0, 1) with nowait;
            insert #missing_index_pretty
            (queryhash, sqlhandle, impact, database_name, schema_name, table_name, equality, inequality, include,
             executions, query_cost, creation_hours, is_spool)
            select distinct isu.queryhash,
                            isu.sqlhandle,
                            isu.impact,
                            isu.database_name,
                            isu.schema_name,
                            isu.table_name
                    ,
                            STUFF((select distinct N', ' + ISNULL(isu2.equality, '') as column_name
                                   from #index_spool_ugly as isu2
                                   where isu2.equality is not null
                                     and isu.queryhash = isu2.queryhash
                                     and isu.sqlhandle = isu2.sqlhandle
                                     and isu.impact = isu2.impact
                                     and isu.database_name = isu2.database_name
                                     and isu.schema_name = isu2.schema_name
                                     and isu.table_name = isu2.table_name
                                   for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 2, N'') as equality
                    ,
                            STUFF((select distinct N', ' + ISNULL(isu2.inequality, '') as column_name
                                   from #index_spool_ugly as isu2
                                   where isu2.inequality is not null
                                     and isu.queryhash = isu2.queryhash
                                     and isu.sqlhandle = isu2.sqlhandle
                                     and isu.impact = isu2.impact
                                     and isu.database_name = isu2.database_name
                                     and isu.schema_name = isu2.schema_name
                                     and isu.table_name = isu2.table_name
                                   for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 2, N'') as inequality
                    ,
                            STUFF((select distinct N', ' + ISNULL(isu2.include, '') as column_name
                                   from #index_spool_ugly as isu2
                                   where isu2.include is not null
                                     and isu.queryhash = isu2.queryhash
                                     and isu.sqlhandle = isu2.sqlhandle
                                     and isu.impact = isu2.impact
                                     and isu.database_name = isu2.database_name
                                     and isu.schema_name = isu2.schema_name
                                     and isu.table_name = isu2.table_name
                                   for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 2, N'') as include,
                            isu.executions,
                            isu.query_cost,
                            isu.creation_hours,
                            1                                                                            as is_spool
            from #index_spool_ugly as isu


            raiserror (N'Updating missing index information', 0, 1) with nowait;
            with missing as (
                select distinct mip.queryhash,
                                mip.sqlhandle,
                                mip.executions,
                                N'<MissingIndexes><![CDATA['
                                    + CHAR(10) + CHAR(13)
                                    + STUFF((select CHAR(10) + CHAR(13) + ISNULL(mip2.details, '') as details
                                             from #missing_index_pretty as mip2
                                             where mip.queryhash = mip2.queryhash
                                               and mip.sqlhandle = mip2.sqlhandle
                                               and mip.executions = mip2.executions
                                             group by mip2.details
                                             order by MAX(mip2.impact) desc
                                             for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 2, N'')
                                    + CHAR(10) + CHAR(13)
                                    + N']]></MissingIndexes>'
                                    as full_details
                from #missing_index_pretty as mip
            )
            update bbcp
            set bbcp.missing_indexes = m.full_details
            from ##blitzcacheprocs as bbcp
                     join missing as m
                          on m.sqlhandle = bbcp.sqlhandle
                              and m.queryhash = bbcp.queryhash
                              and m.executions = bbcp.executioncount
                              and spid = @@SPID
            option (recompile);

        end;

    raiserror (N'Filling in missing index blanks', 0, 1) with nowait;
    update b
    set b.missing_indexes =
            case
                when b.missing_indexes is null
                    then '<?NoNeedToClickMe -- N/A --?>'
                else b.missing_indexes
                end
    from ##blitzcacheprocs as b
    where b.spid = @@SPID
    option (recompile);

    /*End Missing Index*/


/* Set configuration values */
    raiserror (N'Setting configuration values', 0, 1) with nowait;
    declare @execution_threshold int = 1000 ,
        @parameter_sniffing_warning_pct tinyint = 30,
        /* This is in average reads */
        @parameter_sniffing_io_threshold bigint = 100000 ,
        @ctp_threshold_pct tinyint = 10,
        @long_running_query_warning_seconds bigint = 300 * 1000 ,
        @memory_grant_warning_percent int = 10;

    if EXISTS(select 1 / 0 from #configuration where 'frequent execution threshold' = LOWER(parameter_name))
        begin
            select @execution_threshold = CAST(value as int)
            from #configuration
            where 'frequent execution threshold' = LOWER(parameter_name);

            set @msg = ' Setting "frequent execution threshold" to ' + CAST(@execution_threshold as varchar(10));

            raiserror (@msg, 0, 1) with nowait;
        end;

    if EXISTS(select 1 / 0 from #configuration where 'parameter sniffing variance percent' = LOWER(parameter_name))
        begin
            select @parameter_sniffing_warning_pct = CAST(value as tinyint)
            from #configuration
            where 'parameter sniffing variance percent' = LOWER(parameter_name);

            set @msg = ' Setting "parameter sniffing variance percent" to ' +
                       CAST(@parameter_sniffing_warning_pct as varchar(3));

            raiserror (@msg, 0, 1) with nowait;
        end;

    if EXISTS(select 1 / 0 from #configuration where 'parameter sniffing io threshold' = LOWER(parameter_name))
        begin
            select @parameter_sniffing_io_threshold = CAST(value as bigint)
            from #configuration
            where 'parameter sniffing io threshold' = LOWER(parameter_name);

            set @msg = ' Setting "parameter sniffing io threshold" to ' +
                       CAST(@parameter_sniffing_io_threshold as varchar(10));

            raiserror (@msg, 0, 1) with nowait;
        end;

    if EXISTS(select 1 / 0 from #configuration where 'cost threshold for parallelism warning' = LOWER(parameter_name))
        begin
            select @ctp_threshold_pct = CAST(value as tinyint)
            from #configuration
            where 'cost threshold for parallelism warning' = LOWER(parameter_name);

            set @msg = ' Setting "cost threshold for parallelism warning" to ' + CAST(@ctp_threshold_pct as varchar(3));

            raiserror (@msg, 0, 1) with nowait;
        end;

    if EXISTS(select 1 / 0 from #configuration where 'long running query warning (seconds)' = LOWER(parameter_name))
        begin
            select @long_running_query_warning_seconds = CAST(value * 1000 as bigint)
            from #configuration
            where 'long running query warning (seconds)' = LOWER(parameter_name);

            set @msg = ' Setting "long running query warning (seconds)" to ' +
                       CAST(@long_running_query_warning_seconds as varchar(10));

            raiserror (@msg, 0, 1) with nowait;
        end;

    if EXISTS(select 1 / 0 from #configuration where 'unused memory grant' = LOWER(parameter_name))
        begin
            select @memory_grant_warning_percent = CAST(value as int)
            from #configuration
            where 'unused memory grant' = LOWER(parameter_name);

            set @msg = ' Setting "unused memory grant" to ' + CAST(@memory_grant_warning_percent as varchar(10));

            raiserror (@msg, 0, 1) with nowait;
        end;

    declare @ctp int;

    select @ctp = NULLIF(CAST(value as int), 0)
    from sys.configurations
    where name = 'cost threshold for parallelism'
    option (recompile);


/* Update to populate checks columns */
    raiserror ('Checking for query level SQL Server issues.', 0, 1) with nowait;

    with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as p)
    update ##blitzcacheprocs
    set frequent_execution        = case when executionsperminute > @execution_threshold then 1 end,
        parameter_sniffing        = case
                                        when executioncount > 3 and averagereads > @parameter_sniffing_io_threshold
                                            and min_worker_time <
                                                ((1.0 - (@parameter_sniffing_warning_pct / 100.0)) * averagecpu) then 1
                                        when executioncount > 3 and averagereads > @parameter_sniffing_io_threshold
                                            and max_worker_time >
                                                ((1.0 + (@parameter_sniffing_warning_pct / 100.0)) * averagecpu) then 1
                                        when executioncount > 3 and averagereads > @parameter_sniffing_io_threshold
                                            and minreturnedrows <
                                                ((1.0 - (@parameter_sniffing_warning_pct / 100.0)) * averagereturnedrows)
                                            then 1
                                        when executioncount > 3 and averagereads > @parameter_sniffing_io_threshold
                                            and maxreturnedrows >
                                                ((1.0 + (@parameter_sniffing_warning_pct / 100.0)) * averagereturnedrows)
                                            then 1 end,
        near_parallel             = case
                                        when is_parallel <> 1 and
                                             queryplancost between @ctp * (1 - (@ctp_threshold_pct / 100.0)) and @ctp
                                            then 1 end,
        long_running              = case
                                        when averageduration > @long_running_query_warning_seconds then 1
                                        when max_worker_time > @long_running_query_warning_seconds then 1
                                        when max_elapsed_time > @long_running_query_warning_seconds then 1 end,
        is_key_lookup_expensive   = case
                                        when queryplancost >= (@ctp / 2) and key_lookup_cost >= queryplancost * .5
                                            then 1 end,
        is_sort_expensive         = case
                                        when queryplancost >= (@ctp / 2) and sort_cost >= queryplancost * .5 then 1 end,
        is_remote_query_expensive = case when remote_query_cost >= queryplancost * .05 then 1 end,
        is_unused_grant           = case
                                        when percentmemorygrantused <= @memory_grant_warning_percent and
                                             mingrantkb > @minmemoryperquery then 1 end,
        long_running_low_cpu      = case when averageduration > averagecpu * 4 and averagecpu < 500. then 1 end,
        low_cost_high_cpu         = case when queryplancost <= 10 and averagecpu > 5000. then 1 end,
        is_spool_expensive        = case
                                        when queryplancost > (@ctp / 5) and index_spool_cost >= queryplancost * .1
                                            then 1 end,
        is_spool_more_rows        = case
                                        when index_spool_rows >=
                                             (averagereturnedrows / ISNULL(NULLIF(executioncount, 0), 1)) then 1 end,
        is_table_spool_expensive  = case
                                        when queryplancost > (@ctp / 5) and table_spool_cost >= queryplancost / 4
                                            then 1 end,
        is_table_spool_more_rows  = case
                                        when table_spool_rows >=
                                             (averagereturnedrows / ISNULL(NULLIF(executioncount, 0), 1)) then 1 end,
        is_bad_estimate           = case
                                        when averagereturnedrows > 0 and (estimated_rows * 1000 < averagereturnedrows or
                                                                          estimated_rows > averagereturnedrows * 1000)
                                            then 1 end,
        is_big_spills             = case when (avgspills / 128.) > 499. then 1 end
    where spid = @@SPID
    option (recompile);


    raiserror ('Checking for forced parameterization and cursors.', 0, 1) with nowait;

/* Set options checks */
    update p
    set is_forced_parameterized = case when (CAST(pa.value as int) & 131072 = 131072) then 1 end,
        is_forced_plan          = case when (CAST(pa.value as int) & 4 = 4) then 1 end,
        setoptions              = SUBSTRING(
                    case when (CAST(pa.value as int) & 1 = 1) then ', ANSI_PADDING' else '' end +
                    case when (CAST(pa.value as int) & 8 = 8) then ', CONCAT_NULL_YIELDS_NULL' else '' end +
                    case when (CAST(pa.value as int) & 16 = 16) then ', ANSI_WARNINGS' else '' end +
                    case when (CAST(pa.value as int) & 32 = 32) then ', ANSI_NULLS' else '' end +
                    case when (CAST(pa.value as int) & 64 = 64) then ', QUOTED_IDENTIFIER' else '' end +
                    case when (CAST(pa.value as int) & 4096 = 4096) then ', ARITH_ABORT' else '' end +
                    case when (CAST(pa.value as int) & 8192 = 8191) then ', NUMERIC_ROUNDABORT' else '' end
            , 2, 200000)
    from ##blitzcacheprocs p
             cross apply sys.dm_exec_plan_attributes(p.planhandle) pa
    where pa.attribute = 'set_options'
      and spid = @@SPID
    option (recompile);


/* Cursor checks */
    update p
    set is_cursor = case when CAST(pa.value as int) <> 0 then 1 end
    from ##blitzcacheprocs p
             cross apply sys.dm_exec_plan_attributes(p.planhandle) pa
    where pa.attribute like '%cursor%'
      and spid = @@SPID
    option (recompile);

    update p
    set is_cursor = 1
    from ##blitzcacheprocs p
    where queryhash = 0x0000000000000000
       or queryplanhash = 0x0000000000000000
        and spid = @@SPID
    option (recompile);


    raiserror ('Populating Warnings column', 0, 1) with nowait;
/* Populate warnings */
    update ##blitzcacheprocs
    set warnings = SUBSTRING(
                case when warning_no_join_predicate = 1 then ', No Join Predicate' else '' end +
                case when compile_timeout = 1 then ', Compilation Timeout' else '' end +
                case when compile_memory_limit_exceeded = 1 then ', Compile Memory Limit Exceeded' else '' end +
                case when busy_loops = 1 then ', Busy Loops' else '' end +
                case when is_forced_plan = 1 then ', Forced Plan' else '' end +
                case when is_forced_parameterized = 1 then ', Forced Parameterization' else '' end +
                case when unparameterized_query = 1 then ', Unparameterized Query' else '' end +
                case
                    when missing_index_count > 0
                        then ', Missing Indexes (' + CAST(missing_index_count as varchar(3)) + ')'
                    else '' end +
                case
                    when unmatched_index_count > 0 then ', Unmatched Indexes (' +
                                                        CAST(unmatched_index_count as varchar(3)) + ')'
                    else '' end +
                case
                    when is_cursor = 1 then ', Cursor'
                        + case when is_optimistic_cursor = 1 then '; optimistic' else '' end
                        + case when is_forward_only_cursor = 0 then '; not forward only' else '' end
                        + case when is_cursor_dynamic = 1 then '; dynamic' else '' end
                        + case when is_fast_forward_cursor = 1 then '; fast forward' else '' end
                    else '' end +
                case when is_parallel = 1 then ', Parallel' else '' end +
                case when near_parallel = 1 then ', Nearly Parallel' else '' end +
                case when frequent_execution = 1 then ', Frequent Execution' else '' end +
                case when plan_warnings = 1 then ', Plan Warnings' else '' end +
                case when parameter_sniffing = 1 then ', Parameter Sniffing' else '' end +
                case when long_running = 1 then ', Long Running Query' else '' end +
                case when downlevel_estimator = 1 then ', Downlevel CE' else '' end +
                case when implicit_conversions = 1 then ', Implicit Conversions' else '' end +
                case when tvf_join = 1 then ', Function Join' else '' end +
                case
                    when plan_multiple_plans > 0 then ', Multiple Plans' +
                                                      COALESCE(' (' + CAST(plan_multiple_plans as varchar(10)) + ')', '')
                    else '' end +
                case when is_trivial = 1 then ', Trivial Plans' else '' end +
                case when is_forced_serial = 1 then ', Forced Serialization' else '' end +
                case when is_key_lookup_expensive = 1 then ', Expensive Key Lookup' else '' end +
                case when is_remote_query_expensive = 1 then ', Expensive Remote Query' else '' end +
                case
                    when trace_flags_session is not null
                        then ', Session Level Trace Flag(s) Enabled: ' + trace_flags_session
                    else '' end +
                case when is_unused_grant = 1 then ', Unused Memory Grant' else '' end +
                case
                    when function_count > 0 then ', Calls ' + CONVERT(varchar(10), function_count) + ' Function(s)'
                    else '' end +
                case
                    when clr_function_count > 0 then ', Calls ' + CONVERT(varchar(10), clr_function_count) +
                                                     ' CLR Function(s)'
                    else '' end +
                case when plancreationtimehours <= 4 then ', Plan created last 4hrs' else '' end +
                case when is_table_variable = 1 then ', Table Variables' else '' end +
                case when no_stats_warning = 1 then ', Columns With No Statistics' else '' end +
                case when relop_warnings = 1 then ', Operator Warnings' else '' end +
                case when is_table_scan = 1 then ', Table Scans (Heaps)' else '' end +
                case when backwards_scan = 1 then ', Backwards Scans' else '' end +
                case when forced_index = 1 then ', Forced Indexes' else '' end +
                case when forced_seek = 1 then ', Forced Seeks' else '' end +
                case when forced_scan = 1 then ', Forced Scans' else '' end +
                case when columnstore_row_mode = 1 then ', ColumnStore Row Mode ' else '' end +
                case when is_computed_scalar = 1 then ', Computed Column UDF ' else '' end +
                case when is_sort_expensive = 1 then ', Expensive Sort' else '' end +
                case when is_computed_filter = 1 then ', Filter UDF' else '' end +
                case when index_ops >= 5 then ', >= 5 Indexes Modified' else '' end +
                case when is_row_level = 1 then ', Row Level Security' else '' end +
                case when is_spatial = 1 then ', Spatial Index' else '' end +
                case when index_dml = 1 then ', Index DML' else '' end +
                case when table_dml = 1 then ', Table DML' else '' end +
                case when low_cost_high_cpu = 1 then ', Low Cost High CPU' else '' end +
                case when long_running_low_cpu = 1 then + ', Long Running With Low CPU' else '' end +
                case
                    when stale_stats = 1 then + ', Statistics used have > 100k modifications in the last 7 days'
                    else '' end +
                case when is_adaptive = 1 then + ', Adaptive Joins' else '' end +
                case when is_spool_expensive = 1 then + ', Expensive Index Spool' else '' end +
                case when is_spool_more_rows = 1 then + ', Large Index Row Spool' else '' end +
                case when is_table_spool_expensive = 1 then + ', Expensive Table Spool' else '' end +
                case when is_table_spool_more_rows = 1 then + ', Many Rows Table Spool' else '' end +
                case when is_bad_estimate = 1 then + ', Row Estimate Mismatch' else '' end +
                case when is_paul_white_electric = 1 then ', SWITCH!' else '' end +
                case when is_row_goal = 1 then ', Row Goals' else '' end +
                case when is_big_spills = 1 then ', >500mb Spills' else '' end +
                case when is_mstvf = 1 then ', MSTVFs' else '' end +
                case when is_mm_join = 1 then ', Many to Many Merge' else '' end +
                case when is_nonsargable = 1 then ', non-SARGables' else '' end +
                case when compiletime > 5000 then ', Long Compile Time' else '' end +
                case when compilecpu > 5000 then ', High Compile CPU' else '' end +
                case
                    when compilememory > 1024 and
                         ((compilememory) / (1 * case when maxcompilememory = 0 then 1 else maxcompilememory end) *
                          100.) >= 10. then ', High Compile Memory'
                    else '' end +
                case when select_with_writes > 0 then ', Select w/ Writes' else '' end
        , 3, 200000)
    where spid = @@SPID
    option (recompile);


    raiserror ('Populating Warnings column for stored procedures', 0, 1) with nowait;
    with statement_warnings as
             (
                 select distinct sqlhandle,
                                 warnings = SUBSTRING(
                                             case
                                                 when warning_no_join_predicate = 1 then ', No Join Predicate'
                                                 else '' end +
                                             case when compile_timeout = 1 then ', Compilation Timeout' else '' end +
                                             case
                                                 when compile_memory_limit_exceeded = 1
                                                     then ', Compile Memory Limit Exceeded'
                                                 else '' end +
                                             case when busy_loops = 1 then ', Busy Loops' else '' end +
                                             case when is_forced_plan = 1 then ', Forced Plan' else '' end +
                                             case
                                                 when is_forced_parameterized = 1 then ', Forced Parameterization'
                                                 else '' end +
                                             --CASE WHEN unparameterized_query = 1 THEN ', Unparameterized Query' ELSE '' END +
                                             case
                                                 when missing_index_count > 0 then ', Missing Indexes (' +
                                                                                   CONVERT(varchar(10),
                                                                                           (select SUM(b2.missing_index_count)
                                                                                            from ##blitzcacheprocs as b2
                                                                                            where b2.sqlhandle = b.sqlhandle
                                                                                              and b2.queryhash is not null
                                                                                              and spid = @@SPID)) + ')'
                                                 else '' end +
                                             case
                                                 when unmatched_index_count > 0 then ', Unmatched Indexes (' +
                                                                                     CONVERT(varchar(10),
                                                                                             (select SUM(b2.unmatched_index_count)
                                                                                              from ##blitzcacheprocs as b2
                                                                                              where b2.sqlhandle = b.sqlhandle
                                                                                                and b2.queryhash is not null
                                                                                                and spid = @@SPID)) +
                                                                                     ')'
                                                 else '' end +
                                             case
                                                 when is_cursor = 1 then ', Cursor'
                                                     +
                                                                         case when is_optimistic_cursor = 1 then '; optimistic' else '' end
                                                     +
                                                                         case when is_forward_only_cursor = 0 then '; not forward only' else '' end
                                                     + case when is_cursor_dynamic = 1 then '; dynamic' else '' end
                                                     +
                                                                         case when is_fast_forward_cursor = 1 then '; fast forward' else '' end
                                                 else '' end +
                                             case when is_parallel = 1 then ', Parallel' else '' end +
                                             case when near_parallel = 1 then ', Nearly Parallel' else '' end +
                                             case when frequent_execution = 1 then ', Frequent Execution' else '' end +
                                             case when plan_warnings = 1 then ', Plan Warnings' else '' end +
                                             case when parameter_sniffing = 1 then ', Parameter Sniffing' else '' end +
                                             case when long_running = 1 then ', Long Running Query' else '' end +
                                             case when downlevel_estimator = 1 then ', Downlevel CE' else '' end +
                                             case
                                                 when implicit_conversions = 1 then ', Implicit Conversions'
                                                 else '' end +
                                             case when tvf_join = 1 then ', Function Join' else '' end +
                                             case
                                                 when plan_multiple_plans > 0 then ', Multiple Plans' +
                                                                                   COALESCE(' (' + CAST(plan_multiple_plans as varchar(10)) + ')', '')
                                                 else '' end +
                                             case when is_trivial = 1 then ', Trivial Plans' else '' end +
                                             case when is_forced_serial = 1 then ', Forced Serialization' else '' end +
                                             case
                                                 when is_key_lookup_expensive = 1 then ', Expensive Key Lookup'
                                                 else '' end +
                                             case
                                                 when is_remote_query_expensive = 1 then ', Expensive Remote Query'
                                                 else '' end +
                                             case
                                                 when trace_flags_session is not null
                                                     then ', Session Level Trace Flag(s) Enabled: ' + trace_flags_session
                                                 else '' end +
                                             case when is_unused_grant = 1 then ', Unused Memory Grant' else '' end +
                                             case
                                                 when function_count > 0 then ', Calls ' + CONVERT(varchar(10),
                                                         (select SUM(b2.function_count)
                                                          from ##blitzcacheprocs as b2
                                                          where b2.sqlhandle = b.sqlhandle
                                                            and b2.queryhash is not null
                                                            and spid = @@SPID)) + ' function(s)'
                                                 else '' end +
                                             case
                                                 when clr_function_count > 0 then ', Calls ' + CONVERT(varchar(10),
                                                         (select SUM(b2.clr_function_count)
                                                          from ##blitzcacheprocs as b2
                                                          where b2.sqlhandle = b.sqlhandle
                                                            and b2.queryhash is not null
                                                            and spid = @@SPID)) + ' CLR function(s)'
                                                 else '' end +
                                             case
                                                 when plancreationtimehours <= 4 then ', Plan created last 4hrs'
                                                 else '' end +
                                             case when is_table_variable = 1 then ', Table Variables' else '' end +
                                             case
                                                 when no_stats_warning = 1 then ', Columns With No Statistics'
                                                 else '' end +
                                             case when relop_warnings = 1 then ', Operator Warnings' else '' end +
                                             case when is_table_scan = 1 then ', Table Scans' else '' end +
                                             case when backwards_scan = 1 then ', Backwards Scans' else '' end +
                                             case when forced_index = 1 then ', Forced Indexes' else '' end +
                                             case when forced_seek = 1 then ', Forced Seeks' else '' end +
                                             case when forced_scan = 1 then ', Forced Scans' else '' end +
                                             case
                                                 when columnstore_row_mode = 1 then ', ColumnStore Row Mode '
                                                 else '' end +
                                             case when is_computed_scalar = 1 then ', Computed Column UDF ' else '' end +
                                             case when is_sort_expensive = 1 then ', Expensive Sort' else '' end +
                                             case when is_computed_filter = 1 then ', Filter UDF' else '' end +
                                             case when index_ops >= 5 then ', >= 5 Indexes Modified' else '' end +
                                             case when is_row_level = 1 then ', Row Level Security' else '' end +
                                             case when is_spatial = 1 then ', Spatial Index' else '' end +
                                             case when index_dml = 1 then ', Index DML' else '' end +
                                             case when table_dml = 1 then ', Table DML' else '' end +
                                             case when low_cost_high_cpu = 1 then ', Low Cost High CPU' else '' end +
                                             case
                                                 when long_running_low_cpu = 1 then + ', Long Running With Low CPU'
                                                 else '' end +
                                             case
                                                 when stale_stats = 1
                                                     then + ', Statistics used have > 100k modifications in the last 7 days'
                                                 else '' end +
                                             case when is_adaptive = 1 then + ', Adaptive Joins' else '' end +
                                             case
                                                 when is_spool_expensive = 1 then + ', Expensive Index Spool'
                                                 else '' end +
                                             case
                                                 when is_spool_more_rows = 1 then + ', Large Index Row Spool'
                                                 else '' end +
                                             case
                                                 when is_table_spool_expensive = 1 then + ', Expensive Table Spool'
                                                 else '' end +
                                             case
                                                 when is_table_spool_more_rows = 1 then + ', Many Rows Table Spool'
                                                 else '' end +
                                             case when is_bad_estimate = 1 then + ', Row estimate mismatch' else '' end +
                                             case when is_paul_white_electric = 1 then ', SWITCH!' else '' end +
                                             case when is_row_goal = 1 then ', Row Goals' else '' end +
                                             case when is_big_spills = 1 then ', >500mb spills' else '' end +
                                             case when is_mstvf = 1 then ', MSTVFs' else '' end +
                                             case when is_mm_join = 1 then ', Many to Many Merge' else '' end +
                                             case when is_nonsargable = 1 then ', non-SARGables' else '' end +
                                             case when compiletime > 5000 then ', Long Compile Time' else '' end +
                                             case when compilecpu > 5000 then ', High Compile CPU' else '' end +
                                             case
                                                 when compilememory > 1024 and ((compilememory) /
                                                                                (1 * case when maxcompilememory = 0 then 1 else maxcompilememory end) *
                                                                                100.) >= 10.
                                                     then ', High Compile Memory'
                                                 else '' end +
                                             case when select_with_writes > 0 then ', Select w/ Writes' else '' end
                                     , 3, 200000)
                 from ##blitzcacheprocs b
                 where spid = @@SPID
                   and querytype like 'Statement (parent%'
             )
    update b
    set b.warnings = s.warnings
    from ##blitzcacheprocs as b
             join statement_warnings s
                  on b.sqlhandle = s.sqlhandle
    where querytype like 'Procedure or Function%'
      and spid = @@SPID
    option (recompile);

    raiserror ('Checking for plans with >128 levels of nesting', 0, 1) with nowait;
    with plan_handle as (
        select b.planhandle
        from ##blitzcacheprocs b
                 cross apply sys.dm_exec_text_query_plan(b.planhandle, 0, -1) tqp
                 cross apply sys.dm_exec_query_plan(b.planhandle) qp
        where tqp.encrypted = 0
          and b.spid = @@SPID
          and (qp.query_plan is null
            and tqp.query_plan is not null)
    )
    update b
    set warnings = ISNULL(
                'Your query plan is >128 levels of nested nodes, and can''t be converted to XML. Use SELECT * FROM sys.dm_exec_text_query_plan(' +
                CONVERT(varchar(128), ph.planhandle, 1) + ', 0, -1) to get more information'
        , 'We couldn''t find a plan for this query. More info on possible reasons: https://BrentOzar.com/go/noplans')
    from ##blitzcacheprocs b
             left join plan_handle ph on
        b.planhandle = ph.planhandle
    where b.queryplan is null
      and b.spid = @@SPID
    option (recompile);

    raiserror ('Checking for plans with no warnings', 0, 1) with nowait;
    update ##blitzcacheprocs
    set warnings = 'No warnings detected. ' + case @expertmode
                                                  when 0
                                                      then ' Try running sp_BlitzCache with @ExpertMode = 1 to find more advanced problems.'
                                                  else ''
        end
    where warnings = ''
       or warnings is null
        and spid = @@SPID
    option (recompile);


    results:
    if @exporttoexcel = 1
        begin
            raiserror ('Displaying results with Excel formatting (no plans).', 0, 1) with nowait;

            /* excel output */
            update ##blitzcacheprocs
            set querytext = SUBSTRING(
                    REPLACE(REPLACE(REPLACE(LTRIM(RTRIM(querytext)), ' ', '<>'), '><', ''), '<>', ' '), 1, 32000)
            option (recompile);

            set @sql = N'
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    SELECT  TOP (@Top)
            DatabaseName AS [Database Name],
            QueryPlanCost AS [Cost],
            QueryText,
            QueryType AS [Query Type],
            Warnings,
            ExecutionCount,
            ExecutionsPerMinute AS [Executions / Minute],
            PercentExecutions AS [Execution Weight],
            PercentExecutionsByType AS [% Executions (Type)],
            SerialDesiredMemory AS [Serial Desired Memory],
            SerialRequiredMemory AS [Serial Required Memory],
            TotalCPU AS [Total CPU (ms)],
            AverageCPU AS [Avg CPU (ms)],
            PercentCPU AS [CPU Weight],
            PercentCPUByType AS [% CPU (Type)],
            TotalDuration AS [Total Duration (ms)],
            AverageDuration AS [Avg Duration (ms)],
            PercentDuration AS [Duration Weight],
            PercentDurationByType AS [% Duration (Type)],
            TotalReads AS [Total Reads],
            AverageReads AS [Average Reads],
            PercentReads AS [Read Weight],
            PercentReadsByType AS [% Reads (Type)],
            TotalWrites AS [Total Writes],
            AverageWrites AS [Average Writes],
            PercentWrites AS [Write Weight],
            PercentWritesByType AS [% Writes (Type)],
            TotalReturnedRows,
            AverageReturnedRows,
            MinReturnedRows,
            MaxReturnedRows,
		    MinGrantKB,
		    MaxGrantKB,
		    MinUsedGrantKB,
		    MaxUsedGrantKB,
		    PercentMemoryGrantUsed,
			AvgMaxMemoryGrant,
			MinSpills,
			MaxSpills,
			TotalSpills,
			AvgSpills,
            NumberOfPlans,
            NumberOfDistinctPlans,
            PlanCreationTime AS [Created At],
            LastExecutionTime AS [Last Execution],
            StatementStartOffset,
            StatementEndOffset,
			PlanHandle AS [Plan Handle],
			SqlHandle AS [SQL Handle],
            QueryHash,
            QueryPlanHash,
            COALESCE(SetOptions, '''') AS [SET Options]
    FROM    ##BlitzCacheProcs
    WHERE   1 = 1
	AND SPID = @@SPID ' + @nl;

            if @minimumexecutioncount is not null
                begin
                    set @sql += N' AND ExecutionCount >= @minimumExecutionCount ';
                end;

            if @minutesback is not null
                begin
                    set @sql += N' AND LastCompletionTime >= DATEADD(MINUTE, @min_back, GETDATE() ) ';
                end;

            select @sql += N' ORDER BY ' + case @sortorder
                                               when N'cpu' then N' TotalCPU '
                                               when N'reads' then N' TotalReads '
                                               when N'writes' then N' TotalWrites '
                                               when N'duration' then N' TotalDuration '
                                               when N'executions' then N' ExecutionCount '
                                               when N'compiles' then N' PlanCreationTime '
                                               when N'memory grant' then N' MaxGrantKB'
                                               when N'spills' then N' MaxSpills'
                                               when N'avg cpu' then N' AverageCPU'
                                               when N'avg reads' then N' AverageReads'
                                               when N'avg writes' then N' AverageWrites'
                                               when N'avg duration' then N' AverageDuration'
                                               when N'avg executions' then N' ExecutionsPerMinute'
                                               when N'avg memory grant' then N' AvgMaxMemoryGrant'
                                               when N'avg spills' then N' AvgSpills'
                end + N' DESC ';

            set @sql += N' OPTION (RECOMPILE) ; ';

            if @debug = 1
                begin
                    print SUBSTRING(@sql, 0, 4000);
                    print SUBSTRING(@sql, 4000, 8000);
                    print SUBSTRING(@sql, 8000, 12000);
                    print SUBSTRING(@sql, 12000, 16000);
                    print SUBSTRING(@sql, 16000, 20000);
                    print SUBSTRING(@sql, 20000, 24000);
                    print SUBSTRING(@sql, 24000, 28000);
                    print SUBSTRING(@sql, 28000, 32000);
                    print SUBSTRING(@sql, 32000, 36000);
                    print SUBSTRING(@sql, 36000, 40000);
                end;

            exec sp_executesql @sql, N'@Top INT, @min_duration INT, @min_back INT, @minimumExecutionCount INT', @top,
                 @durationfilter_i, @minutesback, @minimumexecutioncount;
        end;


    raiserror ('Displaying analysis of plan cache.', 0, 1) with nowait;

    declare @columns nvarchar(max) = N'';

    if @expertmode = 0
        begin
            raiserror (N'Returning ExpertMode = 0', 0, 1) with nowait;
            set @columns = N' DatabaseName AS [Database],
    QueryPlanCost AS [Cost],
    QueryText AS [Query Text],
    QueryType AS [Query Type],
    Warnings AS [Warnings],
	QueryPlan AS [Query Plan],
	missing_indexes AS [Missing Indexes],
	implicit_conversion_info AS [Implicit Conversion Info],
	cached_execution_parameters AS [Cached Execution Parameters],
    CONVERT(NVARCHAR(30), CAST((ExecutionCount) AS BIGINT), 1) AS [# Executions],
    CONVERT(NVARCHAR(30), CAST((ExecutionsPerMinute) AS BIGINT), 1) AS [Executions / Minute],
    CONVERT(NVARCHAR(30), CAST((PercentExecutions) AS BIGINT), 1) AS [Execution Weight],
    CONVERT(NVARCHAR(30), CAST((TotalCPU) AS BIGINT), 1) AS [Total CPU (ms)],
    CONVERT(NVARCHAR(30), CAST((AverageCPU) AS BIGINT), 1) AS [Avg CPU (ms)],
    CONVERT(NVARCHAR(30), CAST((PercentCPU) AS BIGINT), 1) AS [CPU Weight],
    CONVERT(NVARCHAR(30), CAST((TotalDuration) AS BIGINT), 1) AS [Total Duration (ms)],
    CONVERT(NVARCHAR(30), CAST((AverageDuration) AS BIGINT), 1) AS [Avg Duration (ms)],
    CONVERT(NVARCHAR(30), CAST((PercentDuration) AS BIGINT), 1) AS [Duration Weight],
    CONVERT(NVARCHAR(30), CAST((TotalReads) AS BIGINT), 1) AS [Total Reads],
    CONVERT(NVARCHAR(30), CAST((AverageReads) AS BIGINT), 1) AS [Avg Reads],
    CONVERT(NVARCHAR(30), CAST((PercentReads) AS BIGINT), 1) AS [Read Weight],
    CONVERT(NVARCHAR(30), CAST((TotalWrites) AS BIGINT), 1) AS [Total Writes],
    CONVERT(NVARCHAR(30), CAST((AverageWrites) AS BIGINT), 1) AS [Avg Writes],
    CONVERT(NVARCHAR(30), CAST((PercentWrites) AS BIGINT), 1) AS [Write Weight],
    CONVERT(NVARCHAR(30), CAST((AverageReturnedRows) AS BIGINT), 1) AS [Average Rows],
	CONVERT(NVARCHAR(30), CAST((MinGrantKB) AS BIGINT), 1) AS [Minimum Memory Grant KB],
	CONVERT(NVARCHAR(30), CAST((MaxGrantKB) AS BIGINT), 1) AS [Maximum Memory Grant KB],
	CONVERT(NVARCHAR(30), CAST((MinUsedGrantKB) AS BIGINT), 1) AS [Minimum Used Grant KB],
	CONVERT(NVARCHAR(30), CAST((MaxUsedGrantKB) AS BIGINT), 1) AS [Maximum Used Grant KB],
	CONVERT(NVARCHAR(30), CAST((AvgMaxMemoryGrant) AS BIGINT), 1) AS [Average Max Memory Grant],
	CONVERT(NVARCHAR(30), CAST((MinSpills) AS BIGINT), 1) AS [Min Spills],
	CONVERT(NVARCHAR(30), CAST((MaxSpills) AS BIGINT), 1) AS [Max Spills],
	CONVERT(NVARCHAR(30), CAST((TotalSpills) AS BIGINT), 1) AS [Total Spills],
	CONVERT(NVARCHAR(30), CAST((AvgSpills) AS MONEY), 1) AS [Avg Spills],
    PlanCreationTime AS [Created At],
    LastExecutionTime AS [Last Execution],
	LastCompletionTime AS [Last Completion],
	PlanHandle AS [Plan Handle],
	SqlHandle AS [SQL Handle],
    COALESCE(SetOptions, '''') AS [SET Options],
	[Remove Plan Handle From Cache]';
        end;
    else
        begin
            set @columns = N' DatabaseName AS [Database],
		QueryPlanCost AS [Cost],
        QueryText AS [Query Text],
        QueryType AS [Query Type],
        Warnings AS [Warnings],
		QueryPlan AS [Query Plan],
		missing_indexes AS [Missing Indexes],
		implicit_conversion_info AS [Implicit Conversion Info],
		cached_execution_parameters AS [Cached Execution Parameters], ' + @nl;

            if @expertmode = 2 /* Opserver */
                begin
                    raiserror (N'Returning Expert Mode = 2', 0, 1) with nowait;
                    set @columns += N'
				  SUBSTRING(
                  CASE WHEN warning_no_join_predicate = 1 THEN '', 20'' ELSE '''' END +
                  CASE WHEN compile_timeout = 1 THEN '', 18'' ELSE '''' END +
                  CASE WHEN compile_memory_limit_exceeded = 1 THEN '', 19'' ELSE '''' END +
                  CASE WHEN busy_loops = 1 THEN '', 16'' ELSE '''' END +
                  CASE WHEN is_forced_plan = 1 THEN '', 3'' ELSE '''' END +
                  CASE WHEN is_forced_parameterized > 0 THEN '', 5'' ELSE '''' END +
                  CASE WHEN unparameterized_query = 1 THEN '', 23'' ELSE '''' END +
                  CASE WHEN missing_index_count > 0 THEN '', 10'' ELSE '''' END +
                  CASE WHEN unmatched_index_count > 0 THEN '', 22'' ELSE '''' END +
                  CASE WHEN is_cursor = 1 THEN '', 4'' ELSE '''' END +
                  CASE WHEN is_parallel = 1 THEN '', 6'' ELSE '''' END +
                  CASE WHEN near_parallel = 1 THEN '', 7'' ELSE '''' END +
                  CASE WHEN frequent_execution = 1 THEN '', 1'' ELSE '''' END +
                  CASE WHEN plan_warnings = 1 THEN '', 8'' ELSE '''' END +
                  CASE WHEN parameter_sniffing = 1 THEN '', 2'' ELSE '''' END +
                  CASE WHEN long_running = 1 THEN '', 9'' ELSE '''' END +
                  CASE WHEN downlevel_estimator = 1 THEN '', 13'' ELSE '''' END +
                  CASE WHEN implicit_conversions = 1 THEN '', 14'' ELSE '''' END +
                  CASE WHEN tvf_join = 1 THEN '', 17'' ELSE '''' END +
                  CASE WHEN plan_multiple_plans > 0 THEN '', 21'' ELSE '''' END +
                  CASE WHEN unmatched_index_count > 0 THEN '', 22'' ELSE '''' END +
                  CASE WHEN is_trivial = 1 THEN '', 24'' ELSE '''' END +
				  CASE WHEN is_forced_serial = 1 THEN '', 25'' ELSE '''' END +
                  CASE WHEN is_key_lookup_expensive = 1 THEN '', 26'' ELSE '''' END +
				  CASE WHEN is_remote_query_expensive = 1 THEN '', 28'' ELSE '''' END +
				  CASE WHEN trace_flags_session IS NOT NULL THEN '', 29'' ELSE '''' END +
				  CASE WHEN is_unused_grant = 1 THEN '', 30'' ELSE '''' END +
				  CASE WHEN function_count > 0 THEN '', 31'' ELSE '''' END +
				  CASE WHEN clr_function_count > 0 THEN '', 32'' ELSE '''' END +
				  CASE WHEN PlanCreationTimeHours <= 4 THEN '', 33'' ELSE '''' END +
				  CASE WHEN is_table_variable = 1 THEN '', 34'' ELSE '''' END  +
				  CASE WHEN no_stats_warning = 1 THEN '', 35'' ELSE '''' END  +
				  CASE WHEN relop_warnings = 1 THEN '', 36'' ELSE '''' END +
				  CASE WHEN is_table_scan = 1 THEN '', 37'' ELSE '''' END +
				  CASE WHEN backwards_scan = 1 THEN '', 38'' ELSE '''' END +
				  CASE WHEN forced_index = 1 THEN '', 39'' ELSE '''' END +
				  CASE WHEN forced_seek = 1 OR forced_scan = 1 THEN '', 40'' ELSE '''' END +
				  CASE WHEN columnstore_row_mode = 1 THEN '', 41'' ELSE '''' END +
				  CASE WHEN is_computed_scalar = 1 THEN '', 42'' ELSE '''' END +
				  CASE WHEN is_sort_expensive = 1 THEN '', 43'' ELSE '''' END +
				  CASE WHEN is_computed_filter = 1 THEN '', 44'' ELSE '''' END +
				  CASE WHEN index_ops >= 5 THEN  '', 45'' ELSE '''' END +
				  CASE WHEN is_row_level = 1 THEN  '', 46'' ELSE '''' END +
				  CASE WHEN is_spatial = 1 THEN '', 47'' ELSE '''' END +
				  CASE WHEN index_dml = 1 THEN '', 48'' ELSE '''' END +
				  CASE WHEN table_dml = 1 THEN '', 49'' ELSE '''' END +
				  CASE WHEN long_running_low_cpu = 1 THEN '', 50'' ELSE '''' END +
				  CASE WHEN low_cost_high_cpu = 1 THEN '', 51'' ELSE '''' END +
				  CASE WHEN stale_stats = 1 THEN '', 52'' ELSE '''' END +
				  CASE WHEN is_adaptive = 1 THEN '', 53'' ELSE '''' END	+
				  CASE WHEN is_spool_expensive = 1 THEN + '', 54'' ELSE '''' END +
				  CASE WHEN is_spool_more_rows = 1 THEN + '', 55'' ELSE '''' END  +
				  CASE WHEN is_table_spool_expensive = 1 THEN + '', 67'' ELSE '''' END +
				  CASE WHEN is_table_spool_more_rows = 1 THEN + '', 68'' ELSE '''' END  +
				  CASE WHEN is_bad_estimate = 1 THEN + '', 56'' ELSE '''' END  +
				  CASE WHEN is_paul_white_electric = 1 THEN '', 57'' ELSE '''' END +
				  CASE WHEN is_row_goal = 1 THEN '', 58'' ELSE '''' END +
                  CASE WHEN is_big_spills = 1 THEN '', 59'' ELSE '''' END +
				  CASE WHEN is_mstvf = 1 THEN '', 60'' ELSE '''' END +
				  CASE WHEN is_mm_join = 1 THEN '', 61'' ELSE '''' END  +
                  CASE WHEN is_nonsargable = 1 THEN '', 62'' ELSE '''' END +
				  CASE WHEN CompileTime > 5000 THEN '', 63 '' ELSE '''' END +
				  CASE WHEN CompileCPU > 5000 THEN '', 64 '' ELSE '''' END +
				  CASE WHEN CompileMemory > 1024 AND ((CompileMemory) / (1 * CASE WHEN MaxCompileMemory = 0 THEN 1 ELSE MaxCompileMemory END) * 100.) >= 10. THEN '', 65 '' ELSE '''' END +
				  CASE WHEN select_with_writes > 0 THEN '', 66'' ELSE '''' END
				  , 3, 200000) AS opserver_warning , ' + @nl;
                end;

            set @columns += N'
        CONVERT(NVARCHAR(30), CAST((ExecutionCount) AS BIGINT), 1) AS [# Executions],
        CONVERT(NVARCHAR(30), CAST((ExecutionsPerMinute) AS BIGINT), 1) AS [Executions / Minute],
        CONVERT(NVARCHAR(30), CAST((PercentExecutions) AS BIGINT), 1) AS [Execution Weight],
        CONVERT(NVARCHAR(30), CAST((SerialDesiredMemory) AS BIGINT), 1) AS [Serial Desired Memory],
        CONVERT(NVARCHAR(30), CAST((SerialRequiredMemory) AS BIGINT), 1) AS [Serial Required Memory],
        CONVERT(NVARCHAR(30), CAST((TotalCPU) AS BIGINT), 1) AS [Total CPU (ms)],
        CONVERT(NVARCHAR(30), CAST((AverageCPU) AS BIGINT), 1) AS [Avg CPU (ms)],
        CONVERT(NVARCHAR(30), CAST((PercentCPU) AS BIGINT), 1) AS [CPU Weight],
        CONVERT(NVARCHAR(30), CAST((TotalDuration) AS BIGINT), 1) AS [Total Duration (ms)],
        CONVERT(NVARCHAR(30), CAST((AverageDuration) AS BIGINT), 1) AS [Avg Duration (ms)],
        CONVERT(NVARCHAR(30), CAST((PercentDuration) AS BIGINT), 1) AS [Duration Weight],
        CONVERT(NVARCHAR(30), CAST((TotalReads) AS BIGINT), 1) AS [Total Reads],
        CONVERT(NVARCHAR(30), CAST((AverageReads) AS BIGINT), 1) AS [Average Reads],
        CONVERT(NVARCHAR(30), CAST((PercentReads) AS BIGINT), 1) AS [Read Weight],
        CONVERT(NVARCHAR(30), CAST((TotalWrites) AS BIGINT), 1) AS [Total Writes],
        CONVERT(NVARCHAR(30), CAST((AverageWrites) AS BIGINT), 1) AS [Average Writes],
        CONVERT(NVARCHAR(30), CAST((PercentWrites) AS BIGINT), 1) AS [Write Weight],
        CONVERT(NVARCHAR(30), CAST((PercentExecutionsByType) AS BIGINT), 1) AS [% Executions (Type)],
        CONVERT(NVARCHAR(30), CAST((PercentCPUByType) AS BIGINT), 1) AS [% CPU (Type)],
        CONVERT(NVARCHAR(30), CAST((PercentDurationByType) AS BIGINT), 1) AS [% Duration (Type)],
        CONVERT(NVARCHAR(30), CAST((PercentReadsByType) AS BIGINT), 1) AS [% Reads (Type)],
        CONVERT(NVARCHAR(30), CAST((PercentWritesByType) AS BIGINT), 1) AS [% Writes (Type)],
        CONVERT(NVARCHAR(30), CAST((TotalReturnedRows) AS BIGINT), 1) AS [Total Rows],
        CONVERT(NVARCHAR(30), CAST((AverageReturnedRows) AS BIGINT), 1) AS [Avg Rows],
        CONVERT(NVARCHAR(30), CAST((MinReturnedRows) AS BIGINT), 1) AS [Min Rows],
        CONVERT(NVARCHAR(30), CAST((MaxReturnedRows) AS BIGINT), 1) AS [Max Rows],
		CONVERT(NVARCHAR(30), CAST((MinGrantKB) AS BIGINT), 1) AS [Minimum Memory Grant KB],
		CONVERT(NVARCHAR(30), CAST((MaxGrantKB) AS BIGINT), 1) AS [Maximum Memory Grant KB],
		CONVERT(NVARCHAR(30), CAST((MinUsedGrantKB) AS BIGINT), 1) AS [Minimum Used Grant KB],
		CONVERT(NVARCHAR(30), CAST((MaxUsedGrantKB) AS BIGINT), 1) AS [Maximum Used Grant KB],
		CONVERT(NVARCHAR(30), CAST((AvgMaxMemoryGrant) AS BIGINT), 1) AS [Average Max Memory Grant],
		CONVERT(NVARCHAR(30), CAST((MinSpills) AS BIGINT), 1) AS [Min Spills],
		CONVERT(NVARCHAR(30), CAST((MaxSpills) AS BIGINT), 1) AS [Max Spills],
		CONVERT(NVARCHAR(30), CAST((TotalSpills) AS BIGINT), 1) AS [Total Spills],
		CONVERT(NVARCHAR(30), CAST((AvgSpills) AS MONEY), 1) AS [Avg Spills],
        CONVERT(NVARCHAR(30), CAST((NumberOfPlans) AS BIGINT), 1) AS [# Plans],
        CONVERT(NVARCHAR(30), CAST((NumberOfDistinctPlans) AS BIGINT), 1) AS [# Distinct Plans],
        PlanCreationTime AS [Created At],
        LastExecutionTime AS [Last Execution],
		LastCompletionTime AS [Last Completion],
        CONVERT(NVARCHAR(30), CAST((CachedPlanSize) AS BIGINT), 1) AS [Cached Plan Size (KB)],
        CONVERT(NVARCHAR(30), CAST((CompileTime) AS BIGINT), 1) AS [Compile Time (ms)],
        CONVERT(NVARCHAR(30), CAST((CompileCPU) AS BIGINT), 1) AS [Compile CPU (ms)],
        CONVERT(NVARCHAR(30), CAST((CompileMemory) AS BIGINT), 1) AS [Compile memory (KB)],
        COALESCE(SetOptions, '''') AS [SET Options],
		PlanHandle AS [Plan Handle],
		SqlHandle AS [SQL Handle],
		[SQL Handle More Info],
        QueryHash AS [Query Hash],
		[Query Hash More Info],
        QueryPlanHash AS [Query Plan Hash],
        StatementStartOffset,
        StatementEndOffset,
		[Remove Plan Handle From Cache],
		[Remove SQL Handle From Cache]';
        end;


    set @sql = N'
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT  TOP (@Top) ' + @columns + @nl + N'
FROM    ##BlitzCacheProcs
WHERE   SPID = @spid ' + @nl;

    if @minimumexecutioncount is not null
        begin
            set @sql += N' AND ExecutionCount >= @minimumExecutionCount ' + @nl;
        end;

    if @minutesback is not null
        begin
            set @sql += N' AND LastCompletionTime >= DATEADD(MINUTE, @min_back, GETDATE() ) ' + @nl;
        end;

    select @sql += N' ORDER BY ' + case @sortorder
                                       when N'cpu' then N' TotalCPU '
                                       when N'reads' then N' TotalReads '
                                       when N'writes' then N' TotalWrites '
                                       when N'duration' then N' TotalDuration '
                                       when N'executions' then N' ExecutionCount '
                                       when N'compiles' then N' PlanCreationTime '
                                       when N'memory grant' then N' MaxGrantKB'
                                       when N'spills' then N' MaxSpills'
                                       when N'avg cpu' then N' AverageCPU'
                                       when N'avg reads' then N' AverageReads'
                                       when N'avg writes' then N' AverageWrites'
                                       when N'avg duration' then N' AverageDuration'
                                       when N'avg executions' then N' ExecutionsPerMinute'
                                       when N'avg memory grant' then N' AvgMaxMemoryGrant'
                                       when N'avg spills' then N' AvgSpills'
        end + N' DESC ';
    set @sql += N' OPTION (RECOMPILE) ; ';

    if @debug = 1
        begin
            print SUBSTRING(@sql, 0, 4000);
            print SUBSTRING(@sql, 4000, 8000);
            print SUBSTRING(@sql, 8000, 12000);
            print SUBSTRING(@sql, 12000, 16000);
            print SUBSTRING(@sql, 16000, 20000);
            print SUBSTRING(@sql, 20000, 24000);
            print SUBSTRING(@sql, 24000, 28000);
            print SUBSTRING(@sql, 28000, 32000);
            print SUBSTRING(@sql, 32000, 36000);
            print SUBSTRING(@sql, 36000, 40000);
        end;

    exec sp_executesql @sql, N'@Top INT, @spid INT, @minimumExecutionCount INT, @min_back INT', @top, @@SPID,
         @minimumexecutioncount, @minutesback;


/*

This section will check if:
 * >= 30% of plans were created in the last hour
 * Check on the memory_clerks DMV for space used by TokenAndPermUserStore
 * Compare that to the size of the buffer pool
 * If it's >10%,
*/
    if EXISTS
        (
            select 1 / 0
            from #plan_creation as pc
            where pc.percent_1 >= 30
        )
        begin

            select @common_version =
                   CONVERT(decimal(10, 2), c.common_version)
            from #checkversion as c;

            if @common_version >= 11
                set @user_perm_sql = N'
	SET @buffer_pool_memory_gb = 0;
	SELECT @buffer_pool_memory_gb = SUM(pages_kb)/ 1024. / 1024.
	FROM sys.dm_os_memory_clerks
	WHERE type = ''MEMORYCLERK_SQLBUFFERPOOL'';'
            else
                set @user_perm_sql = N'
	SET @buffer_pool_memory_gb = 0;
	SELECT @buffer_pool_memory_gb = SUM(single_pages_kb + multi_pages_kb)/ 1024. / 1024.
	FROM sys.dm_os_memory_clerks
	WHERE type = ''MEMORYCLERK_SQLBUFFERPOOL'';'

            exec sys.sp_executesql @user_perm_sql,
                 N'@buffer_pool_memory_gb DECIMAL(10,2) OUTPUT',
                 @buffer_pool_memory_gb = @buffer_pool_memory_gb output;

            if @common_version >= 11
                begin
                    set @user_perm_sql = N'
    	SELECT @user_perm_gb = CASE WHEN (pages_kb / 128.0 / 1024.) >= 2.
    			                    THEN CONVERT(DECIMAL(38, 2), (pages_kb / 128.0 / 1024.))
    			                    ELSE 0
    		                   END
    	FROM sys.dm_os_memory_clerks
    	WHERE type = ''USERSTORE_TOKENPERM''
    	AND   name = ''TokenAndPermUserStore'';';
                end;

            if @common_version < 11
                begin
                    set @user_perm_sql = N'
    	SELECT @user_perm_gb = CASE WHEN ((single_pages_kb + multi_pages_kb) / 1024.0 / 1024.) >= 2.
    			                    THEN CONVERT(DECIMAL(38, 2), ((single_pages_kb + multi_pages_kb)  / 1024.0 / 1024.))
    			                    ELSE 0
    		                   END
    	FROM sys.dm_os_memory_clerks
    	WHERE type = ''USERSTORE_TOKENPERM''
    	AND   name = ''TokenAndPermUserStore'';';
                end;

            exec sys.sp_executesql @user_perm_sql,
                 N'@user_perm_gb DECIMAL(10,2) OUTPUT',
                 @user_perm_gb = @user_perm_gb_out output;

            if @buffer_pool_memory_gb > 0
                begin
                    if (@user_perm_gb_out / (1. * @buffer_pool_memory_gb)) * 100. >= 10
                        begin
                            set @is_tokenstore_big = 1;
                            set @user_perm_percent = (@user_perm_gb_out / (1. * @buffer_pool_memory_gb)) * 100.;
                        end
                end

        end


    if @hidesummary = 0 and @exporttoexcel = 0
        begin
            if @reanalyze = 0
                begin
                    raiserror ('Building query plan summary data.', 0, 1) with nowait;

                    /* Build summary data */
                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where frequent_execution = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                1,
                                100,
                                'Execution Pattern',
                                'Frequent Execution',
                                'http://brentozar.com/blitzcache/frequently-executed-queries/',
                                'Queries are being executed more than '
                                    + CAST(@execution_threshold as varchar(5))
                                    +
                                ' times per minute. This can put additional load on the server, even when queries are lightweight.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where parameter_sniffing = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                2,
                                50,
                                'Parameterization',
                                'Parameter Sniffing',
                                'http://brentozar.com/blitzcache/parameter-sniffing/',
                                'There are signs of parameter sniffing (wide variance in rows return or time to execute). Investigate query patterns and tune code appropriately.');

                    /* Forced execution plans */
                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where is_forced_plan = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                3,
                                50,
                                'Parameterization',
                                'Forced Plan',
                                'http://brentozar.com/blitzcache/forced-plans/',
                                'Execution plans have been compiled with forced plans, either through FORCEPLAN, plan guides, or forced parameterization. This will make general tuning efforts less effective.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where is_cursor = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                4,
                                200,
                                'Cursors',
                                'Cursor',
                                'http://brentozar.com/blitzcache/cursors-found-slow-queries/',
                                'There are cursors in the plan cache. This is neither good nor bad, but it is a thing. Cursors are weird in SQL Server.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where is_cursor = 1
                                and is_optimistic_cursor = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                4,
                                200,
                                'Cursors',
                                'Optimistic Cursors',
                                'http://brentozar.com/blitzcache/cursors-found-slow-queries/',
                                'There are optimistic cursors in the plan cache, which can harm performance.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where is_cursor = 1
                                and is_forward_only_cursor = 0
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                4,
                                200,
                                'Cursors',
                                'Non-forward Only Cursors',
                                'http://brentozar.com/blitzcache/cursors-found-slow-queries/',
                                'There are non-forward only cursors in the plan cache, which can harm performance.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where is_cursor = 1
                                and is_cursor_dynamic = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                4,
                                200,
                                'Cursors',
                                'Dynamic Cursors',
                                'http://brentozar.com/blitzcache/cursors-found-slow-queries/',
                                'Dynamic Cursors inhibit parallelism!.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where is_cursor = 1
                                and is_fast_forward_cursor = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                4,
                                200,
                                'Cursors',
                                'Fast Forward Cursors',
                                'http://brentozar.com/blitzcache/cursors-found-slow-queries/',
                                'Fast forward cursors inhibit parallelism!.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where is_forced_parameterized = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                5,
                                50,
                                'Parameterization',
                                'Forced Parameterization',
                                'http://brentozar.com/blitzcache/forced-parameterization/',
                                'Execution plans have been compiled with forced parameterization.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_parallel = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                6,
                                200,
                                'Execution Plans',
                                'Parallel',
                                'http://brentozar.com/blitzcache/parallel-plans-detected/',
                                'Parallel plans detected. These warrant investigation, but are neither good nor bad.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where near_parallel = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                7,
                                200,
                                'Execution Plans',
                                'Nearly Parallel',
                                'http://brentozar.com/blitzcache/query-cost-near-cost-threshold-parallelism/',
                                'Queries near the cost threshold for parallelism. These may go parallel when you least expect it.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where plan_warnings = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                8,
                                50,
                                'Execution Plans',
                                'Plan Warnings',
                                'http://brentozar.com/blitzcache/query-plan-warnings/',
                                'Warnings detected in execution plans. SQL Server is telling you that something bad is going on that requires your attention.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where long_running = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                9,
                                50,
                                'Performance',
                                'Long Running Query',
                                'http://brentozar.com/blitzcache/long-running-queries/',
                                'Long running queries have been found. These are queries with an average duration longer than '
                                    + CAST(@long_running_query_warning_seconds / 1000 / 1000 as varchar(5))
                                    +
                                ' second(s). These queries should be investigated for additional tuning options.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.missing_index_count > 0
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                10,
                                50,
                                'Performance',
                                'Missing Indexes',
                                'http://brentozar.com/blitzcache/missing-index-request/',
                                'Queries found with missing indexes.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.downlevel_estimator = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                13,
                                200,
                                'Cardinality',
                                'Downlevel CE',
                                'http://brentozar.com/blitzcache/legacy-cardinality-estimator/',
                                'A legacy cardinality estimator is being used by one or more queries. Investigate whether you need to be using this cardinality estimator. This may be caused by compatibility levels, global trace flags, or query level trace flags.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where implicit_conversions = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                14,
                                50,
                                'Performance',
                                'Implicit Conversions',
                                'http://brentozar.com/go/implicit',
                                'One or more queries are comparing two fields that are not of the same data type.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where busy_loops = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                16,
                                100,
                                'Performance',
                                'Busy Loops',
                                'http://brentozar.com/blitzcache/busy-loops/',
                                'Operations have been found that are executed 100 times more often than the number of rows returned by each iteration. This is an indicator that something is off in query execution.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where tvf_join = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                17,
                                50,
                                'Performance',
                                'Function Join',
                                'http://brentozar.com/blitzcache/tvf-join/',
                                'Execution plans have been found that join to table valued functions (TVFs). TVFs produce inaccurate estimates of the number of rows returned and can lead to any number of query plan problems.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where compile_timeout = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                18,
                                50,
                                'Execution Plans',
                                'Compilation Timeout',
                                'http://brentozar.com/blitzcache/compilation-timeout/',
                                'Query compilation timed out for one or more queries. SQL Server did not find a plan that meets acceptable performance criteria in the time allotted so the best guess was returned. There is a very good chance that this plan isn''t even below average - it''s probably terrible.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where compile_memory_limit_exceeded = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                19,
                                50,
                                'Execution Plans',
                                'Compile Memory Limit Exceeded',
                                'http://brentozar.com/blitzcache/compile-memory-limit-exceeded/',
                                'The optimizer has a limited amount of memory available. One or more queries are complex enough that SQL Server was unable to allocate enough memory to fully optimize the query. A best fit plan was found, and it''s probably terrible.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where warning_no_join_predicate = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                20,
                                50,
                                'Execution Plans',
                                'No Join Predicate',
                                'http://brentozar.com/blitzcache/no-join-predicate/',
                                'Operators in a query have no join predicate. This means that all rows from one table will be matched with all rows from anther table producing a Cartesian product. That''s a whole lot of rows. This may be your goal, but it''s important to investigate why this is happening.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where plan_multiple_plans > 0
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                21,
                                200,
                                'Execution Plans',
                                'Multiple Plans',
                                'http://brentozar.com/blitzcache/multiple-plans/',
                                'Queries exist with multiple execution plans (as determined by query_plan_hash). Investigate possible ways to parameterize these queries or otherwise reduce the plan count.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where unmatched_index_count > 0
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                22,
                                100,
                                'Performance',
                                'Unmatched Indexes',
                                'http://brentozar.com/blitzcache/unmatched-indexes',
                                'An index could have been used, but SQL Server chose not to use it - likely due to parameterization and filtered indexes.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where unparameterized_query = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                23,
                                100,
                                'Parameterization',
                                'Unparameterized Query',
                                'http://brentozar.com/blitzcache/unparameterized-queries',
                                'Unparameterized queries found. These could be ad hoc queries, data exploration, or queries using "OPTIMIZE FOR UNKNOWN".');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs
                              where is_trivial = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                24,
                                100,
                                'Execution Plans',
                                'Trivial Plans',
                                'http://brentozar.com/blitzcache/trivial-plans',
                                'Trivial plans get almost no optimization. If you''re finding these in the top worst queries, something may be going wrong.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_forced_serial = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                25,
                                10,
                                'Execution Plans',
                                'Forced Serialization',
                                'http://www.brentozar.com/blitzcache/forced-serialization/',
                                'Something in your plan is forcing a serial query. Further investigation is needed if this is not by design.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_key_lookup_expensive = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                26,
                                100,
                                'Execution Plans',
                                'Expensive Key Lookup',
                                'http://www.brentozar.com/blitzcache/expensive-key-lookups/',
                                'There''s a key lookup in your plan that costs >=50% of the total plan cost.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_remote_query_expensive = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                28,
                                100,
                                'Execution Plans',
                                'Expensive Remote Query',
                                'http://www.brentozar.com/blitzcache/expensive-remote-query/',
                                'There''s a remote query in your plan that costs >=50% of the total plan cost.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.trace_flags_session is not null
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                29,
                                200,
                                'Trace Flags',
                                'Session Level Trace Flags Enabled',
                                'https://www.brentozar.com/blitz/trace-flags-enabled-globally/',
                                'Someone is enabling session level Trace Flags in a query.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_unused_grant is not null
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                30,
                                100,
                                'Memory Grant',
                                'Unused Memory Grant',
                                'https://www.brentozar.com/blitzcache/unused-memory-grants/',
                                'Queries have large unused memory grants. This can cause concurrency issues, if queries are waiting a long time to get memory to run.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.function_count > 0
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                31,
                                100,
                                'Compute Scalar That References A Function',
                                'Calls Functions',
                                'https://www.brentozar.com/blitzcache/compute-scalar-functions/',
                                'Both of these will force queries to run serially, run at least once per row, and may result in poor cardinality estimates.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.clr_function_count > 0
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                32,
                                100,
                                'Compute Scalar That References A CLR Function',
                                'Calls CLR Functions',
                                'https://www.brentozar.com/blitzcache/compute-scalar-functions/',
                                'May force queries to run serially, run at least once per row, and may result in poor cardinality estimates.');


                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_table_variable = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                33,
                                100,
                                'Table Variables detected',
                                'Table Variables',
                                'https://www.brentozar.com/blitzcache/table-variables/',
                                'All modifications are single threaded, and selects have really low row estimates.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.no_stats_warning = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                35,
                                100,
                                'Statistics',
                                'Columns With No Statistics',
                                'https://www.brentozar.com/blitzcache/columns-no-statistics/',
                                'Sometimes this happens with indexed views, other times because auto create stats is turned off.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.relop_warnings = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                36,
                                100,
                                'Warnings',
                                'Operator Warnings',
                                'http://brentozar.com/blitzcache/query-plan-warnings/',
                                'Check the plan for more details.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_table_scan = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                37,
                                100,
                                'Indexes',
                                'Table Scans (Heaps)',
                                'https://www.brentozar.com/archive/2012/05/video-heaps/',
                                'This may not be a problem. Run sp_BlitzIndex for more information.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.backwards_scan = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                38,
                                200,
                                'Indexes',
                                'Backwards Scans',
                                'https://www.brentozar.com/blitzcache/backwards-scans/',
                                'This isn''t always a problem. They can cause serial zones in plans, and may need an index to match sort order.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.forced_index = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                39,
                                100,
                                'Indexes',
                                'Forced Indexes',
                                'https://www.brentozar.com/blitzcache/optimizer-forcing/',
                                'This can cause inefficient plans, and will prevent missing index requests.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.forced_seek = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                40,
                                100,
                                'Indexes',
                                'Forced Seeks',
                                'https://www.brentozar.com/blitzcache/optimizer-forcing/',
                                'This can cause inefficient plans by taking seek vs scan choice away from the optimizer.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.forced_scan = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                40,
                                100,
                                'Indexes',
                                'Forced Scans',
                                'https://www.brentozar.com/blitzcache/optimizer-forcing/',
                                'This can cause inefficient plans by taking seek vs scan choice away from the optimizer.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.columnstore_row_mode = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                41,
                                100,
                                'Indexes',
                                'ColumnStore Row Mode',
                                'https://www.brentozar.com/blitzcache/columnstore-indexes-operating-row-mode/',
                                'ColumnStore indexes operating in Row Mode indicate really poor query choices.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_computed_scalar = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                42,
                                50,
                                'Functions',
                                'Computed Column UDF',
                                'https://www.brentozar.com/blitzcache/computed-columns-referencing-functions/',
                                'This can cause a whole mess of bad serializartion problems.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_sort_expensive = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                43,
                                100,
                                'Execution Plans',
                                'Expensive Sort',
                                'http://www.brentozar.com/blitzcache/expensive-sorts/',
                                'There''s a sort in your plan that costs >=50% of the total plan cost.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_computed_filter = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                44,
                                50,
                                'Functions',
                                'Filter UDF',
                                'https://www.brentozar.com/blitzcache/compute-scalar-functions/',
                                'Someone put a Scalar UDF in the WHERE clause!');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.index_ops >= 5
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                45,
                                100,
                                'Indexes',
                                '>= 5 Indexes Modified',
                                'https://www.brentozar.com/blitzcache/many-indexes-modified/',
                                'This can cause lots of hidden I/O -- Run sp_BlitzIndex for more information.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_row_level = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                46,
                                200,
                                'Complexity',
                                'Row Level Security',
                                'https://www.brentozar.com/blitzcache/row-level-security/',
                                'You may see a lot of confusing junk in your query plan.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_spatial = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                47,
                                200,
                                'Complexity',
                                'Spatial Index',
                                'https://www.brentozar.com/blitzcache/spatial-indexes/',
                                'Purely informational.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.index_dml = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                48,
                                150,
                                'Complexity',
                                'Index DML',
                                'https://www.brentozar.com/blitzcache/index-dml/',
                                'This can cause recompiles and stuff.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.table_dml = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                49,
                                150,
                                'Complexity',
                                'Table DML',
                                'https://www.brentozar.com/blitzcache/table-dml/',
                                'This can cause recompiles and stuff.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.long_running_low_cpu = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                50,
                                150,
                                'Blocking',
                                'Long Running Low CPU',
                                'https://www.brentozar.com/blitzcache/long-running-low-cpu/',
                                'This can be a sign of blocking, linked servers, or poor client application code (ASYNC_NETWORK_IO).');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.low_cost_high_cpu = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                51,
                                150,
                                'Complexity',
                                'Low Cost Query With High CPU',
                                'https://www.brentozar.com/blitzcache/low-cost-high-cpu/',
                                'This can be a sign of functions or Dynamic SQL that calls black-box code.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.stale_stats = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                52,
                                150,
                                'Statistics',
                                'Statistics used have > 100k modifications in the last 7 days',
                                'https://www.brentozar.com/blitzcache/stale-statistics/',
                                'Ever heard of updating statistics?');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_adaptive = 1
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                53,
                                200,
                                'Complexity',
                                'Adaptive joins',
                                'https://www.brentozar.com/blitzcache/adaptive-joins/',
                                'This join will sometimes do seeks, and sometimes do scans.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_spool_expensive = 1
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                54,
                                150,
                                'Indexes',
                                'Expensive Index Spool',
                                'https://www.brentozar.com/blitzcache/eager-index-spools/',
                                'Check operator predicates and output for index definition guidance');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_spool_more_rows = 1
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                55,
                                150,
                                'Indexes',
                                'Large Index Row Spool',
                                'https://www.brentozar.com/blitzcache/eager-index-spools/',
                                'Check operator predicates and output for index definition guidance');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_bad_estimate = 1
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                56,
                                100,
                                'Complexity',
                                'Row Estimate Mismatch',
                                'https://www.brentozar.com/blitzcache/bad-estimates/',
                                'Estimated rows are different from average rows by a factor of 10000. This may indicate a performance problem if mismatches occur regularly');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_paul_white_electric = 1
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                57,
                                200,
                                'Is Paul White Electric?',
                                'This query has a Switch operator in it!',
                                'https://www.sql.kiwi/2013/06/hello-operator-my-switch-is-bored.html',
                                'You should email this query plan to Paul: SQLkiwi at gmail dot com');

                    if @v >= 14 or (@v = 13 and @build >= 5026)
                        begin

                            insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                            select @@SPID,
                                   997,
                                   200,
                                   'Database Level Statistics',
                                   'The database ' + sa.[Database] + ' last had a stats update on ' +
                                   CONVERT(nvarchar(10), CONVERT(date, MAX(sa.lastupdate))) + ' and has ' +
                                   CONVERT(nvarchar(10), AVG(sa.modificationcount)) +
                                   ' modifications on average.'                             as [Finding],
                                   'https://www.brentozar.com/blitzcache/stale-statistics/' as url,
                                   'Consider updating statistics more frequently,'          as [Details]
                            from #stats_agg as sa
                            group by sa.[Database]
                            having MAX(sa.lastupdate) <= DATEADD(day, -7, SYSDATETIME())
                               and AVG(sa.modificationcount) >= 100000;

                            if EXISTS(select 1 / 0
                                      from ##blitzcacheprocs p
                                      where p.is_row_goal = 1
                                )
                                insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                                values (@@SPID,
                                        58,
                                        200,
                                        'Complexity',
                                        'Row Goals',
                                        'https://www.brentozar.com/go/rowgoals/',
                                        'This query had row goals introduced, which can be good or bad, and should be investigated for high read queries.');

                            if EXISTS(select 1 / 0
                                      from ##blitzcacheprocs p
                                      where p.is_big_spills = 1
                                )
                                insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                                values (@@SPID,
                                        59,
                                        100,
                                        'TempDB',
                                        '>500mb Spills',
                                        'https://www.brentozar.com/blitzcache/tempdb-spills/',
                                        'This query spills >500mb to tempdb on average. One way or another, this query didn''t get enough memory');


                        end;

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_mstvf = 1
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                60,
                                100,
                                'Functions',
                                'MSTVFs',
                                'http://brentozar.com/blitzcache/tvf-join/',
                                'Execution plans have been found that join to table valued functions (TVFs). TVFs produce inaccurate estimates of the number of rows returned and can lead to any number of query plan problems.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_mm_join = 1
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                61,
                                100,
                                'Complexity',
                                'Many to Many Merge',
                                'https://www.brentozar.com/archive/2018/04/many-mysteries-merge-joins/',
                                'These use secret worktables that could be doing lots of reads. Occurs when join inputs aren''t known to be unique. Can be really bad when parallel.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_nonsargable = 1
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                62,
                                50,
                                'Non-SARGable queries',
                                'non-SARGables',
                                'https://www.brentozar.com/blitzcache/non-sargable-predicates/',
                                'Looks for intrinsic functions and expressions as predicates, and leading wildcard LIKE searches.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where compiletime > 5000
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                63,
                                100,
                                'Complexity',
                                'Long Compile Time',
                                'https://www.brentozar.com/blitzcache/high-compilers/',
                                'Queries are taking >5 seconds to compile. This can be normal for large plans, but be careful if they compile frequently');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where compilecpu > 5000
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                64,
                                50,
                                'Complexity',
                                'High Compile CPU',
                                'https://www.brentozar.com/blitzcache/high-compilers/',
                                'Queries taking >5 seconds of CPU to compile. If CPU is high and plans like this compile frequently, they may be related');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where compilememory > 1024
                                and ((compilememory) /
                                     (1 * case when maxcompilememory = 0 then 1 else maxcompilememory end) * 100.) >=
                                    10.
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                65,
                                50,
                                'Complexity',
                                'High Compile Memory',
                                'https://www.brentozar.com/blitzcache/high-compilers/',
                                'Queries taking 10% of Max Compile Memory. If you see high RESOURCE_SEMAPHORE_QUERY_COMPILE waits, these may be related');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.select_with_writes = 1
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                66,
                                50,
                                'Complexity',
                                'Selects w/ Writes',
                                'https://dba.stackexchange.com/questions/191825/',
                                'This is thrown when reads cause writes that are not already flagged as big spills (2016+) or index spools.');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_table_spool_expensive = 1
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                67,
                                150,
                                'Expensive Table Spool',
                                'You have a table spool, this is usually a sign that queries are doing unnecessary work',
                                'https://sqlperformance.com/2019/09/sql-performance/nested-loops-joins-performance-spools',
                                'Check for non-SARGable predicates, or a lot of work being done inside a nested loops join');

                    if EXISTS(select 1 / 0
                              from ##blitzcacheprocs p
                              where p.is_table_spool_more_rows = 1
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                68,
                                150,
                                'Table Spools Many Rows',
                                'You have a table spool that spools more rows than the query returns',
                                'https://sqlperformance.com/2019/09/sql-performance/nested-loops-joins-performance-spools',
                                'Check for non-SARGable predicates, or a lot of work being done inside a nested loops join');

                    if EXISTS(select 1 / 0
                              from #plan_creation p
                              where (p.percent_24 > 0)
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        select spid,
                               999,
                               case when ISNULL(p.percent_24, 0) > 75 then 1 else 254 end as priority,
                               'Plan Cache Information',
                               case
                                   when ISNULL(p.percent_24, 0) > 75 then 'Plan Cache Instability'
                                   else 'Plan Cache Stability' end                        as finding,
                               'https://www.brentozar.com/archive/2018/07/tsql2sday-how-much-plan-cache-history-do-you-have/',
                               'You have ' + CONVERT(nvarchar(10), ISNULL(p.total_plans, 0))
                                   + ' total plans in your cache, with '
                                   + CONVERT(nvarchar(10), ISNULL(p.percent_24, 0))
                                   + '% plans created in the past 24 hours, '
                                   + CONVERT(nvarchar(10), ISNULL(p.percent_4, 0))
                                   + '% created in the past 4 hours, and '
                                   + CONVERT(nvarchar(10), ISNULL(p.percent_1, 0))
                                   + '% created in the past 1 hour. '
                                   +
                               'When these percentages are high, it may be a sign of memory pressure or plan cache instability.'
                        from #plan_creation p;

                    if EXISTS(select 1 / 0
                              from #plan_usage p
                              where p.percent_duplicate > 5
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        select spid,
                               999,
                               case when ISNULL(p.percent_duplicate, 0) > 75 then 1 else 254 end as priority,
                               'Plan Cache Information',
                               case
                                   when ISNULL(p.percent_duplicate, 0) > 75 then 'Many Duplicate Plans'
                                   else 'Duplicate Plans' end                                    as finding,
                               'https://www.brentozar.com/archive/2018/03/why-multiple-plans-for-one-query-are-bad/',
                               'You have ' + CONVERT(nvarchar(10), p.total_plans)
                                   + ' plans in your cache, and '
                                   + CONVERT(nvarchar(10), p.percent_duplicate)
                                   + '% are duplicates with more than 5 entries'
                                   + ', meaning similar queries are generating the same plan repeatedly.'
                                   +
                               ' Forced Parameterization may fix the issue. To find troublemakers, use: EXEC sp_BlitzCache @SortOrder = ''query hash''; '
                        from #plan_usage as p;

                    if EXISTS(select 1 / 0
                              from #plan_usage p
                              where p.percent_single > 5
                                and spid = @@SPID)
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        select spid,
                               999,
                               case when ISNULL(p.percent_single, 0) > 75 then 1 else 254 end as priority,
                               'Plan Cache Information',
                               case
                                   when ISNULL(p.percent_single, 0) > 75 then 'Many Single-Use Plans'
                                   else 'Single-Use Plans' end                                as finding,
                               'https://www.brentozar.com/blitz/single-use-plans-procedure-cache/',
                               'You have ' + CONVERT(nvarchar(10), p.total_plans)
                                   + ' plans in your cache, and '
                                   + CONVERT(nvarchar(10), p.percent_single)
                                   + '% are single use plans'
                                   +
                               ', meaning SQL Server thinks it''s seeing a lot of "new" queries and creating plans for them.'
                                   + ' Forced Parameterization and/or Optimize For Ad Hoc Workloads may fix the issue.'
                                   + 'To find troublemakers, use: EXEC sp_BlitzCache @SortOrder = ''query hash''; '
                        from #plan_usage as p;

                    if @is_tokenstore_big = 1
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        select @@SPID,
                               69,
                               10,
                               N'Large USERSTORE_TOKENPERM cache: ' + CONVERT(nvarchar(11), @user_perm_gb_out) + N'GB',
                               N'The USERSTORE_TOKENPERM is taking up ' + CONVERT(nvarchar(11), @user_perm_percent)
                                   + N'% of the buffer pool, and your plan cache seems to be unstable',
                               N'https://brentozar.com/go/userstore',
                               N'A growing USERSTORE_TOKENPERM cache can cause the plan cache to clear out'

                    if @v >= 11
                        begin
                            if EXISTS(select 1 / 0
                                      from #trace_flags as tf
                                      where tf.global_trace_flags is not null
                                )
                                insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                                values (@@SPID,
                                        1000,
                                        255,
                                        'Global Trace Flags Enabled',
                                        'You have Global Trace Flags enabled on your server',
                                        'https://www.brentozar.com/blitz/trace-flags-enabled-globally/',
                                        'You have the following Global Trace Flags enabled: ' +
                                        (select top 1 tf.global_trace_flags
                                         from #trace_flags as tf
                                         where tf.global_trace_flags is not null));
                        end;

                    if not EXISTS(select 1 / 0
                                  from ##blitzcacheresults as bcr
                                  where bcr.priority = 2147483646
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                2147483646,
                                255,
                                'Need more help?',
                                'Paste your plan on the internet!',
                                'http://pastetheplan.com',
                                'This makes it easy to share plans and post them to Q&A sites like https://dba.stackexchange.com/!');


                    if not EXISTS(select 1 / 0
                                  from ##blitzcacheresults as bcr
                                  where bcr.priority = 2147483647
                        )
                        insert into ##blitzcacheresults (spid, checkid, priority, findingsgroup, finding, url, details)
                        values (@@SPID,
                                2147483647,
                                255,
                                'Thanks for using sp_BlitzCache!',
                                'From Your Community Volunteers',
                                'http://FirstResponderKit.org',
                                'We hope you found this tool useful. Current version: ' + @version + ' released on ' +
                                CONVERT(nvarchar(30), @versiondate) + '.');

                end;


            select priority,
                   findingsgroup,
                   finding,
                   url,
                   details,
                   checkid
            from ##blitzcacheresults
            where spid = @@SPID
            group by priority,
                     findingsgroup,
                     finding,
                     url,
                     details,
                     checkid
            order by priority asc, findingsgroup, finding, checkid asc
            option (recompile);
        end;

    if @debug = 1
        begin

            select '##BlitzCacheResults' as table_name, *
            from ##blitzcacheresults
            option ( recompile );

            select '##BlitzCacheProcs' as table_name, *
            from ##blitzcacheprocs
            option ( recompile );

            select '#statements' as table_name, *
            from #statements as s
            option (recompile);

            select '#query_plan' as table_name, *
            from #query_plan as qp
            option (recompile);

            select '#relop' as table_name, *
            from #relop as r
            option (recompile);

            select '#only_query_hashes' as table_name, *
            from #only_query_hashes
            option ( recompile );

            select '#ignore_query_hashes' as table_name, *
            from #ignore_query_hashes
            option ( recompile );

            select '#only_sql_handles' as table_name, *
            from #only_sql_handles
            option ( recompile );

            select '#ignore_sql_handles' as table_name, *
            from #ignore_sql_handles
            option ( recompile );

            select '#p' as table_name, *
            from #p
            option ( recompile );

            select '#checkversion' as table_name, *
            from #checkversion
            option ( recompile );

            select '#configuration' as table_name, *
            from #configuration
            option ( recompile );

            select '#stored_proc_info' as table_name, *
            from #stored_proc_info
            option ( recompile );

            select '#conversion_info' as table_name, *
            from #conversion_info as ci
            option ( recompile );

            select '#variable_info' as table_name, *
            from #variable_info as vi
            option ( recompile );

            select '#missing_index_xml' as table_name, *
            from #missing_index_xml as mix
            option ( recompile );

            select '#missing_index_schema' as table_name, *
            from #missing_index_schema as mis
            option ( recompile );

            select '#missing_index_usage' as table_name, *
            from #missing_index_usage as miu
            option ( recompile );

            select '#missing_index_detail' as table_name, *
            from #missing_index_detail as mid
            option ( recompile );

            select '#missing_index_pretty' as table_name, *
            from #missing_index_pretty as mip
            option ( recompile );

            select '#plan_creation' as table_name, *
            from #plan_creation
            option ( recompile );

            select '#plan_cost' as table_name, *
            from #plan_cost
            option ( recompile );

            select '#proc_costs' as table_name, *
            from #proc_costs
            option ( recompile );

            select '#stats_agg' as table_name, *
            from #stats_agg
            option ( recompile );

            select '#trace_flags' as table_name, *
            from #trace_flags
            option ( recompile );

            select '#plan_usage' as table_name, *
            from #plan_usage
            option ( recompile );

        end;

    if @outputdatabasename is not null
        and @outputschemaname is not null
        and @outputtablename is not null
        goto outputresultstotable;
    return;
    --Avoid going into the AllSort GOTO

/*Begin code to sort by all*/
    allsorts:
    raiserror ('Beginning all sort loop', 0, 1) with nowait;


    if (
            @top > 10
            and @skipanalysis = 0
            and @bringthepain = 0
        )
        begin
            raiserror (
                '
		  You''ve chosen a value greater than 10 to sort the whole plan cache by.
		  That can take a long time and harm performance.
		  Please choose a number <= 10, or set @BringThePain = 1 to signify you understand this might be a bad idea.
		          ', 0, 1) with nowait;
            return;
        end;


    if OBJECT_ID('tempdb..#checkversion_allsort') is null
        begin
            create table #checkversion_allsort
            (
                version nvarchar(128),
                common_version as SUBSTRING(version, 1, CHARINDEX('.', version) + 1),
                major as PARSENAME(CONVERT(varchar(32), version), 4),
                minor as PARSENAME(CONVERT(varchar(32), version), 3),
                build as PARSENAME(CONVERT(varchar(32), version), 2),
                revision as PARSENAME(CONVERT(varchar(32), version), 1)
            );

            insert into #checkversion_allsort
                (version)
            select CAST(SERVERPROPERTY('ProductVersion') as nvarchar(128))
            option ( recompile );
        end;


    select @v = common_version,
           @build = build
    from #checkversion_allsort
    option ( recompile );

    if OBJECT_ID('tempdb.. #bou_allsort') is null
        begin
            create table #bou_allsort
            (
                id int identity (1, 1),
                databasename nvarchar(128),
                cost float,
                querytext nvarchar(max),
                querytype nvarchar(258),
                warnings varchar(max),
                queryplan xml,
                missing_indexes xml,
                implicit_conversion_info xml,
                cached_execution_parameters xml,
                executioncount nvarchar(30),
                executionsperminute money,
                executionweight money,
                totalcpu nvarchar(30),
                averagecpu nvarchar(30),
                cpuweight money,
                totalduration nvarchar(30),
                averageduration nvarchar(30),
                durationweight money,
                totalreads nvarchar(30),
                averagereads nvarchar(30),
                readweight money,
                totalwrites nvarchar(30),
                averagewrites nvarchar(30),
                writeweight money,
                averagereturnedrows money,
                mingrantkb nvarchar(30),
                maxgrantkb nvarchar(30),
                minusedgrantkb nvarchar(30),
                maxusedgrantkb nvarchar(30),
                avgmaxmemorygrant money,
                minspills nvarchar(30),
                maxspills nvarchar(30),
                totalspills nvarchar(30),
                avgspills money,
                plancreationtime datetime,
                lastexecutiontime datetime,
                lastcompletiontime datetime,
                planhandle varbinary(64),
                sqlhandle varbinary(64),
                setoptions varchar(max),
                removeplanhandlefromcache nvarchar(200),
                pattern nvarchar(20)
            );
        end;


    if LOWER(@sortorder) = 'all'
        begin
            raiserror ('Beginning for ALL', 0, 1) with nowait;
            set @allsortsql += N'
					DECLARE @ISH NVARCHAR(MAX) = N''''

					INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

					 EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''cpu'',
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

					 UPDATE #bou_allsort SET Pattern = ''cpu'' WHERE Pattern IS NULL OPTION(RECOMPILE);

					 SELECT TOP 1 @ISH = STUFF((SELECT DISTINCT N'','' + CONVERT(NVARCHAR(MAX),b2.SqlHandle, 1) FROM #bou_allsort AS b2 FOR XML PATH(N''''), TYPE).value(N''.[1]'', N''NVARCHAR(MAX)''), 1, 1, N'''') OPTION(RECOMPILE);

					INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

					 EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''reads'', @IgnoreSqlHandles = @ISH,
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

					 UPDATE #bou_allsort SET Pattern = ''reads'' WHERE Pattern IS NULL OPTION(RECOMPILE);

					 SELECT TOP 1 @ISH = STUFF((SELECT DISTINCT N'','' + CONVERT(NVARCHAR(MAX),b2.SqlHandle, 1) FROM #bou_allsort AS b2 FOR XML PATH(N''''), TYPE).value(N''.[1]'', N''NVARCHAR(MAX)''), 1, 1, N'''') OPTION(RECOMPILE);

					INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

					 EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''writes'', @IgnoreSqlHandles = @ISH,
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

					 UPDATE #bou_allsort SET Pattern = ''writes'' WHERE Pattern IS NULL OPTION(RECOMPILE);

					 SELECT TOP 1 @ISH = STUFF((SELECT DISTINCT N'','' + CONVERT(NVARCHAR(MAX),b2.SqlHandle, 1) FROM #bou_allsort AS b2 FOR XML PATH(N''''), TYPE).value(N''.[1]'', N''NVARCHAR(MAX)''), 1, 1, N'''') OPTION(RECOMPILE);

					INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

					 EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''duration'', @IgnoreSqlHandles = @ISH,
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

					 UPDATE #bou_allsort SET Pattern = ''duration'' WHERE Pattern IS NULL OPTION(RECOMPILE);

					 SELECT TOP 1 @ISH = STUFF((SELECT DISTINCT N'','' + CONVERT(NVARCHAR(MAX),b2.SqlHandle, 1) FROM #bou_allsort AS b2 FOR XML PATH(N''''), TYPE).value(N''.[1]'', N''NVARCHAR(MAX)''), 1, 1, N'''') OPTION(RECOMPILE);

					INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

					 EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''executions'', @IgnoreSqlHandles = @ISH,
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

					 UPDATE #bou_allsort SET Pattern = ''executions'' WHERE Pattern IS NULL OPTION(RECOMPILE);

					 ';

            if @versionshowsmemorygrants = 0
                begin
                    if @exporttoexcel = 1
                        begin
                            set @allsortsql += N'  UPDATE #bou_allsort
												   SET
													QueryPlan = NULL,
													implicit_conversion_info = NULL,
													cached_execution_parameters = NULL,
													missing_indexes = NULL
												   OPTION (RECOMPILE);

												   UPDATE ##BlitzCacheProcs
												   SET QueryText = SUBSTRING(REPLACE(REPLACE(REPLACE(LTRIM(RTRIM(QueryText)),'' '',''<>''),''><'',''''),''<>'','' ''), 1, 32000)
												   OPTION(RECOMPILE);';
                        end;

                end;

            if @versionshowsmemorygrants = 1
                begin
                    set @allsortsql += N' SELECT TOP 1 @ISH = STUFF((SELECT DISTINCT N'','' + CONVERT(NVARCHAR(MAX),b2.SqlHandle, 1) FROM #bou_allsort AS b2 FOR XML PATH(N''''), TYPE).value(N''.[1]'', N''NVARCHAR(MAX)''), 1, 1, N'''') OPTION(RECOMPILE);

					INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

										  EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''memory grant'', @IgnoreSqlHandles = @ISH,
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

										  UPDATE #bou_allsort SET Pattern = ''memory grant'' WHERE Pattern IS NULL OPTION(RECOMPILE);';
                    if @exporttoexcel = 1
                        begin
                            set @allsortsql += N'  UPDATE #bou_allsort
												   SET
													QueryPlan = NULL,
													implicit_conversion_info = NULL,
													cached_execution_parameters = NULL,
													missing_indexes = NULL
												   OPTION (RECOMPILE);

												   UPDATE ##BlitzCacheProcs
												   SET QueryText = SUBSTRING(REPLACE(REPLACE(REPLACE(LTRIM(RTRIM(QueryText)),'' '',''<>''),''><'',''''),''<>'','' ''), 1, 32000)
												   OPTION(RECOMPILE);';
                        end;

                end;

            if @versionshowsspills = 0
                begin
                    if @exporttoexcel = 1
                        begin
                            set @allsortsql += N'  UPDATE #bou_allsort
												   SET
													QueryPlan = NULL,
													implicit_conversion_info = NULL,
													cached_execution_parameters = NULL,
													missing_indexes = NULL
												   OPTION (RECOMPILE);

												   UPDATE ##BlitzCacheProcs
												   SET QueryText = SUBSTRING(REPLACE(REPLACE(REPLACE(LTRIM(RTRIM(QueryText)),'' '',''<>''),''><'',''''),''<>'','' ''), 1, 32000)
												   OPTION(RECOMPILE);';
                        end;

                end;

            if @versionshowsspills = 1
                begin
                    set @allsortsql += N' SELECT TOP 1 @ISH = STUFF((SELECT DISTINCT N'','' + CONVERT(NVARCHAR(MAX),b2.SqlHandle, 1) FROM #bou_allsort AS b2 FOR XML PATH(N''''), TYPE).value(N''.[1]'', N''NVARCHAR(MAX)''), 1, 1, N'''') OPTION(RECOMPILE);

					INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

										  EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''spills'', @IgnoreSqlHandles = @ISH,
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

										  UPDATE #bou_allsort SET Pattern = ''spills'' WHERE Pattern IS NULL OPTION(RECOMPILE);';
                    if @exporttoexcel = 1
                        begin
                            set @allsortsql += N'  UPDATE #bou_allsort
												   SET
													QueryPlan = NULL,
													implicit_conversion_info = NULL,
													cached_execution_parameters = NULL,
													missing_indexes = NULL
												   OPTION (RECOMPILE);

												   UPDATE ##BlitzCacheProcs
												   SET QueryText = SUBSTRING(REPLACE(REPLACE(REPLACE(LTRIM(RTRIM(QueryText)),'' '',''<>''),''><'',''''),''<>'','' ''), 1, 32000)
												   OPTION(RECOMPILE);';
                        end;

                end;
            set @allsortsql += N' SELECT DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters,ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
										  TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
										  ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
										  MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache, Pattern
										  FROM #bou_allsort
										  ORDER BY Id
										  OPTION(RECOMPILE);  ';


        end;


    if LOWER(@sortorder) = 'all avg'
        begin
            raiserror ('Beginning for ALL AVG', 0, 1) with nowait;
            set @allsortsql += N'
					DECLARE @ISH NVARCHAR(MAX) = N''''

					INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

					 EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''avg cpu'',
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

					 UPDATE #bou_allsort SET Pattern = ''avg cpu'' WHERE Pattern IS NULL OPTION(RECOMPILE);

					 SELECT TOP 1 @ISH = STUFF((SELECT DISTINCT N'','' + CONVERT(NVARCHAR(MAX),b2.SqlHandle, 1) FROM #bou_allsort AS b2 FOR XML PATH(N''''), TYPE).value(N''.[1]'', N''NVARCHAR(MAX)''), 1, 1, N'''') OPTION(RECOMPILE);

					INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

					 EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''avg reads'', @IgnoreSqlHandles = @ISH,
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

					 UPDATE #bou_allsort SET Pattern = ''avg reads'' WHERE Pattern IS NULL OPTION(RECOMPILE);

					 SELECT TOP 1 @ISH = STUFF((SELECT DISTINCT N'','' + CONVERT(NVARCHAR(MAX),b2.SqlHandle, 1) FROM #bou_allsort AS b2 FOR XML PATH(N''''), TYPE).value(N''.[1]'', N''NVARCHAR(MAX)''), 1, 1, N'''') OPTION(RECOMPILE);

					INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

					 EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''avg writes'', @IgnoreSqlHandles = @ISH,
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

					 UPDATE #bou_allsort SET Pattern = ''avg writes'' WHERE Pattern IS NULL OPTION(RECOMPILE);

					 SELECT TOP 1 @ISH = STUFF((SELECT DISTINCT N'','' + CONVERT(NVARCHAR(MAX),b2.SqlHandle, 1) FROM #bou_allsort AS b2 FOR XML PATH(N''''), TYPE).value(N''.[1]'', N''NVARCHAR(MAX)''), 1, 1, N'''') OPTION(RECOMPILE);

					INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

					 EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''avg duration'', @IgnoreSqlHandles = @ISH,
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

					 UPDATE #bou_allsort SET Pattern = ''avg duration'' WHERE Pattern IS NULL OPTION(RECOMPILE);

					 SELECT TOP 1 @ISH = STUFF((SELECT DISTINCT N'','' + CONVERT(NVARCHAR(MAX),b2.SqlHandle, 1) FROM #bou_allsort AS b2 FOR XML PATH(N''''), TYPE).value(N''.[1]'', N''NVARCHAR(MAX)''), 1, 1, N'''') OPTION(RECOMPILE);

					INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

					 EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''avg executions'', @IgnoreSqlHandles = @ISH,
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

					 UPDATE #bou_allsort SET Pattern = ''avg executions'' WHERE Pattern IS NULL OPTION(RECOMPILE);

					 ';

            if @versionshowsmemorygrants = 0
                begin
                    if @exporttoexcel = 1
                        begin
                            set @allsortsql += N'  UPDATE #bou_allsort
												   SET
													QueryPlan = NULL,
													implicit_conversion_info = NULL,
													cached_execution_parameters = NULL,
													missing_indexes = NULL
												   OPTION (RECOMPILE);

												   UPDATE ##BlitzCacheProcs
												   SET QueryText = SUBSTRING(REPLACE(REPLACE(REPLACE(LTRIM(RTRIM(QueryText)),'' '',''<>''),''><'',''''),''<>'','' ''), 1, 32000)
												   OPTION(RECOMPILE);';
                        end;

                end;

            if @versionshowsmemorygrants = 1
                begin
                    set @allsortsql += N' SELECT TOP 1 @ISH = STUFF((SELECT DISTINCT N'','' + CONVERT(NVARCHAR(MAX),b2.SqlHandle, 1) FROM #bou_allsort AS b2 FOR XML PATH(N''''), TYPE).value(N''.[1]'', N''NVARCHAR(MAX)''), 1, 1, N'''') OPTION(RECOMPILE);

						INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

										  EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''avg memory grant'', @IgnoreSqlHandles = @ISH,
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

										  UPDATE #bou_allsort SET Pattern = ''avg memory grant'' WHERE Pattern IS NULL OPTION(RECOMPILE);';
                    if @exporttoexcel = 1
                        begin
                            set @allsortsql += N'  UPDATE #bou_allsort
												   SET
													QueryPlan = NULL,
													implicit_conversion_info = NULL,
													cached_execution_parameters = NULL,
													missing_indexes = NULL
												   OPTION (RECOMPILE);

												   UPDATE ##BlitzCacheProcs
												   SET QueryText = SUBSTRING(REPLACE(REPLACE(REPLACE(LTRIM(RTRIM(QueryText)),'' '',''<>''),''><'',''''),''<>'','' ''), 1, 32000)
												   OPTION(RECOMPILE);';
                        end;

                end;

            if @versionshowsspills = 0
                begin
                    if @exporttoexcel = 1
                        begin
                            set @allsortsql += N'  UPDATE #bou_allsort
												   SET
													QueryPlan = NULL,
													implicit_conversion_info = NULL,
													cached_execution_parameters = NULL,
													missing_indexes = NULL
												   OPTION (RECOMPILE);

												   UPDATE ##BlitzCacheProcs
												   SET QueryText = SUBSTRING(REPLACE(REPLACE(REPLACE(LTRIM(RTRIM(QueryText)),'' '',''<>''),''><'',''''),''<>'','' ''), 1, 32000)
												   OPTION(RECOMPILE);';
                        end;

                end;

            if @versionshowsspills = 1
                begin
                    set @allsortsql += N' SELECT TOP 1 @ISH = STUFF((SELECT DISTINCT N'','' + CONVERT(NVARCHAR(MAX),b2.SqlHandle, 1) FROM #bou_allsort AS b2 FOR XML PATH(N''''), TYPE).value(N''.[1]'', N''NVARCHAR(MAX)''), 1, 1, N'''') OPTION(RECOMPILE);

						INSERT #bou_allsort (	DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters, ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
											TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
											ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
											MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache )

										  EXEC sp_BlitzCache @ExpertMode = 0, @HideSummary = 1, @Top = @i_Top, @SortOrder = ''avg spills'', @IgnoreSqlHandles = @ISH,
                     @DatabaseName = @i_DatabaseName, @SkipAnalysis = @i_SkipAnalysis, @OutputDatabaseName = @i_OutputDatabaseName, @OutputSchemaName = @i_OutputSchemaName, @OutputTableName = @i_OutputTableName, @CheckDateOverride = @i_CheckDateOverride, @MinutesBack = @i_MinutesBack WITH RECOMPILE;

										  UPDATE #bou_allsort SET Pattern = ''avg memory grant'' WHERE Pattern IS NULL OPTION(RECOMPILE);';
                    if @exporttoexcel = 1
                        begin
                            set @allsortsql += N'  UPDATE #bou_allsort
												   SET
													QueryPlan = NULL,
													implicit_conversion_info = NULL,
													cached_execution_parameters = NULL,
													missing_indexes = NULL
												   OPTION (RECOMPILE);

												   UPDATE ##BlitzCacheProcs
												   SET QueryText = SUBSTRING(REPLACE(REPLACE(REPLACE(LTRIM(RTRIM(QueryText)),'' '',''<>''),''><'',''''),''<>'','' ''), 1, 32000)
												   OPTION(RECOMPILE);';
                        end;

                end;

            set @allsortsql += N' SELECT DatabaseName, Cost, QueryText, QueryType, Warnings, QueryPlan, missing_indexes, implicit_conversion_info, cached_execution_parameters,ExecutionCount, ExecutionsPerMinute, ExecutionWeight,
										  TotalCPU, AverageCPU, CPUWeight, TotalDuration, AverageDuration, DurationWeight, TotalReads, AverageReads,
										  ReadWeight, TotalWrites, AverageWrites, WriteWeight, AverageReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB,
										  MaxUsedGrantKB, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, SetOptions, RemovePlanHandleFromCache, Pattern
										  FROM #bou_allsort
										  ORDER BY Id
										  OPTION(RECOMPILE);  ';
        end;

    if @debug = 1
        begin
            print SUBSTRING(@allsortsql, 0, 4000);
            print SUBSTRING(@allsortsql, 4000, 8000);
            print SUBSTRING(@allsortsql, 8000, 12000);
            print SUBSTRING(@allsortsql, 12000, 16000);
            print SUBSTRING(@allsortsql, 16000, 20000);
            print SUBSTRING(@allsortsql, 20000, 24000);
            print SUBSTRING(@allsortsql, 24000, 28000);
            print SUBSTRING(@allsortsql, 28000, 32000);
            print SUBSTRING(@allsortsql, 32000, 36000);
            print SUBSTRING(@allsortsql, 36000, 40000);
        end;

    exec sys.sp_executesql @stmt = @allsortsql,
         @params = N'@i_DatabaseName NVARCHAR(128), @i_Top INT, @i_SkipAnalysis BIT, @i_OutputDatabaseName NVARCHAR(258), @i_OutputSchemaName NVARCHAR(258), @i_OutputTableName NVARCHAR(258), @i_CheckDateOverride DATETIMEOFFSET, @i_MinutesBack INT ',
         @i_databasename = @databasename, @i_top = @top, @i_skipanalysis = @skipanalysis,
         @i_outputdatabasename = @outputdatabasename, @i_outputschemaname = @outputschemaname,
         @i_outputtablename = @outputtablename, @i_checkdateoverride = @checkdateoverride,
         @i_minutesback = @minutesback;


    /*End of AllSort section*/


/*Begin code to sort by all*/
    outputresultstotable:

    if @outputdatabasename is not null
        and @outputschemaname is not null
        and @outputtablename is not null
        begin
            raiserror ('Writing results to table.', 0, 1) with nowait;

            select @outputdatabasename = QUOTENAME(@outputdatabasename),
                   @outputschemaname = QUOTENAME(@outputschemaname),
                   @outputtablename = QUOTENAME(@outputtablename);

            /* send results to a table */
            declare @insert_sql nvarchar(max) = N'';

            set @insert_sql = 'USE '
                + @outputdatabasename
                + '; IF EXISTS(SELECT * FROM '
                + @outputdatabasename
                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                + @outputschemaname
                + ''') AND NOT EXISTS (SELECT * FROM '
                + @outputdatabasename
                + '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
                + @outputschemaname + ''' AND QUOTENAME(TABLE_NAME) = '''
                + @outputtablename + ''') CREATE TABLE '
                + @outputschemaname + '.'
                + @outputtablename
                + N'(ID bigint NOT NULL IDENTITY(1,1),
          ServerName NVARCHAR(258),
		  CheckDate DATETIMEOFFSET,
          Version NVARCHAR(258),
          QueryType NVARCHAR(258),
          Warnings varchar(max),
          DatabaseName sysname,
          SerialDesiredMemory float,
          SerialRequiredMemory float,
          AverageCPU bigint,
          TotalCPU bigint,
          PercentCPUByType money,
          CPUWeight money,
          AverageDuration bigint,
          TotalDuration bigint,
          DurationWeight money,
          PercentDurationByType money,
          AverageReads bigint,
          TotalReads bigint,
          ReadWeight money,
          PercentReadsByType money,
          AverageWrites bigint,
          TotalWrites bigint,
          WriteWeight money,
          PercentWritesByType money,
          ExecutionCount bigint,
          ExecutionWeight money,
          PercentExecutionsByType money,' + N'
          ExecutionsPerMinute money,
          PlanCreationTime datetime,
		  PlanCreationTimeHours AS DATEDIFF(HOUR, PlanCreationTime, SYSDATETIME()),
          LastExecutionTime datetime,
		  LastCompletionTime datetime,
		  PlanHandle varbinary(64),
		  [Remove Plan Handle From Cache] AS
			CASE WHEN [PlanHandle] IS NOT NULL
			THEN ''DBCC FREEPROCCACHE ('' + CONVERT(VARCHAR(128), [PlanHandle], 1) + '');''
			ELSE ''N/A'' END,
		  SqlHandle varbinary(64),
			[Remove SQL Handle From Cache] AS
			CASE WHEN [SqlHandle] IS NOT NULL
			THEN ''DBCC FREEPROCCACHE ('' + CONVERT(VARCHAR(128), [SqlHandle], 1) + '');''
			ELSE ''N/A'' END,
		  [SQL Handle More Info] AS
			CASE WHEN [SqlHandle] IS NOT NULL
			THEN ''EXEC sp_BlitzCache @OnlySqlHandles = '''''' + CONVERT(VARCHAR(128), [SqlHandle], 1) + ''''''; ''
			ELSE ''N/A'' END,
		  QueryHash binary(8),
		  [Query Hash More Info] AS
			CASE WHEN [QueryHash] IS NOT NULL
			THEN ''EXEC sp_BlitzCache @OnlyQueryHashes = '''''' + CONVERT(VARCHAR(32), [QueryHash], 1) + ''''''; ''
			ELSE ''N/A'' END,
          QueryPlanHash binary(8),
          StatementStartOffset int,
          StatementEndOffset int,
          MinReturnedRows bigint,
          MaxReturnedRows bigint,
          AverageReturnedRows money,
          TotalReturnedRows bigint,
          QueryText nvarchar(max),
          QueryPlan xml,
          NumberOfPlans int,
          NumberOfDistinctPlans int,
		  MinGrantKB BIGINT,
		  MaxGrantKB BIGINT,
		  MinUsedGrantKB BIGINT,
		  MaxUsedGrantKB BIGINT,
		  PercentMemoryGrantUsed MONEY,
		  AvgMaxMemoryGrant MONEY,
		  MinSpills BIGINT,
		  MaxSpills BIGINT,
		  TotalSpills BIGINT,
		  AvgSpills MONEY,
		  QueryPlanCost FLOAT,
          JoinKey AS ServerName + Cast(CheckDate AS NVARCHAR(50)),
          CONSTRAINT [PK_' + REPLACE(REPLACE(@outputtablename, '[', ''), ']', '') + '] PRIMARY KEY CLUSTERED(ID ASC))';

            if @debug = 1
                begin
                    print SUBSTRING(@insert_sql, 0, 4000);
                    print SUBSTRING(@insert_sql, 4000, 8000);
                    print SUBSTRING(@insert_sql, 8000, 12000);
                    print SUBSTRING(@insert_sql, 12000, 16000);
                    print SUBSTRING(@insert_sql, 16000, 20000);
                    print SUBSTRING(@insert_sql, 20000, 24000);
                    print SUBSTRING(@insert_sql, 24000, 28000);
                    print SUBSTRING(@insert_sql, 28000, 32000);
                    print SUBSTRING(@insert_sql, 32000, 36000);
                    print SUBSTRING(@insert_sql, 36000, 40000);
                end;

            exec sp_executesql @insert_sql;

            /* If the table doesn't have the new LastCompletionTime column, add it. See Github #2377. */
            set @objectfullname = @outputdatabasename + N'.' + @outputschemaname + N'.' + @outputtablename;
            set @insert_sql = N'IF NOT EXISTS (SELECT * FROM ' + @outputdatabasename + N'.sys.all_columns
        WHERE object_id = (OBJECT_ID(''' + @objectfullname + N''')) AND name = ''LastCompletionTime'')
        ALTER TABLE ' + @objectfullname + N' ADD LastCompletionTime DATETIME NULL;';
            exec (@insert_sql);


            if @checkdateoverride is null
                begin
                    set @checkdateoverride = SYSDATETIMEOFFSET();
                end;


            set @insert_sql = N' IF EXISTS(SELECT * FROM '
                + @outputdatabasename
                + N'.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                + @outputschemaname + N''') '
                + N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;'
                + 'INSERT '
                + @outputdatabasename + '.'
                + @outputschemaname + '.'
                + @outputtablename
                +
                              N' (ServerName, CheckDate, Version, QueryType, DatabaseName, AverageCPU, TotalCPU, PercentCPUByType, CPUWeight, AverageDuration, TotalDuration, DurationWeight, PercentDurationByType, AverageReads, TotalReads, ReadWeight, PercentReadsByType, '
                +
                              N' AverageWrites, TotalWrites, WriteWeight, PercentWritesByType, ExecutionCount, ExecutionWeight, PercentExecutionsByType, '
                +
                              N' ExecutionsPerMinute, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, QueryHash, QueryPlanHash, StatementStartOffset, StatementEndOffset, MinReturnedRows, MaxReturnedRows, AverageReturnedRows, TotalReturnedRows, QueryText, QueryPlan, NumberOfPlans, NumberOfDistinctPlans, Warnings, '
                +
                              N' SerialRequiredMemory, SerialDesiredMemory, MinGrantKB, MaxGrantKB, MinUsedGrantKB, MaxUsedGrantKB, PercentMemoryGrantUsed, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, QueryPlanCost ) '
                + N'SELECT TOP (@Top) '
                + QUOTENAME(CAST(SERVERPROPERTY('ServerName') as nvarchar(128)), N'''') + N', @CheckDateOverride, '
                + QUOTENAME(CAST(SERVERPROPERTY('ProductVersion') as nvarchar(128)), N'''') + ', '
                +
                              N' QueryType, DatabaseName, AverageCPU, TotalCPU, PercentCPUByType, PercentCPU, AverageDuration, TotalDuration, PercentDuration, PercentDurationByType, AverageReads, TotalReads, PercentReads, PercentReadsByType, '
                +
                              N' AverageWrites, TotalWrites, PercentWrites, PercentWritesByType, ExecutionCount, PercentExecutions, PercentExecutionsByType, '
                +
                              N' ExecutionsPerMinute, PlanCreationTime, LastExecutionTime, LastCompletionTime, PlanHandle, SqlHandle, QueryHash, QueryPlanHash, StatementStartOffset, StatementEndOffset, MinReturnedRows, MaxReturnedRows, AverageReturnedRows, TotalReturnedRows, QueryText, QueryPlan, NumberOfPlans, NumberOfDistinctPlans, Warnings, '
                +
                              N' SerialRequiredMemory, SerialDesiredMemory, MinGrantKB, MaxGrantKB, MinUsedGrantKB, MaxUsedGrantKB, PercentMemoryGrantUsed, AvgMaxMemoryGrant, MinSpills, MaxSpills, TotalSpills, AvgSpills, QueryPlanCost '
                + N' FROM ##BlitzCacheProcs '
                + N' WHERE 1=1 ';

            if @minimumexecutioncount is not null
                begin
                    set @insert_sql += N' AND ExecutionCount >= @MinimumExecutionCount ';
                end;

            if @minutesback is not null
                begin
                    set @insert_sql += N' AND LastCompletionTime >= DATEADD(MINUTE, @min_back, GETDATE() ) ';
                end;

            set @insert_sql += N' AND SPID = @@SPID ';

            select @insert_sql += N' ORDER BY ' + case @sortorder
                                                      when 'cpu' then N' TotalCPU '
                                                      when N'reads' then N' TotalReads '
                                                      when N'writes' then N' TotalWrites '
                                                      when N'duration' then N' TotalDuration '
                                                      when N'executions' then N' ExecutionCount '
                                                      when N'compiles' then N' PlanCreationTime '
                                                      when N'memory grant' then N' MaxGrantKB'
                                                      when N'spills' then N' MaxSpills'
                                                      when N'avg cpu' then N' AverageCPU'
                                                      when N'avg reads' then N' AverageReads'
                                                      when N'avg writes' then N' AverageWrites'
                                                      when N'avg duration' then N' AverageDuration'
                                                      when N'avg executions' then N' ExecutionsPerMinute'
                                                      when N'avg memory grant' then N' AvgMaxMemoryGrant'
                                                      when 'avg spills' then N' AvgSpills'
                end + N' DESC ';

            set @insert_sql += N' OPTION (RECOMPILE) ; ';

            if @debug = 1
                begin
                    print SUBSTRING(@insert_sql, 0, 4000);
                    print SUBSTRING(@insert_sql, 4000, 8000);
                    print SUBSTRING(@insert_sql, 8000, 12000);
                    print SUBSTRING(@insert_sql, 12000, 16000);
                    print SUBSTRING(@insert_sql, 16000, 20000);
                    print SUBSTRING(@insert_sql, 20000, 24000);
                    print SUBSTRING(@insert_sql, 24000, 28000);
                    print SUBSTRING(@insert_sql, 28000, 32000);
                    print SUBSTRING(@insert_sql, 32000, 36000);
                    print SUBSTRING(@insert_sql, 36000, 40000);
                end;

            exec sp_executesql @insert_sql,
                 N'@Top INT, @min_duration INT, @min_back INT, @CheckDateOverride DATETIMEOFFSET, @MinimumExecutionCount INT',
                 @top, @durationfilter_i, @minutesback, @checkdateoverride, @minimumexecutioncount;
        end; /* End of writing results to table */

end; /*Final End*/

go
if OBJECT_ID('dbo.sp_BlitzFirst') is null
    exec ('CREATE PROCEDURE dbo.sp_BlitzFirst AS RETURN 0;');
go


alter procedure [dbo].[sp_BlitzFirst] @logmessage nvarchar(4000) = null,
                                      @help tinyint = 0,
                                      @asof datetimeoffset = null,
                                      @expertmode tinyint = 0,
                                      @seconds int = 5,
                                      @outputtype varchar(20) = 'TABLE',
                                      @outputservername nvarchar(256) = null,
                                      @outputdatabasename nvarchar(256) = null,
                                      @outputschemaname nvarchar(256) = null,
                                      @outputtablename nvarchar(256) = null,
                                      @outputtablenamefilestats nvarchar(256) = null,
                                      @outputtablenameperfmonstats nvarchar(256) = null,
                                      @outputtablenamewaitstats nvarchar(256) = null,
                                      @outputtablenameblitzcache nvarchar(256) = null,
                                      @outputtablenameblitzwho nvarchar(256) = null,
                                      @outputtableretentiondays tinyint = 7,
                                      @outputxmlasnvarchar tinyint = 0,
                                      @filterplansbydatabase varchar(max) = null,
                                      @checkprocedurecache tinyint = 0,
                                      @checkserverinfo tinyint = 1,
                                      @filelatencythresholdms int = 100,
                                      @sincestartup tinyint = 0,
                                      @showsleepingspids tinyint = 0,
                                      @blitzcacheskipanalysis bit = 1,
                                      @logmessagecheckid int = 38,
                                      @logmessagepriority tinyint = 1,
                                      @logmessagefindingsgroup varchar(50) = 'Logged Message',
                                      @logmessagefinding varchar(200) = 'Logged from sp_BlitzFirst',
                                      @logmessageurl varchar(200) = '',
                                      @logmessagecheckdate datetimeoffset = null,
                                      @debug bit = 0,
                                      @version varchar(30) = null output,
                                      @versiondate datetime = null output,
                                      @versioncheckmode bit = 0
    with execute as caller , recompile
as
begin
    set nocount on;
    set transaction isolation level read uncommitted;

    select @version = '7.97', @versiondate = '20200712';

    if (@versioncheckmode = 1)
        begin
            return;
        end;

    if @help = 1
        print '
sp_BlitzFirst from http://FirstResponderKit.org

This script gives you a prioritized list of why your SQL Server is slow right now.

This is not an overall health check - for that, check out sp_Blitz.

To learn more, visit http://FirstResponderKit.org where you can download new
versions for free, watch training videos on how it works, get more info on
the findings, contribute your own code, and more.

Known limitations of this version:
 - Only Microsoft-supported versions of SQL Server. Sorry, 2005 and 2000. It
   may work just fine on 2005, and if it does, hug your parents. Just don''t
   file support issues if it breaks.
 - If a temp table called #CustomPerfmonCounters exists for any other session,
   but not our session, this stored proc will fail with an error saying the
   temp table #CustomPerfmonCounters does not exist.
 - @OutputServerName is not functional yet.
 - If @OutputDatabaseName, SchemaName, TableName, etc are quoted with brackets,
   the write to table may silently fail. Look, I never said I was good at this.

Unknown limitations of this version:
 - None. Like Zombo.com, the only limit is yourself.

Changes - for the full list of improvements and fixes in this version, see:
https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/


MIT License

Copyright (c) 2020 Brent Ozar Unlimited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

';


    raiserror ('Setting up configuration variables',10,1) with nowait;
    declare @stringtoexecute nvarchar(max),
        @parmdefinitions nvarchar(4000),
        @parm1 nvarchar(4000),
        @oursessionid int,
        @linefeed nvarchar(10),
        @stockwarningheader nvarchar(max) = N'',
        @stockwarningfooter nvarchar(max) = N'',
        @stockdetailsheader nvarchar(max) = N'',
        @stockdetailsfooter nvarchar(max) = N'',
        @startsampletime datetimeoffset,
        @finishsampletime datetimeoffset,
        @finishsampletimewaitfor datetime,
        @asof1 datetimeoffset,
        @asof2 datetimeoffset,
        @servicename sysname,
        @outputtablenamefilestats_view nvarchar(256),
        @outputtablenameperfmonstats_view nvarchar(256),
        @outputtablenameperfmonstatsactuals_view nvarchar(256),
        @outputtablenamewaitstats_view nvarchar(256),
        @outputtablenamewaitstats_categories nvarchar(256),
        @outputtablecleanupdate date,
        @objectfullname nvarchar(2000),
        @blitzwho nvarchar(max) = N'EXEC dbo.sp_BlitzWho @ShowSleepingSPIDs = ' +
                                  CONVERT(nvarchar(1), @showsleepingspids) + N';',
        @blitzcacheminutesback int,
        @unquotedoutputservername nvarchar(256) = @outputservername ,
        @unquotedoutputdatabasename nvarchar(256) = @outputdatabasename ,
        @unquotedoutputschemaname nvarchar(256) = @outputschemaname ,
        @localservername nvarchar(128) = CAST(SERVERPROPERTY('ServerName') as nvarchar(128)),
        @dm_exec_query_statistics_xml bit = 0;

/* Sanitize our inputs */
    select @outputtablenamefilestats_view = QUOTENAME(@outputtablenamefilestats + '_Deltas'),
           @outputtablenameperfmonstats_view = QUOTENAME(@outputtablenameperfmonstats + '_Deltas'),
           @outputtablenameperfmonstatsactuals_view = QUOTENAME(@outputtablenameperfmonstats + '_Actuals'),
           @outputtablenamewaitstats_view = QUOTENAME(@outputtablenamewaitstats + '_Deltas'),
           @outputtablenamewaitstats_categories = QUOTENAME(@outputtablenamewaitstats + '_Categories');

    select @outputdatabasename = QUOTENAME(@outputdatabasename),
           @outputschemaname = QUOTENAME(@outputschemaname),
           @outputtablename = QUOTENAME(@outputtablename),
           @outputtablenamefilestats = QUOTENAME(@outputtablenamefilestats),
           @outputtablenameperfmonstats = QUOTENAME(@outputtablenameperfmonstats),
           @outputtablenamewaitstats = QUOTENAME(@outputtablenamewaitstats),
           @outputtablecleanupdate = CAST((DATEADD(day, -1 * @outputtableretentiondays, GETDATE())) as date),
        /* @OutputTableNameBlitzCache = QUOTENAME(@OutputTableNameBlitzCache),  We purposely don't sanitize this because sp_BlitzCache will */
        /* @OutputTableNameBlitzWho = QUOTENAME(@OutputTableNameBlitzWho),  We purposely don't sanitize this because sp_BlitzWho will */
           @linefeed = CHAR(13) + CHAR(10),
           @oursessionid = @@SPID,
           @outputtype = UPPER(@outputtype);

    if (@outputtype = 'NONE' and (@outputtablename is null or @outputschemaname is null or @outputdatabasename is null))
        begin
            raiserror ('This procedure should be called with a value for all @Output* parameters, as @OutputType is set to NONE',12,1);
            return;
        end;

    if UPPER(@outputtype) like 'TOP 10%' set @outputtype = 'Top10';
    if @outputtype = 'Top10' set @sincestartup = 1;

    if @logmessage is not null
        begin

            raiserror ('Saving LogMessage to table',10,1) with nowait;

            /* Try to set the output table parameters if they don't exist */
            if @outputschemaname is null and @outputtablename is null and @outputdatabasename is null
                begin
                    set @outputschemaname = N'[dbo]';
                    set @outputtablename = N'[BlitzFirst]';

                    /* Look for the table in the current database */
                    select top 1 @outputdatabasename = QUOTENAME(table_catalog)
                    from information_schema.tables
                    where table_schema = 'dbo'
                      and table_name = 'BlitzFirst';

                    if @outputdatabasename is null and EXISTS(select * from sys.databases where name = 'DBAtools')
                        set @outputdatabasename = '[DBAtools]';

                end;

            if @outputdatabasename is null or @outputschemaname is null or @outputtablename is null
                or not EXISTS(select *
                              from sys.databases
                              where QUOTENAME([name]) = @outputdatabasename)
                begin
                    raiserror ('We have a hard time logging a message without a valid @OutputDatabaseName, @OutputSchemaName, and @OutputTableName to log it to.', 0, 1) with nowait;
                    return;
                end;
            if @logmessagecheckdate is null
                set @logmessagecheckdate = SYSDATETIMEOFFSET();
            set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                + @outputdatabasename
                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                + @outputschemaname + ''') INSERT '
                + @outputdatabasename + '.'
                + @outputschemaname + '.'
                + @outputtablename
                + ' (ServerName, CheckDate, CheckID, Priority, FindingsGroup, Finding, Details, URL) VALUES( '
                +
                                   ' @SrvName, @LogMessageCheckDate, @LogMessageCheckID, @LogMessagePriority, @LogMessageFindingsGroup, @LogMessageFinding, @LogMessage, @LogMessageURL)';

            execute sp_executesql @stringtoexecute,
                    N'@SrvName NVARCHAR(128), @LogMessageCheckID INT, @LogMessagePriority TINYINT, @LogMessageFindingsGroup VARCHAR(50), @LogMessageFinding VARCHAR(200), @LogMessage NVARCHAR(4000), @LogMessageCheckDate DATETIMEOFFSET, @LogMessageURL VARCHAR(200)',
                    @localservername, @logmessagecheckid, @logmessagepriority, @logmessagefindingsgroup,
                    @logmessagefinding, @logmessage, @logmessagecheckdate, @logmessageurl;

            raiserror ('LogMessage saved to table. We have made a note of your activity. Keep up the good work.',10,1) with nowait;

            return;
        end;

    if @sincestartup = 1
        select @seconds = 0, @expertmode = 1;


    if @outputtype = 'SCHEMA'
        begin
            select fieldlist = '[Priority] TINYINT, [FindingsGroup] VARCHAR(50), [Finding] VARCHAR(200), [URL] VARCHAR(200), [Details] NVARCHAR(4000), [HowToStopIt] NVARCHAR(MAX), [QueryPlan] XML, [QueryText] NVARCHAR(MAX)';

        end;
    else
        if @asof is not null and @outputdatabasename is not null and @outputschemaname is not null and
           @outputtablename is not null
            begin
                /* They want to look into the past. */
                set @asof1 = DATEADD(mi, -15, @asof);
                set @asof2 = DATEADD(mi, +15, @asof);

                set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                    + @outputdatabasename
                    + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                    + @outputschemaname +
                                       ''') SELECT CheckDate, [Priority], [FindingsGroup], [Finding], [URL], CAST([Details] AS [XML]) AS Details,'
                    +
                                       '[HowToStopIt], [CheckID], [StartTime], [LoginName], [NTUserName], [OriginalLoginName], [ProgramName], [HostName], [DatabaseID],'
                    + '[DatabaseName], [OpenTransactionCount], [QueryPlan], [QueryText] FROM '
                    + @outputdatabasename + '.'
                    + @outputschemaname + '.'
                    + @outputtablename
                    + ' WHERE CheckDate >= @AsOf1'
                    + ' AND CheckDate <= @AsOf2'
                    + ' /*ORDER BY CheckDate, Priority , FindingsGroup , Finding , Details*/;';
                exec sp_executesql @stringtoexecute,
                     N'@AsOf1 DATETIMEOFFSET, @AsOf2 DATETIMEOFFSET',
                     @asof1, @asof2


            end; /* IF @AsOf IS NOT NULL AND @OutputDatabaseName IS NOT NULL AND @OutputSchemaName IS NOT NULL AND @OutputTableName IS NOT NULL */
        else
            if @logmessage is null /* IF @OutputType = 'SCHEMA' */
                begin
                    /* What's running right now? This is the first and last result set. */
                    if @sincestartup = 0 and @seconds > 0 and @expertmode = 1 and @outputtype <> 'NONE'
                        begin
                            if OBJECT_ID('master.dbo.sp_BlitzWho') is null and OBJECT_ID('dbo.sp_BlitzWho') is null
                                begin
                                    print N'sp_BlitzWho is not installed in the current database_files.  You can get a copy from http://FirstResponderKit.org';
                                end;
                            else
                                begin
                                    exec (@blitzwho);
                                end;
                        end;
                    /* IF @SinceStartup = 0 AND @Seconds > 0 AND @ExpertMode = 1 AND @OutputType <> 'NONE'   -   What's running right now? This is the first and last result set. */

                    /* Set start/finish times AFTER sp_BlitzWho runs. For more info: https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/2244 */
                    if @seconds = 0 and SERVERPROPERTY('Edition') = 'SQL Azure'
                        with waittimes as (
                            select wait_type,
                                   wait_time_ms,
                                   NTILE(3) over (order by wait_time_ms) as grouper
                            from sys.dm_os_wait_stats w
                            where wait_type in
                                  ('DIRTY_PAGE_POLL', 'HADR_FILESTREAM_IOMGR_IOCOMPLETION', 'LAZYWRITER_SLEEP',
                                   'LOGMGR_QUEUE', 'REQUEST_FOR_DEADLOCK_SEARCH', 'XE_TIMER_EVENT')
                        )
                        select @startsampletime = DATEADD(mi, AVG(-wait_time_ms / 1000 / 60), SYSDATETIMEOFFSET()),
                               @finishsampletime = SYSDATETIMEOFFSET()
                        from waittimes
                        where grouper = 2;
                    else
                        if @seconds = 0 and SERVERPROPERTY('Edition') <> 'SQL Azure'
                            select @startsampletime =
                                   DATEADD(minute, DATEDIFF(minute, GETDATE(), GETUTCDATE()), create_date),
                                   @finishsampletime = SYSDATETIMEOFFSET()
                            from sys.databases
                            where database_id = 2;
                        else
                            select @startsampletime = SYSDATETIMEOFFSET(),
                                   @finishsampletime = DATEADD(ss, @seconds, SYSDATETIMEOFFSET()),
                                   @finishsampletimewaitfor = DATEADD(ss, @seconds, GETDATE());


                    raiserror ('Now starting diagnostic analysis',10,1) with nowait;

                    /*
    We start by creating #BlitzFirstResults. It's a temp table that will store
    the results from our checks. Throughout the rest of this stored procedure,
    we're running a series of checks looking for dangerous things inside the SQL
    Server. When we find a problem, we insert rows into the temp table. At the
    end, we return these results to the end user.

    #BlitzFirstResults has a CheckID field, but there's no Check table. As we do
    checks, we insert data into this table, and we manually put in the CheckID.
    We (Brent Ozar Unlimited) maintain a list of the checks by ID#. You can
    download that from http://FirstResponderKit.org if you want to build
    a tool that relies on the output of sp_BlitzFirst.
    */


                    if OBJECT_ID('tempdb..#BlitzFirstResults') is not null
                        drop table #blitzfirstresults;
                    create table #blitzfirstresults
                    (
                        id int identity (1, 1) primary key clustered,
                        checkid int not null,
                        priority tinyint not null,
                        findingsgroup varchar(50) not null,
                        finding varchar(200) not null,
                        url varchar(200) null,
                        details nvarchar(max) null,
                        howtostopit nvarchar(max) null,
                        queryplan [XML] null,
                        querytext nvarchar(max) null,
                        starttime datetimeoffset null,
                        loginname nvarchar(128) null,
                        ntusername nvarchar(128) null,
                        originalloginname nvarchar(128) null,
                        programname nvarchar(128) null,
                        hostname nvarchar(128) null,
                        databaseid int null,
                        databasename nvarchar(128) null,
                        opentransactioncount int null,
                        querystatsnowid int null,
                        querystatsfirstid int null,
                        planhandle varbinary(64) null,
                        detailsint int null,
                        queryhash binary(8)
                    );

                    if OBJECT_ID('tempdb..#WaitStats') is not null
                        drop table #waitstats;
                    create table #waitstats
                    (
                        pass tinyint not null,
                        wait_type nvarchar(60),
                        wait_time_ms bigint,
                        signal_wait_time_ms bigint,
                        waiting_tasks_count bigint,
                        sampletime datetimeoffset
                    );

                    if OBJECT_ID('tempdb..#FileStats') is not null
                        drop table #filestats;
                    create table #filestats
                    (
                        id int identity (1, 1) primary key clustered,
                        pass tinyint not null,
                        sampletime datetimeoffset not null,
                        databaseid int not null,
                        fileid int not null,
                        databasename nvarchar(256),
                        filelogicalname nvarchar(256),
                        typedesc nvarchar(60),
                        sizeondiskmb bigint,
                        io_stall_read_ms bigint,
                        num_of_reads bigint,
                        bytes_read bigint,
                        io_stall_write_ms bigint,
                        num_of_writes bigint,
                        bytes_written bigint,
                        physicalname nvarchar(520),
                        avg_stall_read_ms int,
                        avg_stall_write_ms int
                    );

                    if OBJECT_ID('tempdb..#QueryStats') is not null
                        drop table #querystats;
                    create table #querystats
                    (
                        id int identity (1, 1) primary key clustered,
                        pass int not null,
                        sampletime datetimeoffset not null,
                        [sql_handle] varbinary(64),
                        statement_start_offset int,
                        statement_end_offset int,
                        plan_generation_num bigint,
                        plan_handle varbinary(64),
                        execution_count bigint,
                        total_worker_time bigint,
                        total_physical_reads bigint,
                        total_logical_writes bigint,
                        total_logical_reads bigint,
                        total_clr_time bigint,
                        total_elapsed_time bigint,
                        creation_time datetimeoffset,
                        query_hash binary(8),
                        query_plan_hash binary(8),
                        points tinyint
                    );

                    if OBJECT_ID('tempdb..#PerfmonStats') is not null
                        drop table #perfmonstats;
                    create table #perfmonstats
                    (
                        id int identity (1, 1) primary key clustered,
                        pass tinyint not null,
                        sampletime datetimeoffset not null,
                        [object_name] nvarchar(128) not null,
                        [counter_name] nvarchar(128) not null,
                        [instance_name] nvarchar(128) null,
                        [cntr_value] bigint null,
                        [cntr_type] int not null,
                        [value_delta] bigint null,
                        [value_per_second] decimal(18, 2) null
                    );

                    if OBJECT_ID('tempdb..#PerfmonCounters') is not null
                        drop table #perfmoncounters;
                    create table #perfmoncounters
                    (
                        id int identity (1, 1) primary key clustered,
                        [object_name] nvarchar(128) not null,
                        [counter_name] nvarchar(128) not null,
                        [instance_name] nvarchar(128) null
                    );

                    if OBJECT_ID('tempdb..#FilterPlansByDatabase') is not null
                        drop table #filterplansbydatabase;
                    create table #filterplansbydatabase
                    (
                        databaseid int primary key clustered
                    );

                    if OBJECT_ID('tempdb..##WaitCategories') is null
                        begin
                            /* We reuse this one by default rather than recreate it every time. */
                            create table ##waitcategories
                            (
                                waittype nvarchar(60) primary key clustered,
                                waitcategory nvarchar(128) not null,
                                ignorable bit default 0
                            );
                        end; /* IF OBJECT_ID('tempdb..##WaitCategories') IS NULL */

                    if OBJECT_ID('tempdb..#checkversion') is not null
                        drop table #checkversion;
                    create table #checkversion
                    (
                        version nvarchar(128),
                        common_version as SUBSTRING(version, 1, CHARINDEX('.', version) + 1),
                        major as PARSENAME(CONVERT(varchar(32), version), 4),
                        minor as PARSENAME(CONVERT(varchar(32), version), 3),
                        build as PARSENAME(CONVERT(varchar(32), version), 2),
                        revision as PARSENAME(CONVERT(varchar(32), version), 1)
                    );

                    if 527 <> (select COALESCE(SUM(1), 0) from ##waitcategories)
                        begin
                            truncate table ##waitcategories;
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('ASYNC_IO_COMPLETION', 'Other Disk IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('ASYNC_NETWORK_IO', 'Network IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BACKUPIO', 'Other Disk IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_CONNECTION_RECEIVE_TASK', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_DISPATCHER', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_ENDPOINT_STATE_MUTEX', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_EVENTHANDLER', 'Service Broker', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_FORWARDER', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_INIT', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_MASTERSTART', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_RECEIVE_WAITFOR', 'User Wait', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_REGISTERALLENDPOINTS', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_SERVICE', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_SHUTDOWN', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_START', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_TASK_SHUTDOWN', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_TASK_STOP', 'Service Broker', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_TASK_SUBMIT', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_TO_FLUSH', 'Service Broker', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_TRANSMISSION_OBJECT', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_TRANSMISSION_TABLE', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_TRANSMISSION_WORK', 'Service Broker', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('BROKER_TRANSMITTER', 'Service Broker', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CHECKPOINT_QUEUE', 'Idle', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CHKPT', 'Tran Log IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CLR_AUTO_EVENT', 'SQL CLR', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CLR_CRST', 'SQL CLR', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CLR_JOIN', 'SQL CLR', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CLR_MANUAL_EVENT', 'SQL CLR', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CLR_MEMORY_SPY', 'SQL CLR', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CLR_MONITOR', 'SQL CLR', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CLR_RWLOCK_READER', 'SQL CLR', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CLR_RWLOCK_WRITER', 'SQL CLR', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CLR_SEMAPHORE', 'SQL CLR', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CLR_TASK_START', 'SQL CLR', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CLRHOST_STATE_ACCESS', 'SQL CLR', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CMEMPARTITIONED', 'Memory', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CMEMTHREAD', 'Memory', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CXPACKET', 'Parallelism', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('CXCONSUMER', 'Parallelism', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DBMIRROR_DBM_EVENT', 'Mirroring', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DBMIRROR_DBM_MUTEX', 'Mirroring', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DBMIRROR_EVENTS_QUEUE', 'Mirroring', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DBMIRROR_SEND', 'Mirroring', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DBMIRROR_WORKER_QUEUE', 'Mirroring', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DBMIRRORING_CMD', 'Mirroring', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DIRTY_PAGE_POLL', 'Other', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DIRTY_PAGE_TABLE_LOCK', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DISPATCHER_QUEUE_SEMAPHORE', 'Other', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DPT_ENTRY_LOCK', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DTC', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DTC_ABORT_REQUEST', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DTC_RESOLVE', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DTC_STATE', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DTC_TMDOWN_REQUEST', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DTC_WAITFOR_OUTCOME', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DTCNEW_ENLIST', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DTCNEW_PREPARE', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DTCNEW_RECOVERY', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DTCNEW_TM', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DTCNEW_TRANSACTION_ENLISTMENT', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('DTCPNTSYNC', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('EE_PMOLOCK', 'Memory', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('EXCHANGE', 'Parallelism', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('EXTERNAL_SCRIPT_NETWORK_IOF', 'Network IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FCB_REPLICA_READ', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FCB_REPLICA_WRITE', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FT_COMPROWSET_RWLOCK', 'Full Text Search', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FT_IFTS_RWLOCK', 'Full Text Search', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FT_IFTS_SCHEDULER_IDLE_WAIT', 'Idle', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FT_IFTSHC_MUTEX', 'Full Text Search', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FT_IFTSISM_MUTEX', 'Full Text Search', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FT_MASTER_MERGE', 'Full Text Search', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FT_MASTER_MERGE_COORDINATOR', 'Full Text Search', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FT_METADATA_MUTEX', 'Full Text Search', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FT_PROPERTYLIST_CACHE', 'Full Text Search', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FT_RESTART_CRAWL', 'Full Text Search', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('FULLTEXT GATHERER', 'Full Text Search', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_AG_MUTEX', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_AR_CRITICAL_SECTION_ENTRY', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_AR_MANAGER_MUTEX', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_AR_UNLOAD_COMPLETED', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_ARCONTROLLER_NOTIFICATIONS_SUBSCRIBER_LIST', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_BACKUP_BULK_LOCK', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_BACKUP_QUEUE', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_CLUSAPI_CALL', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_COMPRESSED_CACHE_SYNC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_CONNECTIVITY_INFO', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DATABASE_FLOW_CONTROL', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DATABASE_VERSIONING_STATE', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DATABASE_WAIT_FOR_RECOVERY', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DATABASE_WAIT_FOR_RESTART', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DATABASE_WAIT_FOR_TRANSITION_TO_VERSIONING', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DB_COMMAND', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DB_OP_COMPLETION_SYNC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DB_OP_START_SYNC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DBR_SUBSCRIBER', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DBR_SUBSCRIBER_FILTER_LIST', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DBSEEDING', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DBSEEDING_LIST', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_DBSTATECHANGE_SYNC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_FABRIC_CALLBACK', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_FILESTREAM_BLOCK_FLUSH', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_FILESTREAM_FILE_CLOSE', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_FILESTREAM_FILE_REQUEST', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_FILESTREAM_IOMGR', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_FILESTREAM_IOMGR_IOCOMPLETION', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_FILESTREAM_MANAGER', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_FILESTREAM_PREPROC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_GROUP_COMMIT', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_LOGCAPTURE_SYNC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_LOGCAPTURE_WAIT', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_LOGPROGRESS_SYNC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_NOTIFICATION_DEQUEUE', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_NOTIFICATION_WORKER_EXCLUSIVE_ACCESS', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_NOTIFICATION_WORKER_STARTUP_SYNC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_NOTIFICATION_WORKER_TERMINATION_SYNC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_PARTNER_SYNC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_READ_ALL_NETWORKS', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_RECOVERY_WAIT_FOR_CONNECTION', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_RECOVERY_WAIT_FOR_UNDO', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_REPLICAINFO_SYNC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_SEEDING_CANCELLATION', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_SEEDING_FILE_LIST', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_SEEDING_LIMIT_BACKUPS', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_SEEDING_SYNC_COMPLETION', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_SEEDING_TIMEOUT_TASK', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_SEEDING_WAIT_FOR_COMPLETION', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_SYNC_COMMIT', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_SYNCHRONIZING_THROTTLE', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_TDS_LISTENER_SYNC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_TDS_LISTENER_SYNC_PROCESSING', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_THROTTLE_LOG_RATE_GOVERNOR', 'Log Rate Governor', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_TIMER_TASK', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_TRANSPORT_DBRLIST', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_TRANSPORT_FLOW_CONTROL', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_TRANSPORT_SESSION', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_WORK_POOL', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_WORK_QUEUE', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('HADR_XRF_STACK_ACCESS', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('INSTANCE_LOG_RATE_GOVERNOR', 'Log Rate Governor', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('IO_COMPLETION', 'Other Disk IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('IO_QUEUE_LIMIT', 'Other Disk IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('IO_RETRY', 'Other Disk IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LATCH_DT', 'Latch', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LATCH_EX', 'Latch', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LATCH_KP', 'Latch', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LATCH_NL', 'Latch', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LATCH_SH', 'Latch', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LATCH_UP', 'Latch', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LAZYWRITER_SLEEP', 'Idle', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_BU', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_BU_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_BU_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_IS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_IS_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_IS_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_IU', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_IU_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_IU_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_IX', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_IX_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_IX_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RIn_NL', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RIn_NL_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RIn_NL_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RIn_S', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RIn_S_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RIn_S_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RIn_U', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RIn_U_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RIn_U_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RIn_X', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RIn_X_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RIn_X_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RS_S', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RS_S_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RS_S_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RS_U', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RS_U_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RS_U_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RX_S', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RX_S_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RX_S_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RX_U', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RX_U_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RX_U_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RX_X', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RX_X_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_RX_X_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_S', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_S_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_S_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_SCH_M', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_SCH_M_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_SCH_M_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_SCH_S', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_SCH_S_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_SCH_S_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_SIU', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_SIU_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_SIU_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_SIX', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_SIX_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_SIX_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_U', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_U_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_U_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_UIX', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_UIX_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_UIX_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_X', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_X_ABORT_BLOCKERS', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LCK_M_X_LOW_PRIORITY', 'Lock', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LOG_RATE_GOVERNOR', 'Tran Log IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LOGBUFFER', 'Tran Log IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LOGMGR', 'Tran Log IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LOGMGR_FLUSH', 'Tran Log IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LOGMGR_PMM_LOG', 'Tran Log IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LOGMGR_QUEUE', 'Idle', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('LOGMGR_RESERVE_APPEND', 'Tran Log IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('MEMORY_ALLOCATION_EXT', 'Memory', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('MEMORY_GRANT_UPDATE', 'Memory', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('MSQL_XACT_MGR_MUTEX', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('MSQL_XACT_MUTEX', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('MSSEARCH', 'Full Text Search', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('NET_WAITFOR_PACKET', 'Network IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('ONDEMAND_TASK_QUEUE', 'Idle', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PAGEIOLATCH_DT', 'Buffer IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PAGEIOLATCH_EX', 'Buffer IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PAGEIOLATCH_KP', 'Buffer IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PAGEIOLATCH_NL', 'Buffer IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PAGEIOLATCH_SH', 'Buffer IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PAGEIOLATCH_UP', 'Buffer IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PAGELATCH_DT', 'Buffer Latch', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PAGELATCH_EX', 'Buffer Latch', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PAGELATCH_KP', 'Buffer Latch', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PAGELATCH_NL', 'Buffer Latch', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PAGELATCH_SH', 'Buffer Latch', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PAGELATCH_UP', 'Buffer Latch', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PARALLEL_REDO_DRAIN_WORKER', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PARALLEL_REDO_FLOW_CONTROL', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PARALLEL_REDO_LOG_CACHE', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PARALLEL_REDO_TRAN_LIST', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PARALLEL_REDO_TRAN_TURN', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PARALLEL_REDO_WORKER_SYNC', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PARALLEL_REDO_WORKER_WAIT_WORK', 'Replication', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('POOL_LOG_RATE_GOVERNOR', 'Log Rate Governor', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_ABR', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_CLOSEBACKUPMEDIA', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_CLOSEBACKUPTAPE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_CLOSEBACKUPVDIDEVICE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_CLUSAPI_CLUSTERRESOURCECONTROL', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_COCREATEINSTANCE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_COGETCLASSOBJECT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_CREATEACCESSOR', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_DELETEROWS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_GETCOMMANDTEXT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_GETDATA', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_GETNEXTROWS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_GETRESULT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_GETROWSBYBOOKMARK', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_LBFLUSH', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_LBLOCKREGION', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_LBREADAT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_LBSETSIZE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_LBSTAT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_LBUNLOCKREGION', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_LBWRITEAT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_QUERYINTERFACE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_RELEASE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_RELEASEACCESSOR', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_RELEASEROWS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_RELEASESESSION', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_RESTARTPOSITION', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_SEQSTRMREAD', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_SEQSTRMREADANDWRITE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_SETDATAFAILURE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_SETPARAMETERINFO', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_SETPARAMETERPROPERTIES', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_STRMLOCKREGION', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_STRMSEEKANDREAD', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_STRMSEEKANDWRITE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_STRMSETSIZE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_STRMSTAT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_COM_STRMUNLOCKREGION', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_CONSOLEWRITE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_CREATEPARAM', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DEBUG', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DFSADDLINK', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DFSLINKEXISTCHECK', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DFSLINKHEALTHCHECK', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DFSREMOVELINK', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DFSREMOVEROOT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DFSROOTFOLDERCHECK', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DFSROOTINIT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DFSROOTSHARECHECK', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DTC_ABORT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DTC_ABORTREQUESTDONE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DTC_BEGINTRANSACTION', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DTC_COMMITREQUESTDONE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DTC_ENLIST', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_DTC_PREPAREREQUESTDONE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_FILESIZEGET', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_FSAOLEDB_ABORTTRANSACTION', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_FSAOLEDB_COMMITTRANSACTION', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_FSAOLEDB_STARTTRANSACTION', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_FSRECOVER_UNCONDITIONALUNDO', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_GETRMINFO', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_HADR_LEASE_MECHANISM', 'Preemptive', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_HTTP_EVENT_WAIT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_HTTP_REQUEST', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_LOCKMONITOR', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_MSS_RELEASE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_ODBCOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OLE_UNINIT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OLEDB_ABORTORCOMMITTRAN', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OLEDB_ABORTTRAN', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OLEDB_GETDATASOURCE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OLEDB_GETLITERALINFO', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OLEDB_GETPROPERTIES', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OLEDB_GETPROPERTYINFO', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OLEDB_GETSCHEMALOCK', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OLEDB_JOINTRANSACTION', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OLEDB_RELEASE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OLEDB_SETPROPERTIES', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OLEDBOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_ACCEPTSECURITYCONTEXT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_ACQUIRECREDENTIALSHANDLE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_AUTHENTICATIONOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_AUTHORIZATIONOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_AUTHZGETINFORMATIONFROMCONTEXT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_AUTHZINITIALIZECONTEXTFROMSID', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_AUTHZINITIALIZERESOURCEMANAGER', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_BACKUPREAD', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_CLOSEHANDLE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_CLUSTEROPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_COMOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_COMPLETEAUTHTOKEN', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_COPYFILE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_CREATEDIRECTORY', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_CREATEFILE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_CRYPTACQUIRECONTEXT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_CRYPTIMPORTKEY', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_CRYPTOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_DECRYPTMESSAGE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_DELETEFILE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_DELETESECURITYCONTEXT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_DEVICEIOCONTROL', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_DEVICEOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_DIRSVC_NETWORKOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_DISCONNECTNAMEDPIPE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_DOMAINSERVICESOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_DSGETDCNAME', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_DTCOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_ENCRYPTMESSAGE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_FILEOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_FINDFILE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_FLUSHFILEBUFFERS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_FORMATMESSAGE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_FREECREDENTIALSHANDLE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_FREELIBRARY', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_GENERICOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_GETADDRINFO', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_GETCOMPRESSEDFILESIZE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_GETDISKFREESPACE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_GETFILEATTRIBUTES', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_GETFILESIZE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_GETFINALFILEPATHBYHANDLE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_GETLONGPATHNAME', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_GETPROCADDRESS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_GETVOLUMENAMEFORVOLUMEMOUNTPOINT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_GETVOLUMEPATHNAME', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_INITIALIZESECURITYCONTEXT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_LIBRARYOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_LOADLIBRARY', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_LOGONUSER', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_LOOKUPACCOUNTSID', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_MESSAGEQUEUEOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_MOVEFILE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_NETGROUPGETUSERS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_NETLOCALGROUPGETMEMBERS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_NETUSERGETGROUPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_NETUSERGETLOCALGROUPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_NETUSERMODALSGET', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_NETVALIDATEPASSWORDPOLICY', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_NETVALIDATEPASSWORDPOLICYFREE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_OPENDIRECTORY', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_PDH_WMI_INIT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_PIPEOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_PROCESSOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_QUERYCONTEXTATTRIBUTES', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_QUERYREGISTRY', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_QUERYSECURITYCONTEXTTOKEN', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_REMOVEDIRECTORY', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_REPORTEVENT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_REVERTTOSELF', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_RSFXDEVICEOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_SECURITYOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_SERVICEOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_SETENDOFFILE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_SETFILEPOINTER', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_SETFILEVALIDDATA', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_SETNAMEDSECURITYINFO', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_SQLCLROPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_SQMLAUNCH', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_VERIFYSIGNATURE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_VERIFYTRUST', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_VSSOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_WAITFORSINGLEOBJECT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_WINSOCKOPS', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_WRITEFILE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_WRITEFILEGATHER', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_OS_WSASETLASTERROR', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_REENLIST', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_RESIZELOG', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_ROLLFORWARDREDO', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_ROLLFORWARDUNDO', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_SB_STOPENDPOINT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_SERVER_STARTUP', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_SETRMINFO', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_SHAREDMEM_GETDATA', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_SNIOPEN', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_SOSHOST', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_SOSTESTING', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_SP_SERVER_DIAGNOSTICS', 'Preemptive', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_STARTRM', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_STREAMFCB_CHECKPOINT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_STREAMFCB_RECOVER', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_STRESSDRIVER', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_TESTING', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_TRANSIMPORT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_UNMARSHALPROPAGATIONTOKEN', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_VSS_CREATESNAPSHOT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_VSS_CREATEVOLUMESNAPSHOT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_XE_CALLBACKEXECUTE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_XE_CX_FILE_OPEN', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_XE_CX_HTTP_CALL', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_XE_DISPATCHER', 'Preemptive', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_XE_ENGINEINIT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_XE_GETTARGETSTATE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_XE_SESSIONCOMMIT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_XE_TARGETFINALIZE', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_XE_TARGETINIT', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_XE_TIMERRUN', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PREEMPTIVE_XETESTING', 'Preemptive', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PWAIT_HADR_ACTION_COMPLETED', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PWAIT_HADR_CHANGE_NOTIFIER_TERMINATION_SYNC', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PWAIT_HADR_CLUSTER_INTEGRATION', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PWAIT_HADR_FAILOVER_COMPLETED', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PWAIT_HADR_JOIN', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PWAIT_HADR_OFFLINE_COMPLETED', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PWAIT_HADR_ONLINE_COMPLETED', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PWAIT_HADR_POST_ONLINE_COMPLETED', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PWAIT_HADR_SERVER_READY_CONNECTIONS', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PWAIT_HADR_WORKITEM_COMPLETED', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PWAIT_HADRSIM', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('PWAIT_RESOURCE_SEMAPHORE_FT_PARALLEL_QUERY_SYNC', 'Full Text Search', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('QDS_ASYNC_QUEUE', 'Other', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', 'Other', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('QDS_PERSIST_TASK_MAIN_LOOP_SLEEP', 'Other', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('QDS_SHUTDOWN_QUEUE', 'Other', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('QUERY_TRACEOUT', 'Tracing', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('REDO_THREAD_PENDING_WORK', 'Other', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('REPL_CACHE_ACCESS', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('REPL_HISTORYCACHE_ACCESS', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('REPL_SCHEMA_ACCESS', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('REPL_TRANFSINFO_ACCESS', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('REPL_TRANHASHTABLE_ACCESS', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('REPL_TRANTEXTINFO_ACCESS', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('REPLICA_WRITES', 'Replication', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('REQUEST_FOR_DEADLOCK_SEARCH', 'Idle', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('RESERVED_MEMORY_ALLOCATION_EXT', 'Memory', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('RESOURCE_SEMAPHORE', 'Memory', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('RESOURCE_SEMAPHORE_QUERY_COMPILE', 'Compilation', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_BPOOL_FLUSH', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_BUFFERPOOL_HELPLW', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_DBSTARTUP', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_DCOMSTARTUP', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_MASTERDBREADY', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_MASTERMDREADY', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_MASTERUPGRADED', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_MEMORYPOOL_ALLOCATEPAGES', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_MSDBSTARTUP', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_RETRY_VIRTUALALLOC', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_SYSTEMTASK', 'Idle', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_TASK', 'Idle', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_TEMPDBSTARTUP', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SLEEP_WORKSPACE_ALLOCATEPAGE', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SOS_SCHEDULER_YIELD', 'CPU', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SOS_WORK_DISPATCHER', 'Idle', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SP_SERVER_DIAGNOSTICS_SLEEP', 'Other', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SQLCLR_APPDOMAIN', 'SQL CLR', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SQLCLR_ASSEMBLY', 'SQL CLR', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SQLCLR_DEADLOCK_DETECTION', 'SQL CLR', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SQLCLR_QUANTUM_PUNISHMENT', 'SQL CLR', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SQLTRACE_BUFFER_FLUSH', 'Idle', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SQLTRACE_FILE_BUFFER', 'Tracing', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SQLTRACE_FILE_READ_IO_COMPLETION', 'Tracing', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SQLTRACE_FILE_WRITE_IO_COMPLETION', 'Tracing', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SQLTRACE_INCREMENTAL_FLUSH_SLEEP', 'Idle', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SQLTRACE_PENDING_BUFFER_WRITERS', 'Tracing', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SQLTRACE_SHUTDOWN', 'Tracing', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('SQLTRACE_WAIT_ENTRIES', 'Idle', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('THREADPOOL', 'Worker Thread', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('TRACE_EVTNOTIF', 'Tracing', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('TRACEWRITE', 'Tracing', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('TRAN_MARKLATCH_DT', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('TRAN_MARKLATCH_EX', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('TRAN_MARKLATCH_KP', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('TRAN_MARKLATCH_NL', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('TRAN_MARKLATCH_SH', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('TRAN_MARKLATCH_UP', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('TRANSACTION_MUTEX', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('UCS_SESSION_REGISTRATION', 'Other', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('WAIT_FOR_RESULTS', 'User Wait', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('WAIT_XTP_OFFLINE_CKPT_NEW_LOG', 'Other', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('WAITFOR', 'User Wait', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('WRITE_COMPLETION', 'Other Disk IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('WRITELOG', 'Tran Log IO', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('XACT_OWN_TRANSACTION', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('XACT_RECLAIM_SESSION', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('XACTLOCKINFO', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('XACTWORKSPACE_MUTEX', 'Transaction', 0);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('XE_DISPATCHER_WAIT', 'Idle', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('XE_LIVE_TARGET_TVF', 'Other', 1);
                            insert into ##waitcategories(waittype, waitcategory, ignorable)
                            values ('XE_TIMER_EVENT', 'Idle', 1);
                        end; /* IF SELECT SUM(1) FROM ##WaitCategories <> 527 */


                    if OBJECT_ID('tempdb..#MasterFiles') is not null
                        drop table #masterfiles;
                    create table #masterfiles
                    (
                        database_id int,
                        file_id int,
                        type_desc nvarchar(50),
                        name nvarchar(255),
                        physical_name nvarchar(255),
                        size bigint
                    );
                    /* Azure SQL Database doesn't have sys.master_files, so we have to build our own. */
                    if ((SERVERPROPERTY('Edition')) = 'SQL Azure'
                        and (OBJECT_ID('sys.master_files') is null))
                        set @stringtoexecute =
                                'INSERT INTO #MasterFiles (database_id, file_id, type_desc, name, physical_name, size) SELECT DB_ID(), file_id, type_desc, name, physical_name, size FROM sys.database_files;';
                    else
                        set @stringtoexecute =
                                'INSERT INTO #MasterFiles (database_id, file_id, type_desc, name, physical_name, size) SELECT database_id, file_id, type_desc, name, physical_name, size FROM sys.master_files;';
                    exec (@stringtoexecute);

                    if @filterplansbydatabase is not null
                        begin
                            if UPPER(LEFT(@filterplansbydatabase, 4)) = 'USER'
                                begin
                                    insert into #filterplansbydatabase (databaseid)
                                    select database_id
                                    from sys.databases
                                    where [name] not in ('master', 'model', 'msdb', 'tempdb');
                                end;
                            else
                                begin
                                    set @filterplansbydatabase = @filterplansbydatabase + ',';
                                    with a as
                                             (
                                                 select CAST(1 as bigint)                      f,
                                                        CHARINDEX(',', @filterplansbydatabase) t,
                                                        1                                      seq
                                                 union all
                                                 select t + 1, CHARINDEX(',', @filterplansbydatabase, t + 1), seq + 1
                                                 from a
                                                 where CHARINDEX(',', @filterplansbydatabase, t + 1) > 0
                                             )
                                    insert
                                    #filterplansbydatabase
                                    (
                                    databaseid
                                    )
                                    select distinct db.database_id
                                    from a
                                             inner join sys.databases db
                                                        on LTRIM(RTRIM(SUBSTRING(@filterplansbydatabase, a.f, a.t - a.f))) =
                                                           db.name
                                    where SUBSTRING(@filterplansbydatabase, f, t - f) is not null
                                    option (maxrecursion 0);
                                end;
                        end;

                    if OBJECT_ID('tempdb..#ReadableDBs') is not null
                        drop table #readabledbs;
                    create table #readabledbs
                    (
                        database_id int
                    );

                    if EXISTS(select * from sys.all_objects o where o.name = 'dm_hadr_database_replica_states')
                        begin
                            raiserror ('Checking for Read intent databases to exclude',0,0) with nowait;

                            set @stringtoexecute =
                                    'INSERT INTO #ReadableDBs (database_id) SELECT DBs.database_id FROM sys.databases DBs INNER JOIN sys.availability_replicas Replicas ON DBs.replica_id = Replicas.replica_id WHERE replica_server_name NOT IN (SELECT DISTINCT primary_replica FROM sys.dm_hadr_availability_group_states States) AND Replicas.secondary_role_allow_connections_desc = ''READ_ONLY'' AND replica_server_name = @@SERVERNAME;';
                            exec (@stringtoexecute);

                        end

                    declare @v decimal(6, 2),
                        @build int,
                        @memgrantsortsupported bit = 1;

                    raiserror (N'Determining SQL Server version.',0,1) with nowait;

                    insert into #checkversion (version)
                    select CAST(SERVERPROPERTY('ProductVersion') as nvarchar(128))
                    option (recompile);


                    select @v = common_version,
                           @build = build
                    from #checkversion
                    option (recompile);

                    if (@v < 11)
                        or (@v = 11 and @build < 6020)
                        or (@v = 12 and @build < 5000)
                        or (@v = 13 and @build < 1601)
                        set @memgrantsortsupported = 0;

                    if EXISTS(select * from sys.all_objects where name = 'dm_exec_query_statistics_xml')
                        and
                       ((@v = 13 and @build >= 5337) /* This DMF causes assertion errors: https://support.microsoft.com/en-us/help/4490136/fix-assertion-error-occurs-when-you-use-sys-dm-exec-query-statistics-x */
                           or (@v = 14 and @build >= 3162)
                           or (@v >= 15)
                           or (@v <= 12)) /* Azure */
                        set @dm_exec_query_statistics_xml = 1;


                    set @stockwarningheader = '<?ClickToSeeCommmand -- ' + @linefeed + @linefeed
                        + 'WARNING: Running this command may result in data loss or an outage.' + @linefeed
                        + 'This tool is meant as a shortcut to help generate scripts for DBAs.' + @linefeed
                        + 'It is not a substitute for database training and experience.' + @linefeed
                        + 'Now, having said that, here''s the details:' + @linefeed + @linefeed;

                    select @stockwarningfooter = @stockwarningfooter + @linefeed + @linefeed + '-- ?>',
                           @stockdetailsheader = @stockdetailsheader + '<?ClickToSeeDetails -- ' + @linefeed,
                           @stockdetailsfooter = @stockdetailsfooter + @linefeed + ' -- ?>';

                    /* Get the instance name to use as a Perfmon counter prefix. */
                    if CAST(SERVERPROPERTY('edition') as varchar(100)) = 'SQL Azure'
                        select top 1 @servicename = LEFT(object_name, (CHARINDEX(':', object_name) - 1))
                        from sys.dm_os_performance_counters;
                    else
                        begin
                            set @stringtoexecute =
                                    'INSERT INTO #PerfmonStats(object_name, Pass, SampleTime, counter_name, cntr_type) SELECT CASE WHEN @@SERVICENAME = ''MSSQLSERVER'' THEN ''SQLServer'' ELSE ''MSSQL$'' + @@SERVICENAME END, 0, SYSDATETIMEOFFSET(), ''stuffing'', 0 ;';
                            exec (@stringtoexecute);
                            select @servicename = object_name from #perfmonstats;
                            delete #perfmonstats;
                        end;

                    /* Build a list of queries that were run in the last 10 seconds.
       We're looking for the death-by-a-thousand-small-cuts scenario
       where a query is constantly running, and it doesn't have that
       big of an impact individually, but it has a ton of impact
       overall. We're going to build this list, and then after we
       finish our @Seconds sample, we'll compare our plan cache to
       this list to see what ran the most. */

                    /* Populate #QueryStats. SQL 2005 doesn't have query hash or query plan hash. */
                    if @checkprocedurecache = 1
                        begin
                            raiserror ('@CheckProcedureCache = 1, capturing first pass of plan cache',10,1) with nowait;
                            if @@VERSION like 'Microsoft SQL Server 2005%'
                                begin
                                    if @filterplansbydatabase is null
                                        begin
                                            set @stringtoexecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 1 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, NULL AS query_hash, NULL AS query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
											WHERE qs.last_execution_time >= (DATEADD(ss, -10, SYSDATETIMEOFFSET()));';
                                        end;
                                    else
                                        begin
                                            set @stringtoexecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 1 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, NULL AS query_hash, NULL AS query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
												CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) AS attr
												INNER JOIN #FilterPlansByDatabase dbs ON CAST(attr.value AS INT) = dbs.DatabaseID
											WHERE qs.last_execution_time >= (DATEADD(ss, -10, SYSDATETIMEOFFSET()))
												AND attr.attribute = ''dbid'';';
                                        end;
                                end;
                            else
                                begin
                                    if @filterplansbydatabase is null
                                        begin
                                            set @stringtoexecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 1 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
											WHERE qs.last_execution_time >= (DATEADD(ss, -10, SYSDATETIMEOFFSET()));';
                                        end;
                                    else
                                        begin
                                            set @stringtoexecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 1 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
											CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) AS attr
											INNER JOIN #FilterPlansByDatabase dbs ON CAST(attr.value AS INT) = dbs.DatabaseID
											WHERE qs.last_execution_time >= (DATEADD(ss, -10, SYSDATETIMEOFFSET()))
												AND attr.attribute = ''dbid'';';
                                        end;
                                end;
                            exec (@stringtoexecute);

                            /* Get the totals for the entire plan cache */
                            insert into #querystats (pass, sampletime, execution_count, total_worker_time,
                                                     total_physical_reads, total_logical_writes, total_logical_reads,
                                                     total_clr_time, total_elapsed_time, creation_time)
                            select -1 as pass,
                                   SYSDATETIMEOFFSET(),
                                   SUM(execution_count),
                                   SUM(total_worker_time),
                                   SUM(total_physical_reads),
                                   SUM(total_logical_writes),
                                   SUM(total_logical_reads),
                                   SUM(total_clr_time),
                                   SUM(total_elapsed_time),
                                   MIN(creation_time)
                            from sys.dm_exec_query_stats qs;
                        end; /*IF @CheckProcedureCache = 1 */


                    if EXISTS(select *
                              from tempdb.sys.all_objects obj
                                       inner join tempdb.sys.all_columns col1
                                                  on obj.object_id = col1.object_id and col1.name = 'object_name'
                                       inner join tempdb.sys.all_columns col2
                                                  on obj.object_id = col2.object_id and col2.name = 'counter_name'
                                       inner join tempdb.sys.all_columns col3
                                                  on obj.object_id = col3.object_id and col3.name = 'instance_name'
                              where obj.name like '%CustomPerfmonCounters%')
                        begin
                            set @stringtoexecute =
                                    'INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) SELECT [object_name],[counter_name],[instance_name] FROM #CustomPerfmonCounters';
                            exec (@stringtoexecute);
                        end;
                    else
                        begin
                            /* Add our default Perfmon counters */
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Access Methods', 'Forwarded Records/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Access Methods', 'Page compression attempts/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Access Methods', 'Page Splits/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Access Methods', 'Skipped Ghosted Records/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Access Methods', 'Table Lock Escalations/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Access Methods', 'Worktables Created/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Availability Group', 'Active Hadr Threads', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Availability Replica', 'Bytes Received from Replica/sec',
                                    '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Availability Replica', 'Bytes Sent to Replica/sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Availability Replica', 'Bytes Sent to Transport/sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Availability Replica', 'Flow Control Time (ms/sec)', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Availability Replica', 'Flow Control/sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Availability Replica', 'Resent Messages/sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Availability Replica', 'Sends to Replica/sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Page life expectancy', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Page reads/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Page writes/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Readahead pages/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Target pages', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Total pages', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Databases', '', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Active Transactions', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Database Flow Control Delay', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Database Flow Controls/sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Group Commit Time', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Group Commits/Sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Log Apply Pending Queue', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Log Apply Ready Queue', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Log Compression Cache misses/sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Log remaining for undo', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Log Send Queue', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Recovery Queue', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Redo blocked/sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Redo Bytes Remaining', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Database Replica', 'Redone Bytes/sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Databases', 'Log Bytes Flushed/sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Databases', 'Log Growths', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Databases', 'Log Pool LogWriter Pushes/sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Databases', 'Log Shrinks', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Databases', 'Transactions/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Databases', 'Write Transactions/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Databases', 'XTP Memory Used (KB)', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Exec Statistics', 'Distributed Query', 'Execs in progress');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Exec Statistics', 'DTC calls', 'Execs in progress');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Exec Statistics', 'Extended Procedures', 'Execs in progress');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Exec Statistics', 'OLEDB calls', 'Execs in progress');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':General Statistics', 'Active Temp Tables', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':General Statistics', 'Logins/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':General Statistics', 'Logouts/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':General Statistics', 'Mars Deadlocks', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':General Statistics', 'Processes blocked', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Locks', 'Number of Deadlocks/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Memory Manager', 'Memory Grants Pending', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':SQL Errors', 'Errors/sec', '_Total');
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':SQL Statistics', 'Batch Requests/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':SQL Statistics', 'Forced Parameterizations/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':SQL Statistics', 'Guided plan executions/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':SQL Statistics', 'SQL Attention rate', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':SQL Statistics', 'SQL Compilations/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':SQL Statistics', 'SQL Re-Compilations/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Workload Group Stats', 'Query optimizations/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Workload Group Stats', 'Suboptimal plans/sec', null);
                            /* Below counters added by Jefferson Elias */
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Access Methods', 'Worktables From Cache Base', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Access Methods', 'Worktables From Cache Ratio', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Database pages', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Free pages', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Stolen pages', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Memory Manager', 'Granted Workspace Memory (KB)', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Memory Manager', 'Maximum Workspace Memory (KB)', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Memory Manager', 'Target Server Memory (KB)', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Memory Manager', 'Total Server Memory (KB)', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Buffer cache hit ratio', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Buffer cache hit ratio base', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Checkpoint pages/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Free list stalls/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Lazy writes/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':SQL Statistics', 'Auto-Param Attempts/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':SQL Statistics', 'Failed Auto-Params/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':SQL Statistics', 'Safe Auto-Params/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':SQL Statistics', 'Unsafe Auto-Params/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Access Methods', 'Workfiles Created/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':General Statistics', 'User Connections', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Latches', 'Average Latch Wait Time (ms)', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Latches', 'Average Latch Wait Time Base', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Latches', 'Latch Waits/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Latches', 'Total Latch Wait Time (ms)', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Locks', 'Average Wait Time (ms)', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Locks', 'Average Wait Time Base', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Locks', 'Lock Requests/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Locks', 'Lock Timeouts/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Locks', 'Lock Wait Time (ms)', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Locks', 'Lock Waits/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Transactions', 'Longest Transaction Running Time', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Access Methods', 'Full Scans/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Access Methods', 'Index Searches/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Buffer Manager', 'Page lookups/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values (@servicename + ':Cursor Manager by Type', 'Active cursors', null);
                            /* Below counters are for In-Memory OLTP (Hekaton), which have a different naming convention.
           And yes, they actually hard-coded the version numbers into the counters, and SQL 2019 still says 2017, oddly.
           For why, see: https://connect.microsoft.com/SQLServer/feedback/details/817216/xtp-perfmon-counters-should-appear-under-sql-server-perfmon-counter-group
        */
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2014 XTP Cursors', 'Expired rows removed/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2014 XTP Cursors', 'Expired rows touched/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2014 XTP Garbage Collection', 'Rows processed/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2014 XTP IO Governor', 'Io Issued/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2014 XTP Phantom Processor', 'Phantom expired rows touched/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2014 XTP Phantom Processor', 'Phantom rows touched/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2014 XTP Transaction Log', 'Log bytes written/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2014 XTP Transaction Log', 'Log records written/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2014 XTP Transactions', 'Transactions aborted by user/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2014 XTP Transactions', 'Transactions aborted/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2014 XTP Transactions', 'Transactions created/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2016 XTP Cursors', 'Expired rows removed/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2016 XTP Cursors', 'Expired rows touched/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2016 XTP Garbage Collection', 'Rows processed/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2016 XTP IO Governor', 'Io Issued/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2016 XTP Phantom Processor', 'Phantom expired rows touched/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2016 XTP Phantom Processor', 'Phantom rows touched/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2016 XTP Transaction Log', 'Log bytes written/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2016 XTP Transaction Log', 'Log records written/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2016 XTP Transactions', 'Transactions aborted by user/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2016 XTP Transactions', 'Transactions aborted/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2016 XTP Transactions', 'Transactions created/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2017 XTP Cursors', 'Expired rows removed/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2017 XTP Cursors', 'Expired rows touched/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2017 XTP Garbage Collection', 'Rows processed/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2017 XTP IO Governor', 'Io Issued/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2017 XTP Phantom Processor', 'Phantom expired rows touched/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2017 XTP Phantom Processor', 'Phantom rows touched/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2017 XTP Transaction Log', 'Log bytes written/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2017 XTP Transaction Log', 'Log records written/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2017 XTP Transactions', 'Transactions aborted by user/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2017 XTP Transactions', 'Transactions aborted/sec', null);
                            insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                            values ('SQL Server 2017 XTP Transactions', 'Transactions created/sec', null);
                        end;

                    /* Populate #FileStats, #PerfmonStats, #WaitStats with DMV data.
        After we finish doing our checks, we'll take another sample and compare them. */
                    raiserror ('Capturing first pass of wait stats, perfmon counters, file stats',10,1) with nowait;
                    insert #waitstats(pass, sampletime, wait_type, wait_time_ms, signal_wait_time_ms,
                                      waiting_tasks_count)
                    select x.pass,
                           x.sampletime,
                           x.wait_type,
                           SUM(x.sum_wait_time_ms)        as sum_wait_time_ms,
                           SUM(x.sum_signal_wait_time_ms) as sum_signal_wait_time_ms,
                           SUM(x.sum_waiting_tasks)       as sum_waiting_tasks
                    from (
                             select 1                                                                       as pass,
                                    case @seconds when 0 then @startsampletime else SYSDATETIMEOFFSET() end as sampletime,
                                    owt.wait_type,
                                    case @seconds
                                        when 0 then 0
                                        else SUM(owt.wait_duration_ms) over (partition by owt.wait_type, owt.session_id)
                                            -
                                             case when @seconds = 0 then 0 else (@seconds * 1000) end end   as sum_wait_time_ms,
                                    0                                                                       as sum_signal_wait_time_ms,
                                    0                                                                       as sum_waiting_tasks
                             from sys.dm_os_waiting_tasks owt
                             where owt.session_id > 50
                               and owt.wait_duration_ms >= case @seconds when 0 then 0 else @seconds * 1000 end
                             union all
                             select 1                                                                          as pass,
                                    case @seconds when 0 then @startsampletime else SYSDATETIMEOFFSET() end    as sampletime,
                                    os.wait_type,
                                    case @seconds
                                        when 0 then 0
                                        else SUM(os.wait_time_ms) over (partition by os.wait_type) end         as sum_wait_time_ms,
                                    case @seconds
                                        when 0 then 0
                                        else SUM(os.signal_wait_time_ms) over (partition by os.wait_type ) end as sum_signal_wait_time_ms,
                                    case @seconds
                                        when 0 then 0
                                        else SUM(os.waiting_tasks_count) over (partition by os.wait_type) end  as sum_waiting_tasks
                             from sys.dm_os_wait_stats os
                         ) x
                    where EXISTS
                              (
                                  select 1 / 0
                                  from ##waitcategories as wc
                                  where wc.waittype = x.wait_type
                                    and wc.ignorable = 0
                              )
                    group by x.pass, x.sampletime, x.wait_type
                    order by sum_wait_time_ms desc;


                    insert into #filestats (pass, sampletime, databaseid, fileid, databasename, filelogicalname,
                                            sizeondiskmb, io_stall_read_ms,
                                            num_of_reads, [bytes_read], io_stall_write_ms, num_of_writes,
                                            [bytes_written], physicalname, typedesc)
                    select 1                                                                          as pass,
                           case @seconds when 0 then @startsampletime else SYSDATETIMEOFFSET() end    as sampletime,
                           mf.[database_id],
                           mf.[file_id],
                           DB_NAME(vfs.database_id)                                                   as [db_name],
                           mf.name + N' [' + mf.type_desc collate sql_latin1_general_cp1_ci_as +
                           N']'                                                                       as file_logical_name,
                           CAST(((vfs.size_on_disk_bytes / 1024.0) / 1024.0) as int)                  as size_on_disk_mb,
                           case @seconds when 0 then 0 else vfs.io_stall_read_ms end,
                           case @seconds when 0 then 0 else vfs.num_of_reads end,
                           case @seconds when 0 then 0 else vfs.[num_of_bytes_read] end,
                           case @seconds when 0 then 0 else vfs.io_stall_write_ms end,
                           case @seconds when 0 then 0 else vfs.num_of_writes end,
                           case @seconds when 0 then 0 else vfs.[num_of_bytes_written] end,
                           mf.physical_name,
                           mf.type_desc
                    from sys.dm_io_virtual_file_stats(null, null) as vfs
                             inner join #masterfiles as mf on vfs.file_id = mf.file_id
                        and vfs.database_id = mf.database_id
                    where vfs.num_of_reads > 0
                       or vfs.num_of_writes > 0;

                    insert into #perfmonstats (pass, sampletime, [object_name], [counter_name], [instance_name],
                                               [cntr_value], [cntr_type])
                    select 1                                                                       as pass,
                           case @seconds when 0 then @startsampletime else SYSDATETIMEOFFSET() end as sampletime,
                           RTRIM(dmv.object_name),
                           RTRIM(dmv.counter_name),
                           RTRIM(dmv.instance_name),
                           case @seconds when 0 then 0 else dmv.cntr_value end,
                           dmv.cntr_type
                    from #perfmoncounters counters
                             inner join sys.dm_os_performance_counters dmv
                                        on counters.counter_name collate sql_latin1_general_cp1_ci_as =
                                           RTRIM(dmv.counter_name) collate sql_latin1_general_cp1_ci_as
                                            and counters.[object_name] collate sql_latin1_general_cp1_ci_as =
                                                RTRIM(dmv.[object_name]) collate sql_latin1_general_cp1_ci_as
                                            and (counters.[instance_name] is null or
                                                 counters.[instance_name] collate sql_latin1_general_cp1_ci_as =
                                                 RTRIM(dmv.[instance_name]) collate sql_latin1_general_cp1_ci_as);

                    /* If they want to run sp_BlitzWho and export to table, go for it. */
                    if @outputtablenameblitzwho is not null
                        and @outputdatabasename is not null
                        and @outputschemaname is not null
                        and EXISTS(select *
                                   from sys.databases
                                   where QUOTENAME([name]) = @outputdatabasename)
                        begin
                            raiserror ('Logging sp_BlitzWho to table',10,1) with nowait;
                            exec sp_BlitzWho @outputdatabasename = @unquotedoutputdatabasename,
                                 @outputschemaname = @unquotedoutputschemaname,
                                 @outputtablename = @outputtablenameblitzwho, @checkdateoverride = @startsampletime;
                        end

                    raiserror ('Beginning investigatory queries',10,1) with nowait;


                    /* Maintenance Tasks Running - Backup Running - CheckID 1 */
                    if @seconds > 0
                        insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details,
                                                        howtostopit, queryplan, starttime, loginname, ntusername,
                                                        programname, hostname, databaseid, databasename,
                                                        opentransactioncount, queryhash)
                        select 1                                                   as checkid,
                               1                                                   as priority,
                               'Maintenance Tasks Running'                         as findinggroup,
                               'Backup Running'                                    as finding,
                               'http://www.BrentOzar.com/askbrent/backups/'        as url,
                               'Backup of ' + DB_NAME(db.resource_database_id) + ' database (' +
                               (select CAST(CAST(SUM(size * 8.0 / 1024 / 1024) as bigint) as nvarchar)
                                from #masterfiles
                                where database_id = db.resource_database_id) + 'GB) ' + @linefeed
                                   + CAST(r.percent_complete as nvarchar(100)) + '% complete, has been running since ' +
                               CAST(r.start_time as nvarchar(100)) + '. ' + @linefeed
                                   + case
                                         when COALESCE(s.nt_user_name, s.login_name) is not null
                                             then (' Login: ' + COALESCE(s.nt_user_name, s.login_name) + ' ')
                                         else '' end                               as details,
                               'KILL ' + CAST(r.session_id as nvarchar(100)) + ';' as howtostopit,
                               pl.query_plan                                       as queryplan,
                               r.start_time                                        as starttime,
                               s.login_name                                        as loginname,
                               s.nt_user_name                                      as ntusername,
                               s.[program_name]                                    as programname,
                               s.[host_name]                                       as hostname,
                               db.[resource_database_id]                           as databaseid,
                               DB_NAME(db.resource_database_id)                    as databasename,
                               0                                                   as opentransactioncount,
                               r.query_hash
                        from sys.dm_exec_requests r
                                 inner join sys.dm_exec_connections c on r.session_id = c.session_id
                                 inner join sys.dm_exec_sessions s on r.session_id = s.session_id
                                 inner join (
                            select distinct request_session_id, resource_database_id
                            from sys.dm_tran_locks
                            where resource_type = N'DATABASE'
                              and request_mode = N'S'
                              and request_status = N'GRANT'
                              and request_owner_type = N'SHARED_TRANSACTION_WORKSPACE') as db
                                            on s.session_id = db.request_session_id
                                 cross apply sys.dm_exec_query_plan(r.plan_handle) pl
                        where r.command like 'BACKUP%'
                          and r.start_time <= DATEADD(minute, -5, GETDATE())
                          and r.database_id not in (select database_id from #readabledbs);

                    /* If there's a backup running, add details explaining how long full backup has been taking in the last month. */
                    if @seconds > 0 and CAST(SERVERPROPERTY('edition') as varchar(100)) <> 'SQL Azure'
                        begin
                            set @stringtoexecute =
                                    'UPDATE #BlitzFirstResults SET Details = Details + '' Over the last 60 days, the full backup usually takes '' + CAST((SELECT AVG(DATEDIFF(mi, bs.backup_start_date, bs.backup_finish_date)) FROM msdb.dbo.backupset bs WHERE abr.DatabaseName = bs.database_name AND bs.type = ''D'' AND bs.backup_start_date > DATEADD(dd, -60, SYSDATETIMEOFFSET()) AND bs.backup_finish_date IS NOT NULL) AS NVARCHAR(100)) + '' minutes.'' FROM #BlitzFirstResults abr WHERE abr.CheckID = 1 AND EXISTS (SELECT * FROM msdb.dbo.backupset bs WHERE bs.type = ''D'' AND bs.backup_start_date > DATEADD(dd, -60, SYSDATETIMEOFFSET()) AND bs.backup_finish_date IS NOT NULL AND abr.DatabaseName = bs.database_name AND DATEDIFF(mi, bs.backup_start_date, bs.backup_finish_date) > 1)';
                            exec (@stringtoexecute);
                        end;


                    /* Maintenance Tasks Running - DBCC CHECK* Running - CheckID 2 */
                    if @seconds > 0 and EXISTS(select * from sys.dm_exec_requests where command like 'DBCC%')
                        insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details,
                                                        howtostopit, queryplan, starttime, loginname, ntusername,
                                                        programname, hostname, databaseid, databasename,
                                                        opentransactioncount, queryhash)
                        select 2                                                   as checkid,
                               1                                                   as priority,
                               'Maintenance Tasks Running'                         as findinggroup,
                               'DBCC CHECK* Running'                               as finding,
                               'http://www.BrentOzar.com/askbrent/dbcc/'           as url,
                               'Corruption check of ' + DB_NAME(db.resource_database_id) + ' database (' +
                               (select CAST(CAST(SUM(size * 8.0 / 1024 / 1024) as bigint) as nvarchar)
                                from #masterfiles
                                where database_id = db.resource_database_id) + 'GB) has been running since ' +
                               CAST(r.start_time as nvarchar(100)) + '. '          as details,
                               'KILL ' + CAST(r.session_id as nvarchar(100)) + ';' as howtostopit,
                               pl.query_plan                                       as queryplan,
                               r.start_time                                        as starttime,
                               s.login_name                                        as loginname,
                               s.nt_user_name                                      as ntusername,
                               s.[program_name]                                    as programname,
                               s.[host_name]                                       as hostname,
                               db.[resource_database_id]                           as databaseid,
                               DB_NAME(db.resource_database_id)                    as databasename,
                               0                                                   as opentransactioncount,
                               r.query_hash
                        from sys.dm_exec_requests r
                                 inner join sys.dm_exec_connections c on r.session_id = c.session_id
                                 inner join sys.dm_exec_sessions s on r.session_id = s.session_id
                                 inner join (select distinct l.request_session_id, l.resource_database_id
                                             from sys.dm_tran_locks l
                                                      inner join sys.databases d on l.resource_database_id = d.database_id
                                             where l.resource_type = N'DATABASE'
                                               and l.request_mode = N'S'
                                               and l.request_status = N'GRANT'
                                               and l.request_owner_type = N'SHARED_TRANSACTION_WORKSPACE') as db
                                            on s.session_id = db.request_session_id
                                 cross apply sys.dm_exec_query_plan(r.plan_handle) pl
                                 cross apply sys.dm_exec_sql_text(r.sql_handle) as t
                        where r.command like 'DBCC%'
                          and CAST(t.text as nvarchar(4000)) not like '%dm_db_index_physical_stats%'
                          and CAST(t.text as nvarchar(4000)) not like '%ALTER INDEX%'
                          and CAST(t.text as nvarchar(4000)) not like '%fileproperty%'
                          and r.database_id not in (select database_id from #readabledbs);


                    /* Maintenance Tasks Running - Restore Running - CheckID 3 */
                    if @seconds > 0
                        insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details,
                                                        howtostopit, queryplan, starttime, loginname, ntusername,
                                                        programname, hostname, databaseid, databasename,
                                                        opentransactioncount, queryhash)
                        select 3                                                   as checkid,
                               1                                                   as priority,
                               'Maintenance Tasks Running'                         as findinggroup,
                               'Restore Running'                                   as finding,
                               'http://www.BrentOzar.com/askbrent/backups/'        as url,
                               'Restore of ' + DB_NAME(db.resource_database_id) + ' database (' +
                               (select CAST(CAST(SUM(size * 8.0 / 1024 / 1024) as bigint) as nvarchar)
                                from #masterfiles
                                where database_id = db.resource_database_id) + 'GB) is ' +
                               CAST(r.percent_complete as nvarchar(100)) + '% complete, has been running since ' +
                               CAST(r.start_time as nvarchar(100)) + '. '          as details,
                               'KILL ' + CAST(r.session_id as nvarchar(100)) + ';' as howtostopit,
                               pl.query_plan                                       as queryplan,
                               r.start_time                                        as starttime,
                               s.login_name                                        as loginname,
                               s.nt_user_name                                      as ntusername,
                               s.[program_name]                                    as programname,
                               s.[host_name]                                       as hostname,
                               db.[resource_database_id]                           as databaseid,
                               DB_NAME(db.resource_database_id)                    as databasename,
                               0                                                   as opentransactioncount,
                               r.query_hash
                        from sys.dm_exec_requests r
                                 inner join sys.dm_exec_connections c on r.session_id = c.session_id
                                 inner join sys.dm_exec_sessions s on r.session_id = s.session_id
                                 inner join (
                            select distinct request_session_id, resource_database_id
                            from sys.dm_tran_locks
                            where resource_type = N'DATABASE'
                              and request_mode = N'S'
                              and request_status = N'GRANT') as db on s.session_id = db.request_session_id
                                 cross apply sys.dm_exec_query_plan(r.plan_handle) pl
                        where r.command like 'RESTORE%'
                          and s.program_name <> 'SQL Server Log Shipping'
                          and r.database_id not in (select database_id from #readabledbs);


                    /* SQL Server Internal Maintenance - Database File Growing - CheckID 4 */
                    if @seconds > 0
                        insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details,
                                                        howtostopit, queryplan, starttime, loginname, ntusername,
                                                        programname, hostname, databaseid, databasename,
                                                        opentransactioncount)
                        select 4                                                                                                                                   as checkid,
                               1                                                                                                                                   as priority,
                               'SQL Server Internal Maintenance'                                                                                                   as findinggroup,
                               'Database File Growing'                                                                                                             as finding,
                               'http://www.BrentOzar.com/go/instant'                                                                                               as url,
                               'SQL Server is waiting for Windows to provide storage space for a database restore, a data file growth, or a log file growth. This task has been running since ' +
                               CAST(r.start_time as nvarchar(100)) + '.' + @linefeed +
                               'Check the query plan (expert mode) to identify the database involved.'                                                             as details,
                               'Unfortunately, you can''t stop this, but you can prevent it next time. Check out http://www.BrentOzar.com/go/instant for details.' as howtostopit,
                               pl.query_plan                                                                                                                       as queryplan,
                               r.start_time                                                                                                                        as starttime,
                               s.login_name                                                                                                                        as loginname,
                               s.nt_user_name                                                                                                                      as ntusername,
                               s.[program_name]                                                                                                                    as programname,
                               s.[host_name]                                                                                                                       as hostname,
                               null                                                                                                                                as databaseid,
                               null                                                                                                                                as databasename,
                               0                                                                                                                                   as opentransactioncount
                        from sys.dm_os_waiting_tasks t
                                 inner join sys.dm_exec_connections c on t.session_id = c.session_id
                                 inner join sys.dm_exec_requests r on t.session_id = r.session_id
                                 inner join sys.dm_exec_sessions s on r.session_id = s.session_id
                                 cross apply sys.dm_exec_query_plan(r.plan_handle) pl
                        where t.wait_type = 'PREEMPTIVE_OS_WRITEFILEGATHER'
                          and r.database_id not in (select database_id from #readabledbs);


                    /* Query Problems - Long-Running Query Blocking Others - CheckID 5 */
                    if SERVERPROPERTY('Edition') <> 'SQL Azure' and @seconds > 0 and EXISTS(
                            select * from sys.dm_os_waiting_tasks where wait_type like 'LCK%'
                                                                    and wait_duration_ms > 30000)
                        begin
                            set @stringtoexecute = N'INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, QueryText, StartTime, LoginName, NTUserName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount, QueryHash)
            SELECT 5 AS CheckID,
                1 AS Priority,
                ''Query Problems'' AS FindingGroup,
                ''Long-Running Query Blocking Others'' AS Finding,
                ''http://www.BrentOzar.com/go/blocking'' AS URL,
                ''Query in '' + COALESCE(DB_NAME(COALESCE((SELECT TOP 1 dbid FROM sys.dm_exec_sql_text(r.sql_handle)),
                    (SELECT TOP 1 t.dbid FROM master..sysprocesses spBlocker CROSS APPLY sys.dm_exec_sql_text(spBlocker.sql_handle) t WHERE spBlocker.spid = tBlocked.blocking_session_id))), ''(Unknown)'') + '' has a last request start time of '' + CAST(s.last_request_start_time AS NVARCHAR(100)) + ''. Query follows: '
                                + @linefeed + @linefeed +
                                                   '''+ CAST(COALESCE((SELECT TOP 1 [text] FROM sys.dm_exec_sql_text(r.sql_handle)),
                    (SELECT TOP 1 [text] FROM master..sysprocesses spBlocker CROSS APPLY sys.dm_exec_sql_text(spBlocker.sql_handle) WHERE spBlocker.spid = tBlocked.blocking_session_id), '''') AS NVARCHAR(2000)) AS Details,
                ''KILL '' + CAST(tBlocked.blocking_session_id AS NVARCHAR(100)) + '';'' AS HowToStopIt,
                (SELECT TOP 1 query_plan FROM sys.dm_exec_query_plan(r.plan_handle)) AS QueryPlan,
                COALESCE((SELECT TOP 1 [text] FROM sys.dm_exec_sql_text(r.sql_handle)),
                    (SELECT TOP 1 [text] FROM master..sysprocesses spBlocker CROSS APPLY sys.dm_exec_sql_text(spBlocker.sql_handle) WHERE spBlocker.spid = tBlocked.blocking_session_id)) AS QueryText,
                r.start_time AS StartTime,
                s.login_name AS LoginName,
                s.nt_user_name AS NTUserName,
                s.[program_name] AS ProgramName,
                s.[host_name] AS HostName,
                r.[database_id] AS DatabaseID,
                DB_NAME(r.database_id) AS DatabaseName,
                0 AS OpenTransactionCount,
                r.query_hash
            FROM sys.dm_os_waiting_tasks tBlocked
	        INNER JOIN sys.dm_exec_sessions s ON tBlocked.blocking_session_id = s.session_id
            LEFT OUTER JOIN sys.dm_exec_requests r ON s.session_id = r.session_id
            INNER JOIN sys.dm_exec_connections c ON s.session_id = c.session_id
            WHERE tBlocked.wait_type LIKE ''LCK%'' AND tBlocked.wait_duration_ms > 30000
              /* And the blocking session ID is not blocked by anyone else: */
              AND NOT EXISTS(SELECT * FROM sys.dm_os_waiting_tasks tBlocking WHERE s.session_id = tBlocking.session_id AND tBlocking.session_id <> tBlocking.blocking_session_id AND tBlocking.blocking_session_id IS NOT NULL)
			  AND r.database_id NOT IN (SELECT database_id FROM #ReadableDBs);';
                            execute sp_executesql @stringtoexecute;
                        end;

                    /* Query Problems - Plan Cache Erased Recently */
                    if DATEADD(mi, -15, SYSDATETIME()) <
                       (select top 1 creation_time from sys.dm_exec_query_stats order by creation_time)
                        begin
                            insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                            select top 1 7                                                                      as checkid,
                                         50                                                                     as priority,
                                         'Query Problems'                                                       as findinggroup,
                                         'Plan Cache Erased Recently'                                           as finding,
                                         'http://www.BrentOzar.com/askbrent/plan-cache-erased-recently/'        as url,
                                         'The oldest query in the plan cache was created at ' +
                                         CAST(creation_time as nvarchar(50)) + '. ' + @linefeed + @linefeed
                                             + 'This indicates that someone ran DBCC FREEPROCCACHE at that time,' +
                                         @linefeed
                                             + 'Giving SQL Server temporary amnesia. Now, as queries come in,' +
                                         @linefeed
                                             + 'SQL Server has to use a lot of CPU power in order to build execution' +
                                         @linefeed
                                             +
                                         'plans and put them in cache again. This causes high CPU loads.'       as details,
                                         'Find who did that, and stop them from doing it again.'                as howtostopit
                            from sys.dm_exec_query_stats
                            order by creation_time;
                        end;


                    /* Query Problems - Sleeping Query with Open Transactions - CheckID 8 */
                    if @seconds > 0
                        insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details,
                                                        howtostopit, starttime, loginname, ntusername, programname,
                                                        hostname, databaseid, databasename, querytext,
                                                        opentransactioncount)
                        select 8                                                                          as checkid,
                               50                                                                         as priority,
                               'Query Problems'                                                           as findinggroup,
                               'Sleeping Query with Open Transactions'                                    as finding,
                               'http://www.brentozar.com/askbrent/sleeping-query-with-open-transactions/' as url,
                               'Database: ' + DB_NAME(db.resource_database_id) + @linefeed + 'Host: ' + s.[host_name] +
                               @linefeed + 'Program: ' + s.[program_name] + @linefeed +
                               'Asleep with open transactions and locks since ' +
                               CAST(s.last_request_end_time as nvarchar(100)) + '. '                      as details,
                               'KILL ' + CAST(s.session_id as nvarchar(100)) + ';'                        as howtostopit,
                               s.last_request_start_time                                                  as starttime,
                               s.login_name                                                               as loginname,
                               s.nt_user_name                                                             as ntusername,
                               s.[program_name]                                                           as programname,
                               s.[host_name]                                                              as hostname,
                               db.[resource_database_id]                                                  as databaseid,
                               DB_NAME(db.resource_database_id)                                           as databasename,
                               (select top 1 [text] from sys.dm_exec_sql_text(c.most_recent_sql_handle))  as querytext,
                               sessions_with_transactions.open_transaction_count                          as opentransactioncount
                        from (select session_id, SUM(open_transaction_count) as open_transaction_count
                              from sys.dm_exec_requests
                              where open_transaction_count > 0
                              group by session_id) as sessions_with_transactions
                                 inner join sys.dm_exec_sessions s
                                            on sessions_with_transactions.session_id = s.session_id
                                 inner join sys.dm_exec_connections c on s.session_id = c.session_id
                                 inner join (
                            select distinct request_session_id, resource_database_id
                            from sys.dm_tran_locks
                            where resource_type = N'DATABASE'
                              and request_mode = N'S'
                              and request_status = N'GRANT'
                              and request_owner_type = N'SHARED_TRANSACTION_WORKSPACE') as db
                                            on s.session_id = db.request_session_id
                        where s.status = 'sleeping'
                          and s.last_request_end_time < DATEADD(ss, -10, SYSDATETIME())
                          and EXISTS(select *
                                     from sys.dm_tran_locks
                                     where request_session_id = s.session_id
                                       and not (resource_type = N'DATABASE' and request_mode = N'S' and
                                                request_status = N'GRANT' and
                                                request_owner_type = N'SHARED_TRANSACTION_WORKSPACE'));


                    /*Query Problems - Clients using implicit transactions */
                    if @seconds > 0
                        and (@@VERSION not like 'Microsoft SQL Server 2005%'
                            and @@VERSION not like 'Microsoft SQL Server 2008%'
                            and @@VERSION not like 'Microsoft SQL Server 2008 R2%')
                        begin
                            set @stringtoexecute = N'INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, StartTime, LoginName, NTUserName, ProgramName, HostName, DatabaseID, DatabaseName, QueryText, OpenTransactionCount)
		SELECT  37 AS CheckId,
		        50 AS Priority,
		        ''Query Problems'' AS FindingsGroup,
		        ''Implicit Transactions'',
		        ''https://www.brentozar.com/go/ImplicitTransactions/'' AS URL,
		        ''Database: '' + DB_NAME(s.database_id)  + '' '' + CHAR(13) + CHAR(10) +
				''Host: '' + s.[host_name]  + '' '' + CHAR(13) + CHAR(10) +
				''Program: '' + s.[program_name]  + '' '' + CHAR(13) + CHAR(10) +
				CONVERT(NVARCHAR(10), s.open_transaction_count) +
				'' open transactions since: '' +
				CONVERT(NVARCHAR(30), tat.transaction_begin_time) + ''. ''
					AS Details,
				''Run sp_BlitzWho and check the is_implicit_transaction column to spot the culprits.
If one of them is a lead blocker, consider killing that query.'' AS HowToStopit,
		        tat.transaction_begin_time,
		        s.login_name,
		        s.nt_user_name,
		        s.program_name,
		        s.host_name,
		        s.database_id,
		        DB_NAME(s.database_id) AS DatabaseName,
		        NULL AS Querytext,
		        s.open_transaction_count AS OpenTransactionCount
		FROM    sys.dm_tran_active_transactions AS tat
		LEFT JOIN sys.dm_tran_session_transactions AS tst
		ON tst.transaction_id = tat.transaction_id
		LEFT JOIN sys.dm_exec_sessions AS s
		ON s.session_id = tst.session_id
		WHERE tat.name = ''implicit_transaction'';
		'
                            execute sp_executesql @stringtoexecute;
                        end;

                    /* Query Problems - Query Rolling Back - CheckID 9 */
                    if @seconds > 0
                        insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details,
                                                        howtostopit, starttime, loginname, ntusername, programname,
                                                        hostname, databaseid, databasename, querytext, queryhash)
                        select 9                                                                                                                                              as checkid,
                               1                                                                                                                                              as priority,
                               'Query Problems'                                                                                                                               as findinggroup,
                               'Query Rolling Back'                                                                                                                           as finding,
                               'http://www.BrentOzar.com/askbrent/rollback/'                                                                                                  as url,
                               'Rollback started at ' + CAST(r.start_time as nvarchar(100)) + ', is ' +
                               CAST(r.percent_complete as nvarchar(100)) +
                               '% complete.'                                                                                                                                  as details,
                               'Unfortunately, you can''t stop this. Whatever you do, don''t restart the server in an attempt to fix it - SQL Server will keep rolling back.' as howtostopit,
                               r.start_time                                                                                                                                   as starttime,
                               s.login_name                                                                                                                                   as loginname,
                               s.nt_user_name                                                                                                                                 as ntusername,
                               s.[program_name]                                                                                                                               as programname,
                               s.[host_name]                                                                                                                                  as hostname,
                               db.[resource_database_id]                                                                                                                      as databaseid,
                               DB_NAME(db.resource_database_id)                                                                                                               as databasename,
                               (select top 1 [text]
                                from sys.dm_exec_sql_text(c.most_recent_sql_handle))                                                                                          as querytext,
                               r.query_hash
                        from sys.dm_exec_sessions s
                                 inner join sys.dm_exec_connections c on s.session_id = c.session_id
                                 inner join sys.dm_exec_requests r on s.session_id = r.session_id
                                 left outer join (
                            select distinct request_session_id, resource_database_id
                            from sys.dm_tran_locks
                            where resource_type = N'DATABASE'
                              and request_mode = N'S'
                              and request_status = N'GRANT'
                              and request_owner_type = N'SHARED_TRANSACTION_WORKSPACE') as db
                                                 on s.session_id = db.request_session_id
                        where r.status = 'rollback';


                    /* Server Performance - Too Much Free Memory - CheckID 34 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                    select 34                                                                                                       as checkid,
                           50                                                                                                       as priority,
                           'Server Performance'                                                                                     as findinggroup,
                           'Too Much Free Memory'                                                                                   as finding,
                           'https://BrentOzar.com/go/freememory'                                                                    as url,
                           CAST((CAST(cfree.cntr_value as bigint) / 1024 / 1024) as nvarchar(100)) +
                           N'GB of free memory inside SQL Server''s buffer pool,' + @linefeed + ' which is ' +
                           CAST((CAST(ctotal.cntr_value as bigint) / 1024 / 1024) as nvarchar(100)) +
                           N'GB. You would think lots of free memory would be good, but check out the URL for more information.'    as details,
                           'Run sp_BlitzCache @SortOrder = ''memory grant'' to find queries with huge memory grants and tune them.' as howtostopit
                    from sys.dm_os_performance_counters cfree
                             inner join sys.dm_os_performance_counters ctotal
                                        on ctotal.object_name like N'%Memory Manager%'
                                            and ctotal.counter_name =
                                                N'Total Server Memory (KB)                                                                                                        '
                    where cfree.object_name like N'%Memory Manager%'
                      and cfree.counter_name =
                          N'Free Memory (KB)                                                                                                                '
                      and CAST(cfree.cntr_value as bigint) > 20480000000
                      and CAST(ctotal.cntr_value as bigint) * .3 <= CAST(cfree.cntr_value as bigint)
                      and CAST(SERVERPROPERTY('edition') as varchar(100)) not like '%Standard%';

                    /* Server Performance - Target Memory Lower Than Max - CheckID 35 */
                    if SERVERPROPERTY('Edition') <> 'SQL Azure'
                        insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                        select 35                                                                                                            as checkid,
                               10                                                                                                            as priority,
                               'Server Performance'                                                                                          as findinggroup,
                               'Target Memory Lower Than Max'                                                                                as finding,
                               'https://BrentOzar.com/go/target'                                                                             as url,
                               N'Max server memory is ' + CAST(cmax.value_in_use as nvarchar(50)) +
                               N' MB but target server memory is only ' +
                               CAST((CAST(ctarget.cntr_value as bigint) / 1024) as nvarchar(50)) + N' MB,' + @linefeed
                                   +
                               N'indicating that SQL Server may be under external memory pressure or max server memory may be set too high.' as details,
                               'Investigate what OS processes are using memory, and double-check the max server memory setting.'             as howtostopit
                        from sys.configurations cmax
                                 inner join sys.dm_os_performance_counters ctarget
                                            on ctarget.object_name like N'%Memory Manager%'
                                                and ctarget.counter_name =
                                                    N'Target Server Memory (KB)                                                                                                       '
                        where cmax.name = 'max server memory (MB)'
                          and CAST(cmax.value_in_use as bigint) >= 1.5 * (CAST(ctarget.cntr_value as bigint) / 1024)
                          and CAST(cmax.value_in_use as bigint) < 2147483647 /* Not set to default of unlimited */
                          and CAST(ctarget.cntr_value as bigint) <
                              .8 * (select available_physical_memory_kb from sys.dm_os_sys_memory);
                    /* Target memory less than 80% of physical memory (in case they set max too high) */

                    /* Server Info - Database Size, Total GB - CheckID 21 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, details, detailsint, url)
                    select 21                                                                   as checkid,
                           251                                                                  as priority,
                           'Server Info'                                                        as findinggroup,
                           'Database Size, Total GB'                                            as finding,
                           CAST(SUM(CAST(size as bigint) * 8. / 1024. / 1024.) as varchar(100)) as details,
                           SUM(CAST(size as bigint)) * 8. / 1024. / 1024.                       as detailsint,
                           'http://www.BrentOzar.com/askbrent/'                                 as url
                    from #masterfiles
                    where database_id > 4;

                    /* Server Info - Database Count - CheckID 22 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, details, detailsint, url)
                    select 22                                   as checkid,
                           251                                  as priority,
                           'Server Info'                        as findinggroup,
                           'Database Count'                     as finding,
                           CAST(SUM(1) as varchar(100))         as details,
                           SUM(1)                               as detailsint,
                           'http://www.BrentOzar.com/askbrent/' as url
                    from sys.databases
                    where database_id > 4;

                    /* Server Info - Memory Grants pending - CheckID 39 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, details, detailsint, url)
                    select 39                                               as checkid,
                           50                                               as priority,
                           'Server Performance'                             as findinggroup,
                           'Memory Grants Pending'                          as finding,
                           CAST(pendinggrants.details as nvarchar(50))      as details,
                           pendinggrants.detailsint,
                           'https://www.brentozar.com/blitz/memory-grants/' as url
                    from (
                             select COUNT(1) as details,
                                    COUNT(1) as detailsint
                             from sys.dm_exec_query_memory_grants as grants
                             where queue_id is not null
                         ) as pendinggrants
                    where pendinggrants.details > 0;

                    /* Server Info - Memory Grant/Workspace info - CheckID 40 */
                    declare @maxworkspace bigint
                    set @maxworkspace = (select CAST(cntr_value as bigint) / 1024
                                         from #perfmonstats
                                         where counter_name = N'Maximum Workspace Memory (KB)')

                    if (@maxworkspace is null
                        or @maxworkspace = 0)
                        begin
                            set @maxworkspace = 1
                        end

                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, details, detailsint, url)
                    select 40 as                                                                                        checkid,
                           251 as                                                                                       priority,
                           'Server Info' as                                                                             findinggroup,
                           'Memory Grant/Workspace info' as                                                             finding,
                           + 'Grants Outstanding: ' + CAST((select COUNT(*)
                                                            from sys.dm_exec_query_memory_grants
                                                            where queue_id is null) as nvarchar(50)) + @linefeed
                               + 'Total Granted(MB): ' +
                           CAST(ISNULL(SUM(grants.granted_memory_kb) / 1024, 0) as nvarchar(50)) + @linefeed
                               + 'Total WorkSpace(MB): ' + CAST(ISNULL(@maxworkspace, 0) as nvarchar(50)) + @linefeed
                               + 'Granted workspace: ' +
                           CAST(ISNULL((CAST(SUM(grants.granted_memory_kb) / 1024 as money)
                               / CAST(@maxworkspace as money)) * 100, 0) as nvarchar(50)) + '%' + @linefeed
                               + 'Oldest Grant in seconds: ' + CAST(
                                   ISNULL(DATEDIFF(second, MIN(grants.request_time), GETDATE()), 0) as nvarchar(50)) as details,
                           (select COUNT(*)
                            from sys.dm_exec_query_memory_grants
                            where queue_id is null) as                                                                  detailsint,
                           'http://www.BrentOzar.com/askbrent/' as                                                      url
                    from sys.dm_exec_query_memory_grants as grants;

                    /* Query Problems - Memory Leak in USERSTORE_TOKENPERM Cache */
                    if EXISTS(select *
                              from sys.all_columns
                              where object_id = OBJECT_ID('sys.dm_os_memory_clerks') and name = 'pages_kb')
                        begin
                            /* SQL 2012+ version */
                            set @stringtoexecute = N'
        INSERT  INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, Details, URL)
        SELECT 45 AS CheckID,
                50 AS Priority,
                ''Query Problems'' AS FindingsGroup,
                ''Memory Leak in USERSTORE_TOKENPERM Cache'' AS Finding,
                N''UserStore_TokenPerm clerk is using '' + CAST(CAST(SUM(CASE WHEN type = ''USERSTORE_TOKENPERM'' AND name = ''TokenAndPermUserStore'' THEN pages_kb * 1.0 ELSE 0.0 END) / 1024.0 / 1024.0 AS INT) AS NVARCHAR(100))
                    + N''GB RAM, total buffer pool is '' + CAST(CAST(SUM(pages_kb) / 1024.0 / 1024.0 AS INT) AS NVARCHAR(100)) + N''GB.''
                AS details,
                ''https://www.BrentOzar.com/go/userstore'' AS URL
        FROM sys.dm_os_memory_clerks
        HAVING SUM(CASE WHEN type = ''USERSTORE_TOKENPERM'' AND name = ''TokenAndPermUserStore'' THEN pages_kb * 1.0 ELSE 0.0 END) / SUM(pages_kb) >= 0.1
            AND SUM(pages_kb) / 1024.0 / 1024.0 >= 1; /* At least 1GB RAM overall */';
                            exec sp_executesql @stringtoexecute;
                        end
                    else
                        begin
                            /* Antiques Roadshow SQL 2008R2 - version */
                            set @stringtoexecute = N'
        INSERT  INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, Details, URL)
        SELECT 45 AS CheckID,
                50 AS Priority,
                ''Performance'' AS FindingsGroup,
                ''Memory Leak in USERSTORE_TOKENPERM Cache'' AS Finding,
                N''UserStore_TokenPerm clerk is using '' + CAST(CAST(SUM(CASE WHEN type = ''USERSTORE_TOKENPERM'' AND name = ''TokenAndPermUserStore'' THEN single_pages_kb + multi_pages_kb * 1.0 ELSE 0.0 END) / 1024.0 / 1024.0 AS INT) AS NVARCHAR(100))
                    + N''GB RAM, total buffer pool is '' + CAST(CAST(SUM(single_pages_kb + multi_pages_kb) / 1024.0 / 1024.0 AS INT) AS NVARCHAR(100)) + N''GB.''
                AS details,
                ''https://www.BrentOzar.com/go/userstore'' AS URL
        FROM sys.dm_os_memory_clerks
        HAVING SUM(CASE WHEN type = ''USERSTORE_TOKENPERM'' AND name = ''TokenAndPermUserStore'' THEN single_pages_kb + multi_pages_kb * 1.0 ELSE 0.0 END) / SUM(single_pages_kb + multi_pages_kb) >= 0.1
            AND SUM(single_pages_kb + multi_pages_kb) / 1024.0 / 1024.0 >= 1; /* At least 1GB RAM overall */';
                            exec sp_executesql @stringtoexecute;
                        end


                    if @seconds > 0
                        begin

                            if EXISTS(select 1 / 0
                                      from sys.all_objects as ao
                                      where ao.name = 'dm_exec_query_profiles')
                                begin

                                    if EXISTS(select 1 / 0
                                              from sys.dm_exec_requests as r
                                                       join sys.dm_exec_sessions as s
                                                            on r.session_id = s.session_id
                                              where s.host_name is not null
                                                and r.total_elapsed_time > 5000)
                                        begin

                                            set @stringtoexecute = N'
                   DECLARE @bad_estimate TABLE
                     (
                       session_id INT,
                       request_id INT,
                       estimate_inaccuracy BIT
                     );

                   INSERT @bad_estimate ( session_id, request_id, estimate_inaccuracy )
                   SELECT x.session_id,
                          x.request_id,
                          x.estimate_inaccuracy
                   FROM (
                         SELECT deqp.session_id,
                                deqp.request_id,
                                CASE WHEN deqp.row_count > ( deqp.estimate_row_count * 10000 )
                                     THEN 1
                                     ELSE 0
                                END AS estimate_inaccuracy
                         FROM   sys.dm_exec_query_profiles AS deqp
						 WHERE deqp.session_id <> @@SPID
                   ) AS x
                   WHERE x.estimate_inaccuracy = 1
                   GROUP BY x.session_id,
                            x.request_id,
                            x.estimate_inaccuracy;

                   DECLARE @parallelism_skew TABLE
                     (
                       session_id INT,
                       request_id INT,
                       parallelism_skew BIT
                     );

                   INSERT @parallelism_skew ( session_id, request_id, parallelism_skew )
                   SELECT y.session_id,
                          y.request_id,
                          y.parallelism_skew
                   FROM (
                         SELECT x.session_id,
                                x.request_id,
                                x.node_id,
                                x.thread_id,
                                x.row_count,
                                x.sum_node_rows,
                                x.node_dop,
                                x.sum_node_rows / x.node_dop AS even_distribution,
                                x.row_count / (1. * ISNULL(NULLIF(x.sum_node_rows / x.node_dop, 0), 1)) AS skew_percent,
                                CASE
                                    WHEN x.row_count > 10000
                                    AND x.row_count / (1. * ISNULL(NULLIF(x.sum_node_rows / x.node_dop, 0), 1)) > 2.
                                    THEN 1
                                    WHEN x.row_count > 10000
                                    AND x.row_count / (1. * ISNULL(NULLIF(x.sum_node_rows / x.node_dop, 0), 1)) < 0.5
                                    THEN 1
                                    ELSE 0
                         	   END AS parallelism_skew
                         FROM (
                         	       SELECT deqp.session_id,
                                              deqp.request_id,
                                              deqp.node_id,
                                              deqp.thread_id,
                         	       	   deqp.row_count,
                         	       	   SUM(deqp.row_count)
                         	       		OVER ( PARTITION BY deqp.session_id,
                                                                   deqp.request_id,
                         	       		                    deqp.node_id
                         	       			   ORDER BY deqp.row_count
                         	       			   ROWS BETWEEN UNBOUNDED PRECEDING
                         	       			   AND UNBOUNDED FOLLOWING )
                         	       			   AS sum_node_rows,
                         	       	   COUNT(*)
                         	       		OVER ( PARTITION BY deqp.session_id,
                                                                   deqp.request_id,
                         	       		                    deqp.node_id
                         	       			   ORDER BY deqp.row_count
                         	       			   ROWS BETWEEN UNBOUNDED PRECEDING
                         	       			   AND UNBOUNDED FOLLOWING )
                         	       			   AS node_dop
                         	       FROM sys.dm_exec_query_profiles AS deqp
                         	       WHERE deqp.thread_id > 0
								   AND deqp.session_id <> @@SPID
                         	       AND EXISTS
                         	       	(
                         	       		SELECT 1/0
                         	       		FROM   sys.dm_exec_query_profiles AS deqp2
                         	       		WHERE deqp.session_id = deqp2.session_id
                         	       		AND   deqp.node_id = deqp2.node_id
                         	       		AND   deqp2.thread_id > 0
                         	       		GROUP BY deqp2.session_id, deqp2.node_id
                         	       		HAVING COUNT(deqp2.node_id) > 1
                         	       	)
                         	   ) AS x
                         ) AS y
                   WHERE y.parallelism_skew = 1
                   GROUP BY y.session_id,
                            y.request_id,
                            y.parallelism_skew;

                   /*
                   CheckID 42: Queries in dm_exec_query_profiles showing signs of poor cardinality estimates
                   */
                   INSERT INTO #BlitzFirstResults
                   (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, StartTime, LoginName, NTUserName, ProgramName, HostName, DatabaseID, DatabaseName, QueryText, OpenTransactionCount, QueryHash, QueryPlan)
                   SELECT 42 AS CheckID,
                          100 AS Priority,
                          ''Query Performance'' AS FindingsGroup,
                          ''Queries with 10000x cardinality misestimations'' AS Findings,
                          ''https://brentozar.com/go/skewedup'' AS URL,
                          ''The query on SPID ''
                              + RTRIM(b.session_id)
                              + '' has been running for ''
                              + RTRIM(r.total_elapsed_time / 1000)
                              + '' seconds,  with a large cardinality misestimate'' AS Details,
                          ''No quick fix here: time to dig into the actual execution plan. '' AS HowToStopIt,
                          r.start_time,
                          s.login_name,
                          s.nt_user_name,
                          s.program_name,
                          s.host_name,
                          r.database_id,
                          DB_NAME(r.database_id),
                          dest.text,
                          s.open_transaction_count,
                          r.query_hash, ';

                                            if @dm_exec_query_statistics_xml = 1
                                                set @stringtoexecute = @stringtoexecute +
                                                                       N' COALESCE(qs_live.query_plan, qp.query_plan) AS query_plan ';
                                            else
                                                set @stringtoexecute = @stringtoexecute + N' qp.query_plan ';

                                            set @stringtoexecute = @stringtoexecute + N'
                  FROM @bad_estimate AS b
                  JOIN sys.dm_exec_requests AS r
                  ON r.session_id = b.session_id
                  AND r.request_id = b.request_id
                  JOIN sys.dm_exec_sessions AS s
                  ON s.session_id = b.session_id
                  CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS dest
				  CROSS APPLY sys.dm_exec_query_plan(r.plan_handle) AS qp ';

                                            if EXISTS(
                                                    select * from sys.all_objects where name = 'dm_exec_query_statistics_xml')
                                                set @stringtoexecute = @stringtoexecute +
                                                                       N' OUTER APPLY sys.dm_exec_query_statistics_xml(s.session_id) qs_live ';


                                            set @stringtoexecute = @stringtoexecute + N';

                   /*
                   CheckID 43: Queries in dm_exec_query_profiles showing signs of unbalanced parallelism
                   */
                   INSERT INTO #BlitzFirstResults
                   (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, StartTime, LoginName, NTUserName, ProgramName, HostName, DatabaseID, DatabaseName, QueryText, OpenTransactionCount, QueryHash, QueryPlan)
                   SELECT 43 AS CheckID,
                          100 AS Priority,
                          ''Query Performance'' AS FindingsGroup,
                          ''Queries with 10000x skewed parallelism'' AS Findings,
                          ''https://brentozar.com/go/skewedup'' AS URL,
                          ''The query on SPID ''
                              + RTRIM(p.session_id)
                              + '' has been running for ''
                              + RTRIM(r.total_elapsed_time / 1000)
                              + '' seconds,  with a parallel threads doing uneven work.'' AS Details,
                          ''No quick fix here: time to dig into the actual execution plan. '' AS HowToStopIt,
                          r.start_time,
                          s.login_name,
                          s.nt_user_name,
                          s.program_name,
                          s.host_name,
                          r.database_id,
                          DB_NAME(r.database_id),
                          dest.text,
                          s.open_transaction_count,
                          r.query_hash, ';

                                            if @dm_exec_query_statistics_xml = 1
                                                set @stringtoexecute = @stringtoexecute +
                                                                       N' COALESCE(qs_live.query_plan, qp.query_plan) AS query_plan ';
                                            else
                                                set @stringtoexecute = @stringtoexecute + N' qp.query_plan ';

                                            set @stringtoexecute = @stringtoexecute + N'
                  FROM @parallelism_skew AS p
                  JOIN sys.dm_exec_requests AS r
                  ON r.session_id = p.session_id
                  AND r.request_id = p.request_id
                  JOIN sys.dm_exec_sessions AS s
                  ON s.session_id = p.session_id
                  CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS dest
				  CROSS APPLY sys.dm_exec_query_plan(r.plan_handle) AS qp ';

                                            if EXISTS(
                                                    select * from sys.all_objects where name = 'dm_exec_query_statistics_xml')
                                                set @stringtoexecute = @stringtoexecute +
                                                                       N' OUTER APPLY sys.dm_exec_query_statistics_xml(s.session_id) qs_live ';


                                            set @stringtoexecute = @stringtoexecute + N';';

                                            execute sp_executesql @stringtoexecute;
                                        end

                                end
                        end

                    /* Server Performance - High CPU Utilization CheckID 24 */
                    if @seconds < 30
                        begin
                            /* If we're waiting less than 30 seconds, run this check now rather than wait til the end.
           We get this data from the ring buffers, and it's only updated once per minute, so might
           as well get it now - whereas if we're checking 30+ seconds, it might get updated by the
           end of our sp_BlitzFirst session. */
                            insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, details, detailsint, url)
                            select 24,
                                   50,
                                   'Server Performance',
                                   'High CPU Utilization',
                                   CAST(100 - systemidle as nvarchar(20)) + N'%.',
                                   100 - systemidle,
                                   'http://www.BrentOzar.com/go/cpu'
                            from (
                                     select record,
                                            record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]',
                                                         'int') as systemidle
                                     from (
                                              select top 1 CONVERT(xml, record) as record
                                              from sys.dm_os_ring_buffers
                                              where ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'
                                                and record like '%<SystemHealth>%'
                                              order by timestamp desc) as rb
                                 ) as y
                            where 100 - systemidle >= 50;

                            if SERVERPROPERTY('Edition') <> 'SQL Azure'
                                with y
                                         as
                                         (
                                             select CONVERT(varchar(5), 100 - ca.c.value('.', 'INT')) as system_idle,
                                                    CONVERT(varchar(30), rb.event_date)               as event_date,
                                                    CONVERT(varchar(8000), rb.record)                 as record
                                             from (select CONVERT(xml, dorb.record)                              as record,
                                                          DATEADD(ms, (ts.ms_ticks - dorb.timestamp), GETDATE()) as event_date
                                                   from sys.dm_os_ring_buffers as dorb
                                                            cross join
                                                            (select dosi.ms_ticks from sys.dm_os_sys_info as dosi) as ts
                                                   where dorb.ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'
                                                     and record like '%<SystemHealth>%') as rb
                                                      cross apply rb.record.nodes(
                                                     '/Record/SchedulerMonitorEvent/SystemHealth/SystemIdle') as ca(c)
                                         )
                                insert
                                into #blitzfirstresults (checkid, priority, findingsgroup, finding, details, detailsint,
                                                         url, howtostopit)
                                select top 1 23,
                                             250,
                                             'Server Info',
                                             'CPU Utilization',
                                             y.system_idle + N'%. Ring buffer details: ' +
                                             CAST(y.record as nvarchar(4000)),
                                             y.system_idle,
                                             'http://www.BrentOzar.com/go/cpu',
                                             STUFF((select top 2147483647 CHAR(10) + CHAR(13)
                                                                              + y2.system_idle
                                                                              + '% ON '
                                                                              + y2.event_date
                                                                              + ' Ring buffer details:  '
                                                                              + y2.record
                                                    from y as y2
                                                    order by y2.event_date desc
                                                    for xml path(N''), type).value(N'.[1]', N'VARCHAR(MAX)'), 1, 1,
                                                   N'') as query
                                from y
                                order by y.event_date desc;


                            /* Highlight if non SQL processes are using >25% CPU */
                            insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, details, detailsint, url)
                            select 28,
                                   50,
                                   'Server Performance',
                                   'High CPU Utilization - Not SQL',
                                   CONVERT(nvarchar(100), 100 - (y.sqlusage + y.systemidle)) +
                                   N'% - Other Processes (not SQL Server) are using this much CPU. This may impact on the performance of your SQL Server instance',
                                   100 - (y.sqlusage + y.systemidle),
                                   'http://www.BrentOzar.com/go/cpu'
                            from (
                                     select record,
                                            record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]',
                                                         'int') as systemidle
                                             ,
                                            record.value(
                                                    '(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]',
                                                    'int')      as sqlusage
                                     from (
                                              select top 1 CONVERT(xml, record) as record
                                              from sys.dm_os_ring_buffers
                                              where ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'
                                                and record like '%<SystemHealth>%'
                                              order by timestamp desc) as rb
                                 ) as y
                            where 100 - (y.sqlusage + y.systemidle) >= 25;

                        end;
                    /* IF @Seconds < 30 */

                    /* Query Problems - Statistics Updated Recently - CheckID 44 */
                    if 20 >=
                       (select COUNT(*) from sys.databases where name not in ('master', 'model', 'msdb', 'tempdb'))
                        begin
                            create table #updatedstats
                            (
                                howtostopit nvarchar(4000),
                                rowsforsorting bigint
                            );
                            if EXISTS(select * from sys.all_objects where name = 'dm_db_stats_properties')
                                begin
                                    exec sp_MSforeachdb N'USE [?];
			INSERT INTO #UpdatedStats(HowToStopIt, RowsForSorting)
			SELECT HowToStopIt =
						QUOTENAME(DB_NAME()) + N''.'' +
						QUOTENAME(SCHEMA_NAME(obj.schema_id)) + N''.'' +
						QUOTENAME(obj.name) +
						N'' statistic '' + QUOTENAME(stat.name) +
						N'' was updated on '' + CONVERT(NVARCHAR(50), sp.last_updated, 121) + N'','' +
						N'' had '' + CAST(sp.rows AS NVARCHAR(50)) + N'' rows, with '' +
						CAST(sp.rows_sampled AS NVARCHAR(50)) + N'' rows sampled,'' +
						N'' producing '' + CAST(sp.steps AS NVARCHAR(50)) + N'' steps in the histogram.'',
				sp.rows
			FROM sys.objects AS obj
			INNER JOIN sys.stats AS stat ON stat.object_id = obj.object_id
			CROSS APPLY sys.dm_db_stats_properties(stat.object_id, stat.stats_id) AS sp
			WHERE sp.last_updated > DATEADD(MI, -15, GETDATE())
			AND obj.is_ms_shipped = 0
			AND ''[?]'' <> ''[tempdb]'';';
                                end;

                            if EXISTS(select * from #updatedstats)
                                insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                                select            44                                  as checkid,
                                                  50                                  as priority,
                                                  'Query Problems'                    as findinggroup,
                                                  'Statistics Updated Recently'       as finding,
                                                  'http://www.BrentOzar.com/go/stats' as url,
                                                  'In the last 15 minutes, statistics were updated. To see which ones, click the HowToStopIt column.' +
                                                  @linefeed + @linefeed
                                                      +
                                                  'This effectively clears the plan cache for queries that involve these tables,' +
                                                  @linefeed
                                                      +
                                                  'which thereby causes parameter sniffing: those queries are now getting brand new' +
                                                  @linefeed
                                                      +
                                                  'query plans based on whatever parameters happen to call them next.' +
                                                  @linefeed + @linefeed
                                                      +
                                                  'Be on the lookout for sudden parameter sniffing issues after this time range.',
                                    howtostopit = (select (select howtostopit + NCHAR(10))
                                                   from #updatedstats
                                                   order by rowsforsorting desc
                                                   for xml path(''));

                        end

                    raiserror ('Finished running investigatory queries',10,1) with nowait;


                    /* End of checks. If we haven't waited @Seconds seconds, wait. */
                    if DATEADD(second, 1, SYSDATETIMEOFFSET()) < @finishsampletime
                        begin
                            raiserror ('Waiting to match @Seconds parameter',10,1) with nowait;
                            waitfor time @finishsampletimewaitfor;
                        end;

                    raiserror ('Capturing second pass of wait stats, perfmon counters, file stats',10,1) with nowait;
                    /* Populate #FileStats, #PerfmonStats, #WaitStats with DMV data. In a second, we'll compare these. */
                    insert #waitstats(pass, sampletime, wait_type, wait_time_ms, signal_wait_time_ms,
                                      waiting_tasks_count)
                    select x.pass,
                           x.sampletime,
                           x.wait_type,
                           SUM(x.sum_wait_time_ms)        as sum_wait_time_ms,
                           SUM(x.sum_signal_wait_time_ms) as sum_signal_wait_time_ms,
                           SUM(x.sum_waiting_tasks)       as sum_waiting_tasks
                    from (
                             select 2                                                              as pass,
                                    SYSDATETIMEOFFSET()                                            as sampletime,
                                    owt.wait_type,
                                    SUM(owt.wait_duration_ms) over (partition by owt.wait_type, owt.session_id)
                                        - case when @seconds = 0 then 0 else (@seconds * 1000) end as sum_wait_time_ms,
                                    0                                                              as sum_signal_wait_time_ms,
                                    case @seconds when 0 then 0 else 1 end                         as sum_waiting_tasks
                             from sys.dm_os_waiting_tasks owt
                             where owt.session_id > 50
                               and owt.wait_duration_ms >= case @seconds when 0 then 0 else @seconds * 1000 end
                             union all
                             select 2                                                             as pass,
                                    SYSDATETIMEOFFSET()                                           as sampletime,
                                    os.wait_type,
                                    SUM(os.wait_time_ms) over (partition by os.wait_type)         as sum_wait_time_ms,
                                    SUM(os.signal_wait_time_ms) over (partition by os.wait_type ) as sum_signal_wait_time_ms,
                                    SUM(os.waiting_tasks_count) over (partition by os.wait_type)  as sum_waiting_tasks
                             from sys.dm_os_wait_stats os
                         ) x
                    where EXISTS
                              (
                                  select 1 / 0
                                  from ##waitcategories as wc
                                  where wc.waittype = x.wait_type
                                    and wc.ignorable = 0
                              )
                    group by x.pass, x.sampletime, x.wait_type
                    order by sum_wait_time_ms desc;

                    insert into #filestats (pass, sampletime, databaseid, fileid, databasename, filelogicalname,
                                            sizeondiskmb, io_stall_read_ms,
                                            num_of_reads, [bytes_read], io_stall_write_ms, num_of_writes,
                                            [bytes_written], physicalname, typedesc, avg_stall_read_ms,
                                            avg_stall_write_ms)
                    select 2                                                                          as pass,
                           SYSDATETIMEOFFSET()                                                        as sampletime,
                           mf.[database_id],
                           mf.[file_id],
                           DB_NAME(vfs.database_id)                                                   as [db_name],
                           mf.name + N' [' + mf.type_desc collate sql_latin1_general_cp1_ci_as +
                           N']'                                                                       as file_logical_name,
                           CAST(((vfs.size_on_disk_bytes / 1024.0) / 1024.0) as int)                  as size_on_disk_mb,
                           vfs.io_stall_read_ms,
                           vfs.num_of_reads,
                           vfs.[num_of_bytes_read],
                           vfs.io_stall_write_ms,
                           vfs.num_of_writes,
                           vfs.[num_of_bytes_written],
                           mf.physical_name,
                           mf.type_desc,
                           0,
                           0
                    from sys.dm_io_virtual_file_stats(null, null) as vfs
                             inner join #masterfiles as mf on vfs.file_id = mf.file_id
                        and vfs.database_id = mf.database_id
                    where vfs.num_of_reads > 0
                       or vfs.num_of_writes > 0;

                    insert into #perfmonstats (pass, sampletime, [object_name], [counter_name], [instance_name],
                                               [cntr_value], [cntr_type])
                    select 2                   as pass,
                           SYSDATETIMEOFFSET() as sampletime,
                           RTRIM(dmv.object_name),
                           RTRIM(dmv.counter_name),
                           RTRIM(dmv.instance_name),
                           dmv.cntr_value,
                           dmv.cntr_type
                    from #perfmoncounters counters
                             inner join sys.dm_os_performance_counters dmv
                                        on counters.counter_name collate sql_latin1_general_cp1_ci_as =
                                           RTRIM(dmv.counter_name) collate sql_latin1_general_cp1_ci_as
                                            and counters.[object_name] collate sql_latin1_general_cp1_ci_as =
                                                RTRIM(dmv.[object_name]) collate sql_latin1_general_cp1_ci_as
                                            and (counters.[instance_name] is null or
                                                 counters.[instance_name] collate sql_latin1_general_cp1_ci_as =
                                                 RTRIM(dmv.[instance_name]) collate sql_latin1_general_cp1_ci_as);

                    /* Set the latencies and averages. We could do this with a CTE, but we're not ambitious today. */
                    update fnow
                    set avg_stall_read_ms = ((fnow.io_stall_read_ms - fbase.io_stall_read_ms) /
                                             (fnow.num_of_reads - fbase.num_of_reads))
                    from #filestats fnow
                             inner join #filestats fbase
                                        on fnow.databaseid = fbase.databaseid and fnow.fileid = fbase.fileid and
                                           fnow.sampletime > fbase.sampletime and
                                           fnow.num_of_reads > fbase.num_of_reads and
                                           fnow.io_stall_read_ms > fbase.io_stall_read_ms
                    where (fnow.num_of_reads - fbase.num_of_reads) > 0;

                    update fnow
                    set avg_stall_write_ms = ((fnow.io_stall_write_ms - fbase.io_stall_write_ms) /
                                              (fnow.num_of_writes - fbase.num_of_writes))
                    from #filestats fnow
                             inner join #filestats fbase
                                        on fnow.databaseid = fbase.databaseid and fnow.fileid = fbase.fileid and
                                           fnow.sampletime > fbase.sampletime and
                                           fnow.num_of_writes > fbase.num_of_writes and
                                           fnow.io_stall_write_ms > fbase.io_stall_write_ms
                    where (fnow.num_of_writes - fbase.num_of_writes) > 0;

                    update pnow
                    set [value_delta]      = pnow.cntr_value - pfirst.cntr_value,
                        [value_per_second] = ((1.0 * pnow.cntr_value - pfirst.cntr_value) /
                                              DATEDIFF(ss, pfirst.sampletime, pnow.sampletime))
                    from #perfmonstats pnow
                             inner join #perfmonstats pfirst on pfirst.[object_name] = pnow.[object_name] and
                                                                pfirst.counter_name = pnow.counter_name and
                                                                (pfirst.instance_name = pnow.instance_name or
                                                                 (pfirst.instance_name is null and pnow.instance_name is null))
                        and pnow.id > pfirst.id
                    where DATEDIFF(ss, pfirst.sampletime, pnow.sampletime) > 0;


                    /* If we're within 10 seconds of our projected finish time, do the plan cache analysis. */
                    if DATEDIFF(ss, @finishsampletime, SYSDATETIMEOFFSET()) > 10 and @checkprocedurecache = 1
                        begin

                            insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details)
                            values (18, 210, 'Query Stats', 'Plan Cache Analysis Skipped',
                                    'http://www.BrentOzar.com/go/topqueries',
                                    'Due to excessive load, the plan cache analysis was skipped. To override this, use @ExpertMode = 1.');

                        end;
                    else
                        if @checkprocedurecache = 1
                            begin


                                raiserror ('@CheckProcedureCache = 1, capturing second pass of plan cache',10,1) with nowait;

                                /* Populate #QueryStats. SQL 2005 doesn't have query hash or query plan hash. */
                                if @@VERSION like 'Microsoft SQL Server 2005%'
                                    begin
                                        if @filterplansbydatabase is null
                                            begin
                                                set @stringtoexecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 2 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, NULL AS query_hash, NULL AS query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
											WHERE qs.last_execution_time >= @StartSampleTimeText;';
                                            end;
                                        else
                                            begin
                                                set @stringtoexecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 2 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, NULL AS query_hash, NULL AS query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
												CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) AS attr
												INNER JOIN #FilterPlansByDatabase dbs ON CAST(attr.value AS INT) = dbs.DatabaseID
											WHERE qs.last_execution_time >= @StartSampleTimeText
												AND attr.attribute = ''dbid'';';
                                            end;
                                    end;
                                else
                                    begin
                                        if @filterplansbydatabase is null
                                            begin
                                                set @stringtoexecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 2 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
											WHERE qs.last_execution_time >= @StartSampleTimeText';
                                            end;
                                        else
                                            begin
                                                set @stringtoexecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 2 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
											CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) AS attr
											INNER JOIN #FilterPlansByDatabase dbs ON CAST(attr.value AS INT) = dbs.DatabaseID
											WHERE qs.last_execution_time >= @StartSampleTimeText
												AND attr.attribute = ''dbid'';';
                                            end;
                                    end;
                                /* Old version pre-2016/06/13:
        IF @@VERSION LIKE 'Microsoft SQL Server 2005%'
            SET @StringToExecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
                                        SELECT [sql_handle], 2 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, NULL AS query_hash, NULL AS query_plan_hash, 0
                                        FROM sys.dm_exec_query_stats qs
                                        WHERE qs.last_execution_time >= @StartSampleTimeText;';
        ELSE
            SET @StringToExecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
                                        SELECT [sql_handle], 2 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, 0
                                        FROM sys.dm_exec_query_stats qs
                                        WHERE qs.last_execution_time >= @StartSampleTimeText;';
		*/
                                set @parmdefinitions = N'@StartSampleTimeText NVARCHAR(100)';
                                set @parm1 = CONVERT(nvarchar(100), CAST(@startsampletime as datetime), 127);

                                execute sp_executesql @stringtoexecute, @parmdefinitions, @startsampletimetext = @parm1;

                                raiserror ('@CheckProcedureCache = 1, totaling up plan cache metrics',10,1) with nowait;

                                /* Get the totals for the entire plan cache */
                                insert into #querystats (pass, sampletime, execution_count, total_worker_time,
                                                         total_physical_reads, total_logical_writes,
                                                         total_logical_reads, total_clr_time, total_elapsed_time,
                                                         creation_time)
                                select 0 as pass,
                                       SYSDATETIMEOFFSET(),
                                       SUM(execution_count),
                                       SUM(total_worker_time),
                                       SUM(total_physical_reads),
                                       SUM(total_logical_writes),
                                       SUM(total_logical_reads),
                                       SUM(total_clr_time),
                                       SUM(total_elapsed_time),
                                       MIN(creation_time)
                                from sys.dm_exec_query_stats qs;


                                raiserror ('@CheckProcedureCache = 1, so analyzing execution plans',10,1) with nowait;
                                /*
        Pick the most resource-intensive queries to review. Update the Points field
        in #QueryStats - if a query is in the top 10 for logical reads, CPU time,
        duration, or execution, add 1 to its points.
        */
                                with qstop as (
                                    select top 10 qsnow.id
                                    from #querystats qsnow
                                             inner join #querystats qsfirst
                                                        on qsnow.[sql_handle] = qsfirst.[sql_handle] and
                                                           qsnow.statement_start_offset = qsfirst.statement_start_offset and
                                                           qsnow.statement_end_offset = qsfirst.statement_end_offset and
                                                           qsnow.plan_generation_num = qsfirst.plan_generation_num and
                                                           qsnow.plan_handle = qsfirst.plan_handle and qsfirst.pass = 1
                                    where qsnow.total_elapsed_time > qsfirst.total_elapsed_time
                                      and qsnow.pass = 2
                                      and qsnow.total_elapsed_time - qsfirst.total_elapsed_time > 1000000 /* Only queries with over 1 second of runtime */
                                    order by (qsnow.total_elapsed_time - COALESCE(qsfirst.total_elapsed_time, 0)) desc)
                                update #querystats
                                set points = points + 1
                                from #querystats qs
                                         inner join qstop on qs.id = qstop.id;

                                with qstop as (
                                    select top 10 qsnow.id
                                    from #querystats qsnow
                                             inner join #querystats qsfirst
                                                        on qsnow.[sql_handle] = qsfirst.[sql_handle] and
                                                           qsnow.statement_start_offset = qsfirst.statement_start_offset and
                                                           qsnow.statement_end_offset = qsfirst.statement_end_offset and
                                                           qsnow.plan_generation_num = qsfirst.plan_generation_num and
                                                           qsnow.plan_handle = qsfirst.plan_handle and qsfirst.pass = 1
                                    where qsnow.total_logical_reads > qsfirst.total_logical_reads
                                      and qsnow.pass = 2
                                      and qsnow.total_logical_reads - qsfirst.total_logical_reads > 1000 /* Only queries with over 1000 reads */
                                    order by (qsnow.total_logical_reads - COALESCE(qsfirst.total_logical_reads, 0)) desc)
                                update #querystats
                                set points = points + 1
                                from #querystats qs
                                         inner join qstop on qs.id = qstop.id;

                                with qstop as (
                                    select top 10 qsnow.id
                                    from #querystats qsnow
                                             inner join #querystats qsfirst
                                                        on qsnow.[sql_handle] = qsfirst.[sql_handle] and
                                                           qsnow.statement_start_offset = qsfirst.statement_start_offset and
                                                           qsnow.statement_end_offset = qsfirst.statement_end_offset and
                                                           qsnow.plan_generation_num = qsfirst.plan_generation_num and
                                                           qsnow.plan_handle = qsfirst.plan_handle and qsfirst.pass = 1
                                    where qsnow.total_worker_time > qsfirst.total_worker_time
                                      and qsnow.pass = 2
                                      and qsnow.total_worker_time - qsfirst.total_worker_time > 1000000 /* Only queries with over 1 second of worker time */
                                    order by (qsnow.total_worker_time - COALESCE(qsfirst.total_worker_time, 0)) desc)
                                update #querystats
                                set points = points + 1
                                from #querystats qs
                                         inner join qstop on qs.id = qstop.id;

                                with qstop as (
                                    select top 10 qsnow.id
                                    from #querystats qsnow
                                             inner join #querystats qsfirst
                                                        on qsnow.[sql_handle] = qsfirst.[sql_handle] and
                                                           qsnow.statement_start_offset = qsfirst.statement_start_offset and
                                                           qsnow.statement_end_offset = qsfirst.statement_end_offset and
                                                           qsnow.plan_generation_num = qsfirst.plan_generation_num and
                                                           qsnow.plan_handle = qsfirst.plan_handle and qsfirst.pass = 1
                                    where qsnow.execution_count > qsfirst.execution_count
                                      and qsnow.pass = 2
                                      and (qsnow.total_elapsed_time - qsfirst.total_elapsed_time > 1000000 /* Only queries with over 1 second of runtime */
                                        or
                                           qsnow.total_logical_reads - qsfirst.total_logical_reads > 1000 /* Only queries with over 1000 reads */
                                        or
                                           qsnow.total_worker_time - qsfirst.total_worker_time > 1000000 /* Only queries with over 1 second of worker time */)
                                    order by (qsnow.execution_count - COALESCE(qsfirst.execution_count, 0)) desc)
                                update #querystats
                                set points = points + 1
                                from #querystats qs
                                         inner join qstop on qs.id = qstop.id;

                                /* Query Stats - CheckID 17 - Most Resource-Intensive Queries */
                                insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details,
                                                                howtostopit, queryplan, querytext, querystatsnowid,
                                                                querystatsfirstid, planhandle, queryhash)
                                select          17,
                                                210,
                                                'Query Stats',
                                                'Most Resource-Intensive Queries',
                                                'http://www.BrentOzar.com/go/topqueries',
                                                'Query stats during the sample:' + @linefeed +
                                                'Executions: ' + CAST(
                                                        qsnow.execution_count - (COALESCE(qsfirst.execution_count, 0)) as nvarchar(100)) +
                                                @linefeed +
                                                'Elapsed Time: ' + CAST(
                                                        qsnow.total_elapsed_time - (COALESCE(qsfirst.total_elapsed_time, 0)) as nvarchar(100)) +
                                                @linefeed +
                                                'CPU Time: ' + CAST(
                                                        qsnow.total_worker_time - (COALESCE(qsfirst.total_worker_time, 0)) as nvarchar(100)) +
                                                @linefeed +
                                                'Logical Reads: ' + CAST(qsnow.total_logical_reads -
                                                                         (COALESCE(qsfirst.total_logical_reads, 0)) as nvarchar(100)) +
                                                @linefeed +
                                                'Logical Writes: ' + CAST(qsnow.total_logical_writes -
                                                                          (COALESCE(qsfirst.total_logical_writes, 0)) as nvarchar(100)) +
                                                @linefeed +
                                                'CLR Time: ' + CAST(
                                                        qsnow.total_clr_time - (COALESCE(qsfirst.total_clr_time, 0)) as nvarchar(100)) +
                                                @linefeed +
                                                @linefeed + @linefeed + 'Query stats since ' +
                                                CONVERT(nvarchar(100), qsnow.creation_time, 121) + @linefeed +
                                                'Executions: ' + CAST(qsnow.execution_count as nvarchar(100)) +
                                                case qstotal.execution_count
                                                    when 0 then ''
                                                    else (' - Percent of Server Total: ' + CAST(CAST(
                                                            100.0 * qsnow.execution_count / qstotal.execution_count as decimal(6, 2)) as nvarchar(100)) +
                                                          '%') end + @linefeed +
                                                'Elapsed Time: ' + CAST(qsnow.total_elapsed_time as nvarchar(100)) +
                                                case qstotal.total_elapsed_time
                                                    when 0 then ''
                                                    else (' - Percent of Server Total: ' + CAST(CAST(
                                                            100.0 * qsnow.total_elapsed_time / qstotal.total_elapsed_time as decimal(6, 2)) as nvarchar(100)) +
                                                          '%') end + @linefeed +
                                                'CPU Time: ' + CAST(qsnow.total_worker_time as nvarchar(100)) +
                                                case qstotal.total_worker_time
                                                    when 0 then ''
                                                    else (' - Percent of Server Total: ' + CAST(CAST(
                                                            100.0 * qsnow.total_worker_time / qstotal.total_worker_time as decimal(6, 2)) as nvarchar(100)) +
                                                          '%') end + @linefeed +
                                                'Logical Reads: ' + CAST(qsnow.total_logical_reads as nvarchar(100)) +
                                                case qstotal.total_logical_reads
                                                    when 0 then ''
                                                    else (' - Percent of Server Total: ' + CAST(CAST(
                                                            100.0 * qsnow.total_logical_reads / qstotal.total_logical_reads as decimal(6, 2)) as nvarchar(100)) +
                                                          '%') end + @linefeed +
                                                'Logical Writes: ' + CAST(qsnow.total_logical_writes as nvarchar(100)) +
                                                case qstotal.total_logical_writes
                                                    when 0 then ''
                                                    else (' - Percent of Server Total: ' + CAST(CAST(
                                                            100.0 * qsnow.total_logical_writes / qstotal.total_logical_writes as decimal(6, 2)) as nvarchar(100)) +
                                                          '%') end + @linefeed +
                                                'CLR Time: ' + CAST(qsnow.total_clr_time as nvarchar(100)) +
                                                case qstotal.total_clr_time
                                                    when 0 then ''
                                                    else (' - Percent of Server Total: ' + CAST(CAST(
                                                            100.0 * qsnow.total_clr_time / qstotal.total_clr_time as decimal(6, 2)) as nvarchar(100)) +
                                                          '%') end + @linefeed +
                                                    --@LineFeed + @LineFeed + 'Query hash: ' + CAST(qsNow.query_hash AS NVARCHAR(100)) + @LineFeed +
                                                    --@LineFeed + @LineFeed + 'Query plan hash: ' + CAST(qsNow.query_plan_hash AS NVARCHAR(100)) +
                                                @linefeed                                                                   as details,
                                                'See the URL for tuning tips on why this query may be consuming resources.' as howtostopit,
                                                qp.query_plan,
                                    querytext = SUBSTRING(st.text,
                                                          (qsnow.statement_start_offset / 2) + 1,
                                                          ((case qsnow.statement_end_offset
                                                                when -1 then DATALENGTH(st.text)
                                                                else qsnow.statement_end_offset
                                                                end - qsnow.statement_start_offset) / 2) + 1),
                                                qsnow.id                                                                    as querystatsnowid,
                                                qsfirst.id                                                                  as querystatsfirstid,
                                                qsnow.plan_handle                                                           as planhandle,
                                                qsnow.query_hash
                                from #querystats qsnow
                                         inner join #querystats qstotal on qstotal.pass = 0
                                         left outer join #querystats qsfirst
                                                         on qsnow.[sql_handle] = qsfirst.[sql_handle] and
                                                            qsnow.statement_start_offset = qsfirst.statement_start_offset and
                                                            qsnow.statement_end_offset = qsfirst.statement_end_offset and
                                                            qsnow.plan_generation_num = qsfirst.plan_generation_num and
                                                            qsnow.plan_handle = qsfirst.plan_handle and qsfirst.pass = 1
                                         cross apply sys.dm_exec_sql_text(qsnow.sql_handle) as st
                                         cross apply sys.dm_exec_query_plan(qsnow.plan_handle) as qp
                                where qsnow.points > 0
                                  and st.text is not null
                                  and qp.query_plan is not null;

                                update #blitzfirstresults
                                set databaseid   = CAST(attr.value as int),
                                    databasename = DB_NAME(CAST(attr.value as int))
                                from #blitzfirstresults
                                         cross apply sys.dm_exec_plan_attributes(#blitzfirstresults.planhandle) as attr
                                where attr.attribute = 'dbid';


                            end; /* IF DATEDIFF(ss, @FinishSampleTime, SYSDATETIMEOFFSET()) > 10 AND @CheckProcedureCache = 1 */


                    raiserror ('Analyzing changes between first and second passes of DMVs',10,1) with nowait;

                    /* Wait Stats - CheckID 6 */
                    /* Compare the current wait stats to the sample we took at the start, and insert the top 10 waits. */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details,
                                                    howtostopit, detailsint)
                    select top 10 6                                                                                 as checkid,
                                  200                                                                               as priority,
                                  'Wait Stats'                                                                      as findinggroup,
                                  wnow.wait_type                                                                    as finding, /* IF YOU CHANGE THIS, STUFF WILL BREAK. Other checks look for wait type names in the Finding field. See checks 11, 12 as example. */
                                  N'https://www.sqlskills.com/help/waits/' + LOWER(wnow.wait_type) + '/'            as url,
                                  'For ' + CAST(
                                          ((wnow.wait_time_ms - COALESCE(wbase.wait_time_ms, 0)) / 1000) as nvarchar(100)) +
                                  ' seconds over the last ' + case @seconds
                                                                  when 0 then (CAST(
                                                                                       DATEDIFF(dd, @startsampletime, @finishsampletime) as nvarchar(10)) +
                                                                               ' days')
                                                                  else (CAST(@seconds as nvarchar(10)) + ' seconds') end +
                                  ', SQL Server was waiting on this particular bottleneck.' + @linefeed +
                                  @linefeed                                                                         as details,
                                  'See the URL for more details on how to mitigate this wait type.'                 as howtostopit,
                                  ((wnow.wait_time_ms - COALESCE(wbase.wait_time_ms, 0)) / 1000)                    as detailsint
                    from #waitstats wnow
                             left outer join #waitstats wbase
                                             on wnow.wait_type = wbase.wait_type and wnow.sampletime > wbase.sampletime
                    where wnow.wait_time_ms > (wbase.wait_time_ms +
                                               (.5 * (DATEDIFF(ss, @startsampletime, @finishsampletime)) * 1000)) /* Only look for things we've actually waited on for half of the time or more */
                    order by (wnow.wait_time_ms - COALESCE(wbase.wait_time_ms, 0)) desc;

                    /* Server Performance - Poison Wait Detected - CheckID 30 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details,
                                                    howtostopit, detailsint)
                    select 30                                                                                as checkid,
                           10                                                                                as priority,
                           'Server Performance'                                                              as findinggroup,
                           'Poison Wait Detected: ' + wnow.wait_type                                         as finding,
                           N'http://www.brentozar.com/go/poison/#' + wnow.wait_type                          as url,
                           'For ' +
                           CAST(((wnow.wait_time_ms - COALESCE(wbase.wait_time_ms, 0)) / 1000) as nvarchar(100)) +
                           ' seconds over the last ' + case @seconds
                                                           when 0 then (CAST(
                                                                                DATEDIFF(dd, @startsampletime, @finishsampletime) as nvarchar(10)) +
                                                                        ' days')
                                                           else (CAST(@seconds as nvarchar(10)) + ' seconds') end +
                           ', SQL Server was waiting on this particular bottleneck.' + @linefeed + @linefeed as details,
                           'See the URL for more details on how to mitigate this wait type.'                 as howtostopit,
                           ((wnow.wait_time_ms - COALESCE(wbase.wait_time_ms, 0)) / 1000)                    as detailsint
                    from #waitstats wnow
                             left outer join #waitstats wbase
                                             on wnow.wait_type = wbase.wait_type and wnow.sampletime > wbase.sampletime
                    where wnow.wait_type in
                          ('IO_QUEUE_LIMIT', 'IO_RETRY', 'LOG_RATE_GOVERNOR', 'POOL_LOG_RATE_GOVERNOR',
                           'PREEMPTIVE_DEBUG', 'RESMGR_THROTTLED', 'RESOURCE_SEMAPHORE',
                           'RESOURCE_SEMAPHORE_QUERY_COMPILE', 'SE_REPL_CATCHUP_THROTTLE', 'SE_REPL_COMMIT_ACK',
                           'SE_REPL_COMMIT_TURN', 'SE_REPL_ROLLBACK_ACK', 'SE_REPL_SLOW_SECONDARY_THROTTLE',
                           'THREADPOOL')
                      and wnow.wait_time_ms > (wbase.wait_time_ms + 1000);


                    /* Server Performance - Slow Data File Reads - CheckID 11 */
                    if EXISTS(select * from #blitzfirstresults where finding like 'PAGEIOLATCH%')
                        begin
                            insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details,
                                                            howtostopit, databaseid, databasename)
                            select top 10 11                                                                as checkid,
                                          50                                                                as priority,
                                          'Server Performance'                                              as findinggroup,
                                          'Slow Data File Reads'                                            as finding,
                                          'http://www.BrentOzar.com/go/slow/'                               as url,
                                          'Your server is experiencing PAGEIOLATCH% waits due to slow data file reads. This file is one of the reasons why.' +
                                          @linefeed
                                              + 'File: ' + fnow.physicalname + @linefeed
                                              + 'Number of reads during the sample: ' +
                                          CAST((fnow.num_of_reads - fbase.num_of_reads) as nvarchar(20)) + @linefeed
                                              + 'Seconds spent waiting on storage for these reads: ' + CAST(
                                                  ((fnow.io_stall_read_ms - fbase.io_stall_read_ms) / 1000.0) as nvarchar(20)) +
                                          @linefeed
                                              + 'Average read latency during the sample: ' + CAST(
                                                  ((fnow.io_stall_read_ms - fbase.io_stall_read_ms) /
                                                   (fnow.num_of_reads - fbase.num_of_reads)) as nvarchar(20)) +
                                          ' milliseconds' + @linefeed
                                              + 'Microsoft guidance for data file read speed: 20ms or less.' +
                                          @linefeed + @linefeed                                             as details,
                                          'See the URL for more details on how to mitigate this wait type.' as howtostopit,
                                          fnow.databaseid,
                                          fnow.databasename
                            from #filestats fnow
                                     inner join #filestats fbase
                                                on fnow.databaseid = fbase.databaseid and fnow.fileid = fbase.fileid and
                                                   fnow.sampletime > fbase.sampletime and
                                                   fnow.num_of_reads > fbase.num_of_reads and
                                                   fnow.io_stall_read_ms > (fbase.io_stall_read_ms + 1000)
                            where (fnow.io_stall_read_ms - fbase.io_stall_read_ms) /
                                  (fnow.num_of_reads - fbase.num_of_reads) >= @filelatencythresholdms
                              and fnow.typedesc = 'ROWS'
                            order by (fnow.io_stall_read_ms - fbase.io_stall_read_ms) /
                                     (fnow.num_of_reads - fbase.num_of_reads) desc;
                        end;

                    /* Server Performance - Slow Log File Writes - CheckID 12 */
                    if EXISTS(select * from #blitzfirstresults where finding like 'WRITELOG%')
                        begin
                            insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details,
                                                            howtostopit, databaseid, databasename)
                            select top 10 12                                                                as checkid,
                                          50                                                                as priority,
                                          'Server Performance'                                              as findinggroup,
                                          'Slow Log File Writes'                                            as finding,
                                          'http://www.BrentOzar.com/go/slow/'                               as url,
                                          'Your server is experiencing WRITELOG waits due to slow log file writes. This file is one of the reasons why.' +
                                          @linefeed
                                              + 'File: ' + fnow.physicalname + @linefeed
                                              + 'Number of writes during the sample: ' +
                                          CAST((fnow.num_of_writes - fbase.num_of_writes) as nvarchar(20)) + @linefeed
                                              + 'Seconds spent waiting on storage for these writes: ' + CAST(
                                                  ((fnow.io_stall_write_ms - fbase.io_stall_write_ms) / 1000.0) as nvarchar(20)) +
                                          @linefeed
                                              + 'Average write latency during the sample: ' + CAST(
                                                  ((fnow.io_stall_write_ms - fbase.io_stall_write_ms) /
                                                   (fnow.num_of_writes - fbase.num_of_writes)) as nvarchar(20)) +
                                          ' milliseconds' + @linefeed
                                              + 'Microsoft guidance for log file write speed: 3ms or less.' +
                                          @linefeed + @linefeed                                             as details,
                                          'See the URL for more details on how to mitigate this wait type.' as howtostopit,
                                          fnow.databaseid,
                                          fnow.databasename
                            from #filestats fnow
                                     inner join #filestats fbase
                                                on fnow.databaseid = fbase.databaseid and fnow.fileid = fbase.fileid and
                                                   fnow.sampletime > fbase.sampletime and
                                                   fnow.num_of_writes > fbase.num_of_writes and
                                                   fnow.io_stall_write_ms > (fbase.io_stall_write_ms + 1000)
                            where (fnow.io_stall_write_ms - fbase.io_stall_write_ms) /
                                  (fnow.num_of_writes - fbase.num_of_writes) >= @filelatencythresholdms
                              and fnow.typedesc = 'LOG'
                            order by (fnow.io_stall_write_ms - fbase.io_stall_write_ms) /
                                     (fnow.num_of_writes - fbase.num_of_writes) desc;
                        end;


                    /* SQL Server Internal Maintenance - Log File Growing - CheckID 13 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                    select 13                                                                                                                                       as checkid,
                           1                                                                                                                                        as priority,
                           'SQL Server Internal Maintenance'                                                                                                        as findinggroup,
                           'Log File Growing'                                                                                                                       as finding,
                           'http://www.BrentOzar.com/askbrent/file-growing/'                                                                                        as url,
                           'Number of growths during the sample: ' + CAST(ps.value_delta as nvarchar(20)) + @linefeed
                               + 'Determined by sampling Perfmon counter ' + ps.object_name + ' - ' + ps.counter_name +
                           @linefeed                                                                                                                                as details,
                           'Pre-grow data and log files during maintenance windows so that they do not grow during production loads. See the URL for more details.' as howtostopit
                    from #perfmonstats ps
                    where ps.pass = 2
                      and object_name = @servicename + ':Databases'
                      and counter_name = 'Log Growths'
                      and value_delta > 0;


                    /* SQL Server Internal Maintenance - Log File Shrinking - CheckID 14 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                    select 14                                                                                                                                       as checkid,
                           1                                                                                                                                        as priority,
                           'SQL Server Internal Maintenance'                                                                                                        as findinggroup,
                           'Log File Shrinking'                                                                                                                     as finding,
                           'http://www.BrentOzar.com/askbrent/file-shrinking/'                                                                                      as url,
                           'Number of shrinks during the sample: ' + CAST(ps.value_delta as nvarchar(20)) + @linefeed
                               + 'Determined by sampling Perfmon counter ' + ps.object_name + ' - ' + ps.counter_name +
                           @linefeed                                                                                                                                as details,
                           'Pre-grow data and log files during maintenance windows so that they do not grow during production loads. See the URL for more details.' as howtostopit
                    from #perfmonstats ps
                    where ps.pass = 2
                      and object_name = @servicename + ':Databases'
                      and counter_name = 'Log Shrinks'
                      and value_delta > 0;

                    /* Query Problems - Compilations/Sec High - CheckID 15 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                    select 15                                                                                                                                   as checkid,
                           50                                                                                                                                   as priority,
                           'Query Problems'                                                                                                                     as findinggroup,
                           'Compilations/Sec High'                                                                                                              as finding,
                           'http://www.BrentOzar.com/askbrent/compilations/'                                                                                    as url,
                           'Number of batch requests during the sample: ' + CAST(ps.value_delta as nvarchar(20)) +
                           @linefeed
                               + 'Number of compilations during the sample: ' +
                           CAST(pscomp.value_delta as nvarchar(20)) + @linefeed
                               +
                           'For OLTP environments, Microsoft recommends that 90% of batch requests should hit the plan cache, and not be compiled from scratch. We are exceeding that threshold.' +
                           @linefeed                                                                                                                            as details,
                           'To find the queries that are compiling, start with:' + @linefeed
                               + 'sp_BlitzCache @SortOrder = ''recent compilations''' + @linefeed
                               +
                           'If dynamic SQL or non-parameterized strings are involved, consider enabling Forced Parameterization. See the URL for more details.' as howtostopit
                    from #perfmonstats ps
                             inner join #perfmonstats pscomp
                                        on pscomp.pass = 2 and pscomp.object_name = @servicename + ':SQL Statistics' and
                                           pscomp.counter_name = 'SQL Compilations/sec' and pscomp.value_delta > 0
                    where ps.pass = 2
                      and ps.object_name = @servicename + ':SQL Statistics'
                      and ps.counter_name = 'Batch Requests/sec'
                      and ps.value_delta > (1000 * @seconds) /* Ignore servers sitting idle */
                      and (pscomp.value_delta * 10) > ps.value_delta;
                    /* Compilations are more than 10% of batch requests per second */

                    /* Query Problems - Re-Compilations/Sec High - CheckID 16 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                    select 16                                                                                                                                              as checkid,
                           50                                                                                                                                              as priority,
                           'Query Problems'                                                                                                                                as findinggroup,
                           'Re-Compilations/Sec High'                                                                                                                      as finding,
                           'http://www.BrentOzar.com/askbrent/recompilations/'                                                                                             as url,
                           'Number of batch requests during the sample: ' + CAST(ps.value_delta as nvarchar(20)) +
                           @linefeed
                               + 'Number of recompilations during the sample: ' +
                           CAST(pscomp.value_delta as nvarchar(20)) + @linefeed
                               +
                           'More than 10% of our queries are being recompiled. This is typically due to statistics changing on objects.' +
                           @linefeed                                                                                                                                       as details,
                           'To find the queries that are being forced to recompile, start with:' + @linefeed
                               + 'sp_BlitzCache @SortOrder = ''recent compilations''' + @linefeed
                               +
                           'Examine those plans to find out which objects are changing so quickly that they hit the stats update threshold. See the URL for more details.' as howtostopit
                    from #perfmonstats ps
                             inner join #perfmonstats pscomp
                                        on pscomp.pass = 2 and pscomp.object_name = @servicename + ':SQL Statistics' and
                                           pscomp.counter_name = 'SQL Re-Compilations/sec' and pscomp.value_delta > 0
                    where ps.pass = 2
                      and ps.object_name = @servicename + ':SQL Statistics'
                      and ps.counter_name = 'Batch Requests/sec'
                      and ps.value_delta > (1000 * @seconds) /* Ignore servers sitting idle */
                      and (pscomp.value_delta * 10) > ps.value_delta;
                    /* Recompilations are more than 10% of batch requests per second */

                    /* Table Problems - Forwarded Fetches/Sec High - CheckID 29 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                    select 29                                                                                                                                                                           as checkid,
                           40                                                                                                                                                                           as priority,
                           'Table Problems'                                                                                                                                                             as findinggroup,
                           'Forwarded Fetches/Sec High'                                                                                                                                                 as finding,
                           'https://BrentOzar.com/go/fetch/'                                                                                                                                            as url,
                           CAST(ps.value_delta as nvarchar(20)) +
                           ' Forwarded Records (from SQLServer:Access Methods counter)' + @linefeed
                               + 'Check your heaps: they need to be rebuilt, or they need a clustered index applied.' +
                           @linefeed                                                                                                                                                                    as details,
                           'Rebuild your heaps. If you use Ola Hallengren maintenance scripts, those do not rebuild heaps by default: https://www.brentozar.com/archive/2016/07/fix-forwarded-records/' as howtostopit
                    from #perfmonstats ps
                             inner join #perfmonstats pscomp
                                        on pscomp.pass = 2 and pscomp.object_name = @servicename + ':Access Methods' and
                                           pscomp.counter_name = 'Forwarded Records/sec' and pscomp.value_delta > 100
                    where ps.pass = 2
                      and ps.object_name = @servicename + ':Access Methods'
                      and ps.counter_name = 'Forwarded Records/sec'
                      and ps.value_delta > (100 * @seconds);
                    /* Ignore servers sitting idle */

                    /* Check for temp objects with high forwarded fetches.
		This has to be done as dynamic SQL because we have to execute OBJECT_NAME inside TempDB. */
                    if @@ROWCOUNT > 0
                        begin
                            set @stringtoexecute = N'USE tempdb;
		INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt)
		SELECT TOP 10 29 AS CheckID,
			40 AS Priority,
			''Table Problems'' AS FindingGroup,
			''Forwarded Fetches/Sec High: Temp Table'' AS Finding,
			''https://BrentOzar.com/go/fetch/'' AS URL,
			CAST(COALESCE(os.forwarded_fetch_count,0) AS NVARCHAR(20)) + '' forwarded fetches on temp table '' + COALESCE(OBJECT_NAME(os.object_id), ''Unknown'') AS Details,
			''Look through your source code to find the object creating these temp tables, and tune the creation and population to reduce fetches. See the URL for details.'' AS HowToStopIt
		FROM tempdb.sys.dm_db_index_operational_stats(DB_ID(''tempdb''), NULL, NULL, NULL) os
		WHERE os.database_id = DB_ID(''tempdb'')
			AND os.forwarded_fetch_count > 100
		ORDER BY os.forwarded_fetch_count DESC;'

                            execute sp_executesql @stringtoexecute;
                        end

                    /* In-Memory OLTP - Garbage Collection in Progress - CheckID 31 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                    select 31                                                                                                                                                                                               as checkid,
                           50                                                                                                                                                                                               as priority,
                           'In-Memory OLTP'                                                                                                                                                                                 as findinggroup,
                           'Garbage Collection in Progress'                                                                                                                                                                 as finding,
                           'https://BrentOzar.com/go/garbage/'                                                                                                                                                              as url,
                           CAST(ps.value_delta as nvarchar(50)) +
                           ' rows processed (from SQL Server YYYY XTP Garbage Collection:Rows processed/sec counter)' +
                           @linefeed
                               +
                           'This can happen due to memory pressure (causing In-Memory OLTP to shrink its footprint) or' +
                           @linefeed
                               +
                           'due to transactional workloads that constantly insert/delete data.'                                                                                                                             as details,
                           'Sadly, you cannot choose when garbage collection occurs. This is one of the many gotchas of Hekaton. Learn more: http://nedotter.com/archive/2016/04/row-version-lifecycle-for-in-memory-oltp/' as howtostopit
                    from #perfmonstats ps
                             inner join #perfmonstats pscomp
                                        on pscomp.pass = 2 and pscomp.object_name like '%XTP Garbage Collection' and
                                           pscomp.counter_name = 'Rows processed/sec' and pscomp.value_delta > 100
                    where ps.pass = 2
                      and ps.object_name like '%XTP Garbage Collection'
                      and ps.counter_name = 'Rows processed/sec'
                      and ps.value_delta > (100 * @seconds);
                    /* Ignore servers sitting idle */

                    /* In-Memory OLTP - Transactions Aborted - CheckID 32 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                    select 32                                                                                                                as checkid,
                           100                                                                                                               as priority,
                           'In-Memory OLTP'                                                                                                  as findinggroup,
                           'Transactions Aborted'                                                                                            as finding,
                           'https://BrentOzar.com/go/aborted/'                                                                               as url,
                           CAST(ps.value_delta as nvarchar(50)) +
                           ' transactions aborted (from SQL Server YYYY XTP Transactions:Transactions aborted/sec counter)' +
                           @linefeed
                               +
                           'This may indicate that data is changing, or causing folks to retry their transactions, thereby increasing load.' as details,
                           'Dig into your In-Memory OLTP transactions to figure out which ones are failing and being retried.'               as howtostopit
                    from #perfmonstats ps
                             inner join #perfmonstats pscomp
                                        on pscomp.pass = 2 and pscomp.object_name like '%XTP Transactions' and
                                           pscomp.counter_name = 'Transactions aborted/sec' and pscomp.value_delta > 100
                    where ps.pass = 2
                      and ps.object_name like '%XTP Transactions'
                      and ps.counter_name = 'Transactions aborted/sec'
                      and ps.value_delta > (10 * @seconds);
                    /* Ignore servers sitting idle */

                    /* Query Problems - Suboptimal Plans/Sec High - CheckID 33 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                    select 32                                                                                                                           as checkid,
                           100                                                                                                                          as priority,
                           'Query Problems'                                                                                                             as findinggroup,
                           'Suboptimal Plans/Sec High'                                                                                                  as finding,
                           'https://BrentOzar.com/go/suboptimal/'                                                                                       as url,
                           CAST(ps.value_delta as nvarchar(50)) + ' plans reported in the ' +
                           CAST(ps.instance_name as nvarchar(100)) +
                           ' workload group (from Workload GroupStats:Suboptimal plans/sec counter)' + @linefeed
                               +
                           'Even if you are not using Resource Governor, it still tracks information about user queries, memory grants, etc.'           as details,
                           'Check out sp_BlitzCache to get more information about recent queries, or try sp_BlitzWho to see currently running queries.' as howtostopit
                    from #perfmonstats ps
                             inner join #perfmonstats pscomp on pscomp.pass = 2 and
                                                                pscomp.object_name = @servicename + ':Workload GroupStats' and
                                                                pscomp.counter_name = 'Suboptimal plans/sec' and
                                                                pscomp.value_delta > 100
                    where ps.pass = 2
                      and ps.object_name = @servicename + ':Workload GroupStats'
                      and ps.counter_name = 'Suboptimal plans/sec'
                      and ps.value_delta > (10 * @seconds);
                    /* Ignore servers sitting idle */

                    /* Azure Performance - Database is Maxed Out - CheckID 41 */
                    if SERVERPROPERTY('Edition') = 'SQL Azure'
                        insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, howtostopit)
                        select 41                                                                                                               as checkid,
                               10                                                                                                               as priority,
                               'Azure Performance'                                                                                              as findinggroup,
                               'Database is Maxed Out'                                                                                          as finding,
                               'https://BrentOzar.com/go/maxedout'                                                                              as url,
                               N'At ' + CONVERT(nvarchar(100), s.end_time, 121) +
                               N', your database approached (or hit) your DTU limits:' + @linefeed
                                   + N'Average CPU percent: ' + CAST(avg_cpu_percent as nvarchar(50)) + @linefeed
                                   + N'Average data IO percent: ' + CAST(avg_data_io_percent as nvarchar(50)) +
                               @linefeed
                                   + N'Average log write percent: ' + CAST(avg_log_write_percent as nvarchar(50)) +
                               @linefeed
                                   + N'Max worker percent: ' + CAST(max_worker_percent as nvarchar(50)) + @linefeed
                                   + N'Max session percent: ' +
                               CAST(max_session_percent as nvarchar(50))                                                                        as details,
                               'Tune your queries or indexes with sp_BlitzCache or sp_BlitzIndex, or consider upgrading to a higher DTU level.' as howtostopit
                        from sys.dm_db_resource_stats s
                        where s.end_time >= DATEADD(mi, -5, GETDATE())
                          and (avg_cpu_percent > 90
                            or avg_data_io_percent >= 90
                            or avg_log_write_percent >= 90
                            or max_worker_percent >= 90
                            or max_session_percent >= 90);

                    /* Server Info - Batch Requests per Sec - CheckID 19 */
                    insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, detailsint)
                    select 19                                                                  as checkid,
                           250                                                                 as priority,
                           'Server Info'                                                       as findinggroup,
                           'Batch Requests per Sec'                                            as finding,
                           'http://www.BrentOzar.com/go/measure'                               as url,
                           CAST(CAST(ps.value_delta as money) /
                                (DATEDIFF(ss, ps1.sampletime, ps.sampletime)) as nvarchar(20)) as details,
                           ps.value_delta / (DATEDIFF(ss, ps1.sampletime, ps.sampletime))      as detailsint
                    from #perfmonstats ps
                             inner join #perfmonstats ps1
                                        on ps.object_name = ps1.object_name and ps.counter_name = ps1.counter_name and
                                           ps1.pass = 1
                    where ps.pass = 2
                      and ps.object_name = @servicename + ':SQL Statistics'
                      and ps.counter_name = 'Batch Requests/sec';


                    insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                    values (@servicename + ':SQL Statistics', 'SQL Compilations/sec', null);
                    insert into #perfmoncounters ([object_name], [counter_name], [instance_name])
                    values (@servicename + ':SQL Statistics', 'SQL Re-Compilations/sec', null);

                    /* Server Info - SQL Compilations/sec - CheckID 25 */
                    if @expertmode = 1
                        insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, detailsint)
                        select 25 as                                                                                      checkid,
                               250 as                                                                                     priority,
                               'Server Info' as                                                                           findinggroup,
                               'SQL Compilations per Sec' as                                                              finding,
                               'http://www.BrentOzar.com/go/measure' as                                                   url,
                               CAST(
                                       ps.value_delta / (DATEDIFF(ss, ps1.sampletime, ps.sampletime)) as nvarchar(20)) as details,
                               ps.value_delta / (DATEDIFF(ss, ps1.sampletime, ps.sampletime)) as                          detailsint
                        from #perfmonstats ps
                                 inner join #perfmonstats ps1 on ps.object_name = ps1.object_name and
                                                                 ps.counter_name = ps1.counter_name and ps1.pass = 1
                        where ps.pass = 2
                          and ps.object_name = @servicename + ':SQL Statistics'
                          and ps.counter_name = 'SQL Compilations/sec';

                    /* Server Info - SQL Re-Compilations/sec - CheckID 26 */
                    if @expertmode = 1
                        insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, detailsint)
                        select 26 as                                                                                      checkid,
                               250 as                                                                                     priority,
                               'Server Info' as                                                                           findinggroup,
                               'SQL Re-Compilations per Sec' as                                                           finding,
                               'http://www.BrentOzar.com/go/measure' as                                                   url,
                               CAST(
                                       ps.value_delta / (DATEDIFF(ss, ps1.sampletime, ps.sampletime)) as nvarchar(20)) as details,
                               ps.value_delta / (DATEDIFF(ss, ps1.sampletime, ps.sampletime)) as                          detailsint
                        from #perfmonstats ps
                                 inner join #perfmonstats ps1 on ps.object_name = ps1.object_name and
                                                                 ps.counter_name = ps1.counter_name and ps1.pass = 1
                        where ps.pass = 2
                          and ps.object_name = @servicename + ':SQL Statistics'
                          and ps.counter_name = 'SQL Re-Compilations/sec';

                    /* Server Info - Wait Time per Core per Sec - CheckID 20 */
                    if @seconds > 0
                        begin
                            ;
                            with waits1(sampletime, waits_ms) as (select sampletime, SUM(ws1.wait_time_ms)
                                                                  from #waitstats ws1
                                                                  where ws1.pass = 1
                                                                  group by sampletime),
                                 waits2(sampletime, waits_ms) as (select sampletime, SUM(ws2.wait_time_ms)
                                                                  from #waitstats ws2
                                                                  where ws2.pass = 2
                                                                  group by sampletime),
                                 cores(cpu_count) as (select SUM(1)
                                                      from sys.dm_os_schedulers
                                                      where status = 'VISIBLE ONLINE' and is_online = 1)
                            insert
                            into #blitzfirstresults (checkid, priority, findingsgroup, finding, url, details, detailsint)
                            select 20                                                                       as checkid,
                                   250                                                                      as priority,
                                   'Server Info'                                                            as findinggroup,
                                   'Wait Time per Core per Sec'                                             as finding,
                                   'http://www.BrentOzar.com/go/measure'                                    as url,
                                   CAST((CAST(waits2.waits_ms - waits1.waits_ms as money)) / 1000 / i.cpu_count /
                                        DATEDIFF(ss, waits1.sampletime, waits2.sampletime) as nvarchar(20)) as details,
                                   (waits2.waits_ms - waits1.waits_ms) / 1000 / i.cpu_count /
                                   DATEDIFF(ss, waits1.sampletime, waits2.sampletime)                       as detailsint
                            from cores i
                                     cross join waits1
                                     cross join waits2;
                        end;

                    /* Server Performance - High CPU Utilization CheckID 24 */
                    if @seconds >= 30
                        begin
                            /* If we're waiting 30+ seconds, run this check at the end.
           We get this data from the ring buffers, and it's only updated once per minute, so might
           as well get it now - whereas if we're checking 30+ seconds, it might get updated by the
           end of our sp_BlitzFirst session. */
                            insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, details, detailsint, url)
                            select 24,
                                   50,
                                   'Server Performance',
                                   'High CPU Utilization',
                                   CAST(100 - systemidle as nvarchar(20)) + N'%. Ring buffer details: ' +
                                   CAST(record as nvarchar(4000)),
                                   100 - systemidle,
                                   'http://www.BrentOzar.com/go/cpu'
                            from (
                                     select record,
                                            record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]',
                                                         'int') as systemidle
                                     from (
                                              select top 1 CONVERT(xml, record) as record
                                              from sys.dm_os_ring_buffers
                                              where ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'
                                                and record like '%<SystemHealth>%'
                                              order by timestamp desc) as rb
                                 ) as y
                            where 100 - systemidle >= 50;

                            insert into #blitzfirstresults (checkid, priority, findingsgroup, finding, details, detailsint, url)
                            select 23,
                                   250,
                                   'Server Info',
                                   'CPU Utilization',
                                   CAST(100 - systemidle as nvarchar(20)) + N'%. Ring buffer details: ' +
                                   CAST(record as nvarchar(4000)),
                                   100 - systemidle,
                                   'http://www.BrentOzar.com/go/cpu'
                            from (
                                     select record,
                                            record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]',
                                                         'int') as systemidle
                                     from (
                                              select top 1 CONVERT(xml, record) as record
                                              from sys.dm_os_ring_buffers
                                              where ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'
                                                and record like '%<SystemHealth>%'
                                              order by timestamp desc) as rb
                                 ) as y;

                        end;
                    /* IF @Seconds >= 30 */


                    /* If we didn't find anything, apologize. */
                    if not EXISTS(select * from #blitzfirstresults where priority < 250)
                        begin

                            insert into #blitzfirstresults
                            (checkid,
                             priority,
                             findingsgroup,
                             finding,
                             url,
                             details)
                            values (-1,
                                    1,
                                    'No Problems Found',
                                    'From Your Community Volunteers',
                                    'http://FirstResponderKit.org/',
                                    'Try running our more in-depth checks with sp_Blitz, or there may not be an unusual SQL Server performance problem. ');

                        end;
                    /*IF NOT EXISTS (SELECT * FROM #BlitzFirstResults) */

                    /* Add credits for the nice folks who put so much time into building and maintaining this for free: */
                    insert into #blitzfirstresults
                    (checkid,
                     priority,
                     findingsgroup,
                     finding,
                     url,
                     details)
                    values (-1,
                            255,
                            'Thanks!',
                            'From Your Community Volunteers',
                            'http://FirstResponderKit.org/',
                            'To get help or add your own contributions, join us at http://FirstResponderKit.org.');

                    insert into #blitzfirstresults
                    (checkid,
                     priority,
                     findingsgroup,
                     finding,
                     url,
                     details)
                    values (-1,
                            0,
                            'sp_BlitzFirst ' + CAST(CONVERT(datetimeoffset, @versiondate, 102) as varchar(100)),
                            'From Your Community Volunteers',
                            'http://FirstResponderKit.org/',
                            'We hope you found this tool useful.');

                    /* Outdated sp_BlitzFirst - sp_BlitzFirst is Over 6 Months Old */
                    if DATEDIFF(mm, @versiondate, SYSDATETIMEOFFSET()) > 6
                        begin
                            insert into #blitzfirstresults
                            (checkid,
                             priority,
                             findingsgroup,
                             finding,
                             url,
                             details)
                            select 27                                                                                                                                                         as checkid,
                                   0                                                                                                                                                          as priority,
                                   'Outdated sp_BlitzFirst'                                                                                                                                   as findingsgroup,
                                   'sp_BlitzFirst is Over 6 Months Old'                                                                                                                       as finding,
                                   'http://FirstResponderKit.org/'                                                                                                                            as url,
                                   'Some things get better with age, like fine wine and your T-SQL. However, sp_BlitzFirst is not one of those things - time to go download the current one.' as details;
                        end;

                    if @checkserverinfo = 0 /* Github #1680 */
                        begin
                            delete #blitzfirstresults
                            where findingsgroup = 'Server Info';
                        end

                    raiserror ('Analysis finished, outputting results',10,1) with nowait;


                    /* If they want to run sp_BlitzCache and export to table, go for it. */
                    if @outputtablenameblitzcache is not null
                        and @outputdatabasename is not null
                        and @outputschemaname is not null
                        and EXISTS(select *
                                   from sys.databases
                                   where QUOTENAME([name]) = @outputdatabasename)
                        begin


                            raiserror ('Calling sp_BlitzCache',10,1) with nowait;


                            /* If they have an newer version of sp_BlitzCache that supports @MinutesBack and @CheckDateOverride */
                            if EXISTS(select *
                                      from sys.objects o
                                               inner join sys.parameters pmb
                                                          on o.object_id = pmb.object_id and pmb.name = '@MinutesBack'
                                               inner join sys.parameters pcdo
                                                          on o.object_id = pcdo.object_id and pcdo.name = '@CheckDateOverride'
                                      where o.name = 'sp_BlitzCache')
                                begin
                                    /* Get the most recent sp_BlitzCache execution before this one - don't use sp_BlitzFirst because user logs are added in there at any time */
                                    set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                                        + @outputdatabasename
                                        + '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
                                        + @outputschemaname + ''' AND QUOTENAME(TABLE_NAME) = '''
                                        + QUOTENAME(@outputtablenameblitzcache) +
                                                           ''') SELECT TOP 1 @BlitzCacheMinutesBack = DATEDIFF(MI,CheckDate,SYSDATETIMEOFFSET()) FROM '
                                        + @outputdatabasename + '.'
                                        + @outputschemaname + '.'
                                        + QUOTENAME(@outputtablenameblitzcache)
                                        + ' WHERE ServerName = ''' +
                                                           CAST(SERVERPROPERTY('ServerName') as nvarchar(128)) +
                                                           ''' ORDER BY CheckDate DESC;';
                                    exec sp_executesql @stringtoexecute, N'@BlitzCacheMinutesBack INT OUTPUT',
                                         @blitzcacheminutesback output;

                                    /* If there's no data, let's just analyze the last 15 minutes of the plan cache */
                                    if @blitzcacheminutesback is null or @blitzcacheminutesback < 1 or
                                       @blitzcacheminutesback > 60
                                        set @blitzcacheminutesback = 15;

                                    exec sp_BlitzCache
                                         @outputdatabasename = @unquotedoutputdatabasename,
                                         @outputschemaname = @unquotedoutputschemaname,
                                         @outputtablename = @outputtablenameblitzcache,
                                         @checkdateoverride = @startsampletime,
                                         @sortorder = 'all',
                                         @skipanalysis = @blitzcacheskipanalysis,
                                         @minutesback = @blitzcacheminutesback,
                                         @debug = @debug;

                                    /* Delete history older than @OutputTableRetentionDays */
                                    set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                                        + @outputdatabasename
                                        + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                        + @outputschemaname + ''') DELETE '
                                        + @outputdatabasename + '.'
                                        + @outputschemaname + '.'
                                        + QUOTENAME(@outputtablenameblitzcache)
                                        + ' WHERE ServerName = @SrvName AND CheckDate < @CheckDate;';
                                    exec sp_executesql @stringtoexecute,
                                         N'@SrvName NVARCHAR(128), @CheckDate date',
                                         @localservername, @outputtablecleanupdate;


                                end;

                            else /* No sp_BlitzCache found, or it's outdated */
                                begin
                                    insert into #blitzfirstresults
                                    (checkid,
                                     priority,
                                     findingsgroup,
                                     finding,
                                     url,
                                     details)
                                    select 36                                                                                                                          as checkid,
                                           0                                                                                                                           as priority,
                                           'Outdated or Missing sp_BlitzCache'                                                                                         as findingsgroup,
                                           'Update Your sp_BlitzCache'                                                                                                 as finding,
                                           'http://FirstResponderKit.org/'                                                                                             as url,
                                           'You passed in @OutputTableNameBlitzCache, but we need a newer version of sp_BlitzCache in master or the current database.' as details;
                                end;

                            raiserror ('sp_BlitzCache Finished',10,1) with nowait;

                        end;
                    /* End running sp_BlitzCache */

                    /* @OutputTableName lets us export the results to a permanent table */
                    if @outputdatabasename is not null
                        and @outputschemaname is not null
                        and @outputtablename is not null
                        and @outputtablename not like '#%'
                        and EXISTS(select *
                                   from sys.databases
                                   where QUOTENAME([name]) = @outputdatabasename)
                        begin
                            set @stringtoexecute = 'USE '
                                + @outputdatabasename
                                + '; IF EXISTS(SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                + @outputschemaname
                                + ''') AND NOT EXISTS (SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
                                + @outputschemaname + ''' AND QUOTENAME(TABLE_NAME) = '''
                                + @outputtablename + ''') CREATE TABLE '
                                + @outputschemaname + '.'
                                + @outputtablename
                                + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                CheckID INT NOT NULL,
                Priority TINYINT NOT NULL,
                FindingsGroup VARCHAR(50) NOT NULL,
                Finding VARCHAR(200) NOT NULL,
                URL VARCHAR(200) NOT NULL,
                Details NVARCHAR(4000) NULL,
                HowToStopIt [XML] NULL,
                QueryPlan [XML] NULL,
                QueryText NVARCHAR(MAX) NULL,
                StartTime DATETIMEOFFSET NULL,
                LoginName NVARCHAR(128) NULL,
                NTUserName NVARCHAR(128) NULL,
                OriginalLoginName NVARCHAR(128) NULL,
                ProgramName NVARCHAR(128) NULL,
                HostName NVARCHAR(128) NULL,
                DatabaseID INT NULL,
                DatabaseName NVARCHAR(128) NULL,
                OpenTransactionCount INT NULL,
                DetailsInt INT NULL,
                QueryHash BINARY(8) NULL,
                JoinKey AS ServerName + CAST(CheckDate AS NVARCHAR(50)),
                PRIMARY KEY CLUSTERED (ID ASC));';

                            exec (@stringtoexecute);

                            /* If the table doesn't have the new QueryHash column, add it. See Github #2162. */
                            set @objectfullname =
                                    @outputdatabasename + N'.' + @outputschemaname + N'.' + @outputtablename;
                            set @stringtoexecute = N'IF NOT EXISTS (SELECT * FROM ' + @outputdatabasename + N'.sys.all_columns
            WHERE object_id = (OBJECT_ID(''' + @objectfullname + N''')) AND name = ''QueryHash'')
            ALTER TABLE ' + @objectfullname + N' ADD QueryHash BINARY(8) NULL;';
                            exec (@stringtoexecute);

                            /* If the table doesn't have the new JoinKey computed column, add it. See Github #2164. */
                            set @objectfullname =
                                    @outputdatabasename + N'.' + @outputschemaname + N'.' + @outputtablename;
                            set @stringtoexecute = N'IF NOT EXISTS (SELECT * FROM ' + @outputdatabasename + N'.sys.all_columns
            WHERE object_id = (OBJECT_ID(''' + @objectfullname + N''')) AND name = ''JoinKey'')
            ALTER TABLE ' + @objectfullname + N' ADD JoinKey AS ServerName + CAST(CheckDate AS NVARCHAR(50));';
                            exec (@stringtoexecute);

                            set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                + @outputschemaname + ''') INSERT '
                                + @outputdatabasename + '.'
                                + @outputschemaname + '.'
                                + @outputtablename
                                +
                                                   ' (ServerName, CheckDate, CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, QueryText, StartTime, LoginName, NTUserName, OriginalLoginName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount, DetailsInt, QueryHash) SELECT '
                                +
                                                   ' @SrvName, @CheckDate, CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, QueryText, StartTime, LoginName, NTUserName, OriginalLoginName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount, DetailsInt, QueryHash FROM #BlitzFirstResults ORDER BY Priority , FindingsGroup , Finding , Details';

                            exec sp_executesql @stringtoexecute,
                                 N'@SrvName NVARCHAR(128), @CheckDate datetimeoffset',
                                 @localservername, @startsampletime;

                            /* Delete history older than @OutputTableRetentionDays */
                            set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                + @outputschemaname + ''') DELETE '
                                + @outputdatabasename + '.'
                                + @outputschemaname + '.'
                                + @outputtablename
                                + ' WHERE ServerName = @SrvName AND CheckDate < @CheckDate ;';

                            exec sp_executesql @stringtoexecute,
                                 N'@SrvName NVARCHAR(128), @CheckDate date',
                                 @localservername, @outputtablecleanupdate;

                        end;
                    else
                        if (SUBSTRING(@outputtablename, 2, 2) = '##')
                            begin
                                set @stringtoexecute = N' IF (OBJECT_ID(''tempdb..'
                                    + @outputtablename
                                    + ''') IS NULL) CREATE TABLE '
                                    + @outputtablename
                                    + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                CheckID INT NOT NULL,
                Priority TINYINT NOT NULL,
                FindingsGroup VARCHAR(50) NOT NULL,
                Finding VARCHAR(200) NOT NULL,
                URL VARCHAR(200) NOT NULL,
                Details NVARCHAR(4000) NULL,
                HowToStopIt [XML] NULL,
                QueryPlan [XML] NULL,
                QueryText NVARCHAR(MAX) NULL,
                StartTime DATETIMEOFFSET NULL,
                LoginName NVARCHAR(128) NULL,
                NTUserName NVARCHAR(128) NULL,
                OriginalLoginName NVARCHAR(128) NULL,
                ProgramName NVARCHAR(128) NULL,
                HostName NVARCHAR(128) NULL,
                DatabaseID INT NULL,
                DatabaseName NVARCHAR(128) NULL,
                OpenTransactionCount INT NULL,
                DetailsInt INT NULL,
                QueryHash BINARY(8) NULL,
                JoinKey AS ServerName + CAST(CheckDate AS NVARCHAR(50)),
                PRIMARY KEY CLUSTERED (ID ASC));'
                                    + ' INSERT '
                                    + @outputtablename
                                    +
                                                       ' (ServerName, CheckDate, CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, QueryText, StartTime, LoginName, NTUserName, OriginalLoginName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount, DetailsInt) SELECT '
                                    +
                                                       ' @SrvName, @CheckDate, CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, QueryText, StartTime, LoginName, NTUserName, OriginalLoginName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount, DetailsInt FROM #BlitzFirstResults ORDER BY Priority , FindingsGroup , Finding , Details';

                                exec sp_executesql @stringtoexecute,
                                     N'@SrvName NVARCHAR(128), @CheckDate datetimeoffset',
                                     @localservername, @startsampletime;
                            end;
                        else
                            if (SUBSTRING(@outputtablename, 2, 1) = '#')
                                begin
                                    raiserror ('Due to the nature of Dymamic SQL, only global (i.e. double pound (##)) temp tables are supported for @OutputTableName', 16, 0);
                                end;

                    /* @OutputTableNameFileStats lets us export the results to a permanent table */
                    if @outputdatabasename is not null
                        and @outputschemaname is not null
                        and @outputtablenamefilestats is not null
                        and @outputtablenamefilestats not like '#%'
                        and EXISTS(select *
                                   from sys.databases
                                   where QUOTENAME([name]) = @outputdatabasename)
                        begin
                            /* Create the table */
                            set @stringtoexecute = 'USE '
                                + @outputdatabasename
                                + '; IF EXISTS(SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                + @outputschemaname
                                + ''') AND NOT EXISTS (SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
                                + @outputschemaname + ''' AND QUOTENAME(TABLE_NAME) = '''
                                + @outputtablenamefilestats + ''') CREATE TABLE '
                                + @outputschemaname + '.'
                                + @outputtablenamefilestats
                                + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                DatabaseID INT NOT NULL,
                FileID INT NOT NULL,
                DatabaseName NVARCHAR(256) ,
                FileLogicalName NVARCHAR(256) ,
                TypeDesc NVARCHAR(60) ,
                SizeOnDiskMB BIGINT ,
                io_stall_read_ms BIGINT ,
                num_of_reads BIGINT ,
                bytes_read BIGINT ,
                io_stall_write_ms BIGINT ,
                num_of_writes BIGINT ,
                bytes_written BIGINT,
                PhysicalName NVARCHAR(520) ,
                PRIMARY KEY CLUSTERED (ID ASC));';

                            exec (@stringtoexecute);

                            set @objectfullname = @outputdatabasename + N'.' + @outputschemaname + N'.' +
                                                  @outputtablenamefilestats_view;

                            /* If the view exists without the most recently added columns, drop it. See Github #2162. */
                            if OBJECT_ID(@objectfullname) is not null
                                begin
                                    set @stringtoexecute =
                                                N'USE ' + @outputdatabasename + N'; IF NOT EXISTS (SELECT * FROM ' +
                                                @outputdatabasename + N'.sys.all_columns
                WHERE object_id = (OBJECT_ID(''' + @objectfullname + N''')) AND name = ''JoinKey'')
                DROP VIEW ' + @outputschemaname + N'.' + @outputtablenamefilestats_view + N';';

                                    exec (@stringtoexecute);
                                end

                            /* Create the view */
                            if OBJECT_ID(@objectfullname) is null
                                begin
                                    set @stringtoexecute = 'USE '
                                        + @outputdatabasename
                                        + '; EXEC (''CREATE VIEW '
                                        + @outputschemaname + '.'
                                        + @outputtablenamefilestats_view + ' AS ' + @linefeed
                                        + 'WITH RowDates as' + @linefeed
                                        + '(' + @linefeed
                                        + '        SELECT ' + @linefeed
                                        + '                ROW_NUMBER() OVER (ORDER BY [ServerName], [CheckDate]) ID,' +
                                                           @linefeed
                                        + '                [CheckDate]' + @linefeed
                                        + '        FROM ' + @outputschemaname + '.' + @outputtablenamefilestats + '' +
                                                           @linefeed
                                        + '        GROUP BY [ServerName], [CheckDate]' + @linefeed
                                        + '),' + @linefeed
                                        + 'CheckDates as' + @linefeed
                                        + '(' + @linefeed
                                        + '        SELECT ThisDate.CheckDate,' + @linefeed
                                        + '               LastDate.CheckDate as PreviousCheckDate' + @linefeed
                                        + '        FROM RowDates ThisDate' + @linefeed
                                        + '        JOIN RowDates LastDate' + @linefeed
                                        + '        ON ThisDate.ID = LastDate.ID + 1' + @linefeed
                                        + ')' + @linefeed
                                        + '     SELECT f.ServerName,' + @linefeed
                                        + '            f.CheckDate,' + @linefeed
                                        + '            f.DatabaseID,' + @linefeed
                                        + '            f.DatabaseName,' + @linefeed
                                        + '            f.FileID,' + @linefeed
                                        + '            f.FileLogicalName,' + @linefeed
                                        + '            f.TypeDesc,' + @linefeed
                                        + '            f.PhysicalName,' + @linefeed
                                        + '            f.SizeOnDiskMB,' + @linefeed
                                        + '            DATEDIFF(ss, fPrior.CheckDate, f.CheckDate) AS ElapsedSeconds,' +
                                                           @linefeed
                                        + '            (f.SizeOnDiskMB - fPrior.SizeOnDiskMB) AS SizeOnDiskMBgrowth,' +
                                                           @linefeed
                                        +
                                                           '            (f.io_stall_read_ms - fPrior.io_stall_read_ms) AS io_stall_read_ms,' +
                                                           @linefeed
                                        + '            io_stall_read_ms_average = CASE' + @linefeed
                                        +
                                                           '                                           WHEN(f.num_of_reads - fPrior.num_of_reads) = 0' +
                                                           @linefeed
                                        + '                                           THEN 0' + @linefeed
                                        +
                                                           '                                           ELSE(f.io_stall_read_ms - fPrior.io_stall_read_ms) /     (f.num_of_reads   -           fPrior.num_of_reads)' +
                                                           @linefeed
                                        + '                                       END,' + @linefeed
                                        + '            (f.num_of_reads - fPrior.num_of_reads) AS num_of_reads,' +
                                                           @linefeed
                                        +
                                                           '            (f.bytes_read - fPrior.bytes_read) / 1024.0 / 1024.0 AS megabytes_read,' +
                                                           @linefeed
                                        +
                                                           '            (f.io_stall_write_ms - fPrior.io_stall_write_ms) AS io_stall_write_ms,' +
                                                           @linefeed
                                        + '            io_stall_write_ms_average = CASE' + @linefeed
                                        +
                                                           '                                            WHEN(f.num_of_writes - fPrior.num_of_writes) = 0' +
                                                           @linefeed
                                        + '                                            THEN 0' + @linefeed
                                        +
                                                           '                                            ELSE(f.io_stall_write_ms - fPrior.io_stall_write_ms) /         (f.num_of_writes   -       fPrior.num_of_writes)' +
                                                           @linefeed
                                        + '                                        END,' + @linefeed
                                        + '            (f.num_of_writes - fPrior.num_of_writes) AS num_of_writes,' +
                                                           @linefeed
                                        +
                                                           '            (f.bytes_written - fPrior.bytes_written) / 1024.0 / 1024.0 AS megabytes_written, ' +
                                                           @linefeed
                                        + '            f.ServerName + CAST(f.CheckDate AS NVARCHAR(50)) AS JoinKey' +
                                                           @linefeed
                                        + '     FROM   ' + @outputschemaname + '.' + @outputtablenamefilestats + ' f' +
                                                           @linefeed
                                        +
                                                           '            INNER HASH JOIN CheckDates DATES ON f.CheckDate = DATES.CheckDate' +
                                                           @linefeed
                                        + '            INNER JOIN ' + @outputschemaname + '.' +
                                                           @outputtablenamefilestats +
                                                           ' fPrior ON f.ServerName =                 fPrior.ServerName' +
                                                           @linefeed
                                        +
                                                           '                                                              AND f.DatabaseID = fPrior.DatabaseID' +
                                                           @linefeed
                                        +
                                                           '                                                              AND f.FileID = fPrior.FileID' +
                                                           @linefeed
                                        +
                                                           '                                                              AND fPrior.CheckDate =   DATES.PreviousCheckDate' +
                                                           @linefeed
                                        + '' + @linefeed
                                        + '     WHERE  f.num_of_reads >= fPrior.num_of_reads' + @linefeed
                                        + '            AND f.num_of_writes >= fPrior.num_of_writes' + @linefeed
                                        +
                                                           '            AND DATEDIFF(MI, fPrior.CheckDate, f.CheckDate) BETWEEN 1 AND 60;'')'

                                    exec (@stringtoexecute);
                                end;


                            set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                + @outputschemaname + ''') INSERT '
                                + @outputdatabasename + '.'
                                + @outputschemaname + '.'
                                + @outputtablenamefilestats
                                +
                                                   ' (ServerName, CheckDate, DatabaseID, FileID, DatabaseName, FileLogicalName, TypeDesc, SizeOnDiskMB, io_stall_read_ms, num_of_reads, bytes_read, io_stall_write_ms, num_of_writes, bytes_written, PhysicalName) SELECT '
                                +
                                                   ' @SrvName, @CheckDate, DatabaseID, FileID, DatabaseName, FileLogicalName, TypeDesc, SizeOnDiskMB, io_stall_read_ms, num_of_reads, bytes_read, io_stall_write_ms, num_of_writes, bytes_written, PhysicalName FROM #FileStats WHERE Pass = 2';

                            exec sp_executesql @stringtoexecute,
                                 N'@SrvName NVARCHAR(128), @CheckDate datetimeoffset',
                                 @localservername, @startsampletime;

                            /* Delete history older than @OutputTableRetentionDays */
                            set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                + @outputschemaname + ''') DELETE '
                                + @outputdatabasename + '.'
                                + @outputschemaname + '.'
                                + @outputtablenamefilestats
                                + ' WHERE ServerName = @SrvName AND CheckDate < @CheckDate ;';

                            exec sp_executesql @stringtoexecute,
                                 N'@SrvName NVARCHAR(128), @CheckDate date',
                                 @localservername, @outputtablecleanupdate;

                        end;
                    else
                        if (SUBSTRING(@outputtablenamefilestats, 2, 2) = '##')
                            begin
                                set @stringtoexecute = N' IF (OBJECT_ID(''tempdb..'
                                    + @outputtablenamefilestats
                                    + ''') IS NULL) CREATE TABLE '
                                    + @outputtablenamefilestats
                                    + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                DatabaseID INT NOT NULL,
                FileID INT NOT NULL,
                DatabaseName NVARCHAR(256) ,
                FileLogicalName NVARCHAR(256) ,
                TypeDesc NVARCHAR(60) ,
                SizeOnDiskMB BIGINT ,
                io_stall_read_ms BIGINT ,
                num_of_reads BIGINT ,
                bytes_read BIGINT ,
                io_stall_write_ms BIGINT ,
                num_of_writes BIGINT ,
                bytes_written BIGINT,
                PhysicalName NVARCHAR(520) ,
                DetailsInt INT NULL,
                PRIMARY KEY CLUSTERED (ID ASC));'
                                    + ' INSERT '
                                    + @outputtablenamefilestats
                                    +
                                                       ' (ServerName, CheckDate, DatabaseID, FileID, DatabaseName, FileLogicalName, TypeDesc, SizeOnDiskMB, io_stall_read_ms, num_of_reads, bytes_read, io_stall_write_ms, num_of_writes, bytes_written, PhysicalName) SELECT '
                                    +
                                                       ' @SrvName, @CheckDate, DatabaseID, FileID, DatabaseName, FileLogicalName, TypeDesc, SizeOnDiskMB, io_stall_read_ms, num_of_reads, bytes_read, io_stall_write_ms, num_of_writes, bytes_written, PhysicalName FROM #FileStats WHERE Pass = 2';

                                exec sp_executesql @stringtoexecute,
                                     N'@SrvName NVARCHAR(128), @CheckDate datetimeoffset',
                                     @localservername, @startsampletime;
                            end;
                        else
                            if (SUBSTRING(@outputtablenamefilestats, 2, 1) = '#')
                                begin
                                    raiserror ('Due to the nature of Dymamic SQL, only global (i.e. double pound (##)) temp tables are supported for @OutputTableName', 16, 0);
                                end;


                    /* @OutputTableNamePerfmonStats lets us export the results to a permanent table */
                    if @outputdatabasename is not null
                        and @outputschemaname is not null
                        and @outputtablenameperfmonstats is not null
                        and @outputtablenameperfmonstats not like '#%'
                        and EXISTS(select *
                                   from sys.databases
                                   where QUOTENAME([name]) = @outputdatabasename)
                        begin
                            /* Create the table */
                            set @stringtoexecute = 'USE '
                                + @outputdatabasename
                                + '; IF EXISTS(SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                + @outputschemaname
                                + ''') AND NOT EXISTS (SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
                                + @outputschemaname + ''' AND QUOTENAME(TABLE_NAME) = '''
                                + @outputtablenameperfmonstats + ''') CREATE TABLE '
                                + @outputschemaname + '.'
                                + @outputtablenameperfmonstats
                                + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                [object_name] NVARCHAR(128) NOT NULL,
                [counter_name] NVARCHAR(128) NOT NULL,
                [instance_name] NVARCHAR(128) NULL,
                [cntr_value] BIGINT NULL,
                [cntr_type] INT NOT NULL,
                [value_delta] BIGINT NULL,
                [value_per_second] DECIMAL(18,2) NULL,
                PRIMARY KEY CLUSTERED (ID ASC));';

                            exec (@stringtoexecute);

                            set @objectfullname = @outputdatabasename + N'.' + @outputschemaname + N'.' +
                                                  @outputtablenameperfmonstats_view;

                            /* If the view exists without the most recently added columns, drop it. See Github #2162. */
                            if OBJECT_ID(@objectfullname) is not null
                                begin
                                    set @stringtoexecute =
                                                N'USE ' + @outputdatabasename + N'; IF NOT EXISTS (SELECT * FROM ' +
                                                @outputdatabasename + N'.sys.all_columns
                WHERE object_id = (OBJECT_ID(''' + @objectfullname + N''')) AND name = ''JoinKey'')
                DROP VIEW ' + @outputschemaname + N'.' + @outputtablenameperfmonstats_view + N';';

                                    exec (@stringtoexecute);
                                end

                            /* Create the view */
                            if OBJECT_ID(@objectfullname) is null
                                begin
                                    set @stringtoexecute = 'USE '
                                        + @outputdatabasename
                                        + '; EXEC (''CREATE VIEW '
                                        + @outputschemaname + '.'
                                        + @outputtablenameperfmonstats_view + ' AS ' + @linefeed
                                        + 'WITH RowDates as' + @linefeed
                                        + '(' + @linefeed
                                        + '        SELECT ' + @linefeed
                                        + '                ROW_NUMBER() OVER (ORDER BY [ServerName], [CheckDate]) ID,' +
                                                           @linefeed
                                        + '                [CheckDate]' + @linefeed
                                        + '        FROM ' + @outputschemaname + '.' + @outputtablenameperfmonstats +
                                                           '' + @linefeed
                                        + '        GROUP BY [ServerName], [CheckDate]' + @linefeed
                                        + '),' + @linefeed
                                        + 'CheckDates as' + @linefeed
                                        + '(' + @linefeed
                                        + '        SELECT ThisDate.CheckDate,' + @linefeed
                                        + '               LastDate.CheckDate as PreviousCheckDate' + @linefeed
                                        + '        FROM RowDates ThisDate' + @linefeed
                                        + '        JOIN RowDates LastDate' + @linefeed
                                        + '        ON ThisDate.ID = LastDate.ID + 1' + @linefeed
                                        + ')' + @linefeed
                                        + 'SELECT' + @linefeed
                                        + '       pMon.[ServerName]' + @linefeed
                                        + '      ,pMon.[CheckDate]' + @linefeed
                                        + '      ,pMon.[object_name]' + @linefeed
                                        + '      ,pMon.[counter_name]' + @linefeed
                                        + '      ,pMon.[instance_name]' + @linefeed
                                        +
                                                           '      ,DATEDIFF(SECOND,pMonPrior.[CheckDate],pMon.[CheckDate]) AS ElapsedSeconds' +
                                                           @linefeed
                                        + '      ,pMon.[cntr_value]' + @linefeed
                                        + '      ,pMon.[cntr_type]' + @linefeed
                                        + '      ,(pMon.[cntr_value] - pMonPrior.[cntr_value]) AS cntr_delta' +
                                                           @linefeed
                                        +
                                                           '      ,(pMon.cntr_value - pMonPrior.cntr_value) * 1.0 / DATEDIFF(ss, pMonPrior.CheckDate, pMon.CheckDate) AS cntr_delta_per_second' +
                                                           @linefeed
                                        + '      ,pMon.ServerName + CAST(pMon.CheckDate AS NVARCHAR(50)) AS JoinKey' +
                                                           @linefeed
                                        + '  FROM ' + @outputschemaname + '.' + @outputtablenameperfmonstats + ' pMon' +
                                                           @linefeed
                                        + '  INNER HASH JOIN CheckDates Dates' + @linefeed
                                        + '  ON Dates.CheckDate = pMon.CheckDate' + @linefeed
                                        + '  JOIN ' + @outputschemaname + '.' + @outputtablenameperfmonstats +
                                                           ' pMonPrior' + @linefeed
                                        + '  ON  Dates.PreviousCheckDate = pMonPrior.CheckDate' + @linefeed
                                        + '      AND pMon.[ServerName]    = pMonPrior.[ServerName]   ' + @linefeed
                                        + '      AND pMon.[object_name]   = pMonPrior.[object_name]  ' + @linefeed
                                        + '      AND pMon.[counter_name]  = pMonPrior.[counter_name] ' + @linefeed
                                        + '      AND pMon.[instance_name] = pMonPrior.[instance_name]' + @linefeed
                                        +
                                                           '    WHERE DATEDIFF(MI, pMonPrior.CheckDate, pMon.CheckDate) BETWEEN 1 AND 60;'')'

                                    exec (@stringtoexecute);
                                end

                            set @objectfullname = @outputdatabasename + N'.' + @outputschemaname + N'.' +
                                                  @outputtablenameperfmonstatsactuals_view;

                            /* If the view exists without the most recently added columns, drop it. See Github #2162. */
                            if OBJECT_ID(@objectfullname) is not null
                                begin
                                    set @stringtoexecute =
                                                N'USE ' + @outputdatabasename + N'; IF NOT EXISTS (SELECT * FROM ' +
                                                @outputdatabasename + N'.sys.all_columns
                WHERE object_id = (OBJECT_ID(''' + @objectfullname + N''')) AND name = ''JoinKey'')
                DROP VIEW ' + @outputschemaname + N'.' + @outputtablenameperfmonstatsactuals_view + N';';

                                    exec (@stringtoexecute);
                                end

                            /* Create the second view */
                            if OBJECT_ID(@objectfullname) is null
                                begin
                                    set @stringtoexecute = 'USE '
                                        + @outputdatabasename
                                        + '; EXEC (''CREATE VIEW '
                                        + @outputschemaname + '.'
                                        + @outputtablenameperfmonstatsactuals_view + ' AS ' + @linefeed
                                        + 'WITH PERF_AVERAGE_BULK AS' + @linefeed
                                        + '(' + @linefeed
                                        + '    SELECT ServerName,' + @linefeed
                                        + '           object_name,' + @linefeed
                                        + '           instance_name,' + @linefeed
                                        + '           counter_name,' + @linefeed
                                        +
                                                           '           CASE WHEN CHARINDEX(''''('''', counter_name) = 0 THEN counter_name ELSE LEFT (counter_name, CHARINDEX(''''('''',counter_name)-1) END    AS   counter_join,' +
                                                           @linefeed
                                        + '           CheckDate,' + @linefeed
                                        + '           cntr_delta' + @linefeed
                                        + '    FROM   ' + @outputschemaname + '.' + @outputtablenameperfmonstats_view +
                                                           @linefeed
                                        + '    WHERE  cntr_type IN(1073874176)' + @linefeed
                                        + '    AND cntr_delta <> 0' + @linefeed
                                        + '),' + @linefeed
                                        + 'PERF_LARGE_RAW_BASE AS' + @linefeed
                                        + '(' + @linefeed
                                        + '    SELECT ServerName,' + @linefeed
                                        + '           object_name,' + @linefeed
                                        + '           instance_name,' + @linefeed
                                        +
                                                           '           LEFT(counter_name, CHARINDEX(''''BASE'''', UPPER(counter_name))-1) AS counter_join,' +
                                                           @linefeed
                                        + '           CheckDate,' + @linefeed
                                        + '           cntr_delta' + @linefeed
                                        + '    FROM   ' + @outputschemaname + '.' + @outputtablenameperfmonstats_view +
                                                           '' + @linefeed
                                        + '    WHERE  cntr_type IN(1073939712)' + @linefeed
                                        + '    AND cntr_delta <> 0' + @linefeed
                                        + '),' + @linefeed
                                        + 'PERF_AVERAGE_FRACTION AS' + @linefeed
                                        + '(' + @linefeed
                                        + '    SELECT ServerName,' + @linefeed
                                        + '           object_name,' + @linefeed
                                        + '           instance_name,' + @linefeed
                                        + '           counter_name,' + @linefeed
                                        + '           counter_name AS counter_join,' + @linefeed
                                        + '           CheckDate,' + @linefeed
                                        + '           cntr_delta' + @linefeed
                                        + '    FROM   ' + @outputschemaname + '.' + @outputtablenameperfmonstats_view +
                                                           '' + @linefeed
                                        + '    WHERE  cntr_type IN(537003264)' + @linefeed
                                        + '    AND cntr_delta <> 0' + @linefeed
                                        + '),' + @linefeed
                                        + 'PERF_COUNTER_BULK_COUNT AS' + @linefeed
                                        + '(' + @linefeed
                                        + '    SELECT ServerName,' + @linefeed
                                        + '           object_name,' + @linefeed
                                        + '           instance_name,' + @linefeed
                                        + '           counter_name,' + @linefeed
                                        + '           CheckDate,' + @linefeed
                                        + '           cntr_delta / ElapsedSeconds AS cntr_value' + @linefeed
                                        + '    FROM   ' + @outputschemaname + '.' + @outputtablenameperfmonstats_view +
                                                           '' + @linefeed
                                        + '    WHERE  cntr_type IN(272696576, 272696320)' + @linefeed
                                        + '    AND cntr_delta <> 0' + @linefeed
                                        + '),' + @linefeed
                                        + 'PERF_COUNTER_RAWCOUNT AS' + @linefeed
                                        + '(' + @linefeed
                                        + '    SELECT ServerName,' + @linefeed
                                        + '           object_name,' + @linefeed
                                        + '           instance_name,' + @linefeed
                                        + '           counter_name,' + @linefeed
                                        + '           CheckDate,' + @linefeed
                                        + '           cntr_value' + @linefeed
                                        + '    FROM   ' + @outputschemaname + '.' + @outputtablenameperfmonstats_view +
                                                           '' + @linefeed
                                        + '    WHERE  cntr_type IN(65792, 65536)' + @linefeed
                                        + ')' + @linefeed
                                        + '' + @linefeed
                                        + 'SELECT NUM.ServerName,' + @linefeed
                                        + '       NUM.object_name,' + @linefeed
                                        + '       NUM.counter_name,' + @linefeed
                                        + '       NUM.instance_name,' + @linefeed
                                        + '       NUM.CheckDate,' + @linefeed
                                        + '       NUM.cntr_delta / DEN.cntr_delta AS cntr_value,' + @linefeed
                                        + '       NUM.ServerName + CAST(NUM.CheckDate AS NVARCHAR(50)) AS JoinKey' +
                                                           @linefeed
                                        + '       ' + @linefeed
                                        + 'FROM   PERF_AVERAGE_BULK AS NUM' + @linefeed
                                        +
                                                           '       JOIN PERF_LARGE_RAW_BASE AS DEN ON NUM.counter_join = DEN.counter_join' +
                                                           @linefeed
                                        +
                                                           '                                          AND NUM.CheckDate = DEN.CheckDate' +
                                                           @linefeed
                                        +
                                                           '                                          AND NUM.ServerName = DEN.ServerName' +
                                                           @linefeed
                                        +
                                                           '                                          AND NUM.object_name = DEN.object_name' +
                                                           @linefeed
                                        +
                                                           '                                          AND NUM.instance_name = DEN.instance_name' +
                                                           @linefeed
                                        + '                                          AND DEN.cntr_delta <> 0' +
                                                           @linefeed
                                        + '' + @linefeed
                                        + 'UNION ALL' + @linefeed
                                        + '' + @linefeed
                                        + 'SELECT NUM.ServerName,' + @linefeed
                                        + '       NUM.object_name,' + @linefeed
                                        + '       NUM.counter_name,' + @linefeed
                                        + '       NUM.instance_name,' + @linefeed
                                        + '       NUM.CheckDate,' + @linefeed
                                        +
                                                           '       CAST((CAST(NUM.cntr_delta as DECIMAL(19)) / DEN.cntr_delta) as decimal(23,3))  AS cntr_value,' +
                                                           @linefeed
                                        + '       NUM.ServerName + CAST(NUM.CheckDate AS NVARCHAR(50)) AS JoinKey' +
                                                           @linefeed
                                        + 'FROM   PERF_AVERAGE_FRACTION AS NUM' + @linefeed
                                        +
                                                           '       JOIN PERF_LARGE_RAW_BASE AS DEN ON NUM.counter_join = DEN.counter_join' +
                                                           @linefeed
                                        +
                                                           '                                          AND NUM.CheckDate = DEN.CheckDate' +
                                                           @linefeed
                                        +
                                                           '                                          AND NUM.ServerName = DEN.ServerName' +
                                                           @linefeed
                                        +
                                                           '                                          AND NUM.object_name = DEN.object_name' +
                                                           @linefeed
                                        +
                                                           '                                          AND NUM.instance_name = DEN.instance_name' +
                                                           @linefeed
                                        + '                                          AND DEN.cntr_delta <> 0' +
                                                           @linefeed
                                        + 'UNION ALL' + @linefeed
                                        + '' + @linefeed
                                        + 'SELECT ServerName,' + @linefeed
                                        + '       object_name,' + @linefeed
                                        + '       counter_name,' + @linefeed
                                        + '       instance_name,' + @linefeed
                                        + '       CheckDate,' + @linefeed
                                        + '       cntr_value,' + @linefeed
                                        + '       ServerName + CAST(CheckDate AS NVARCHAR(50)) AS JoinKey' + @linefeed
                                        + 'FROM   PERF_COUNTER_BULK_COUNT' + @linefeed
                                        + '' + @linefeed
                                        + 'UNION ALL' + @linefeed
                                        + '' + @linefeed
                                        + 'SELECT ServerName,' + @linefeed
                                        + '       object_name,' + @linefeed
                                        + '       counter_name,' + @linefeed
                                        + '       instance_name,' + @linefeed
                                        + '       CheckDate,' + @linefeed
                                        + '       cntr_value,' + @linefeed
                                        + '       ServerName + CAST(CheckDate AS NVARCHAR(50)) AS JoinKey' + @linefeed
                                        + 'FROM   PERF_COUNTER_RAWCOUNT;'')';

                                    exec (@stringtoexecute);
                                end;


                            set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                + @outputschemaname + ''') INSERT '
                                + @outputdatabasename + '.'
                                + @outputschemaname + '.'
                                + @outputtablenameperfmonstats
                                +
                                                   ' (ServerName, CheckDate, object_name, counter_name, instance_name, cntr_value, cntr_type, value_delta, value_per_second) SELECT '
                                +
                                                   ' @SrvName, @CheckDate, object_name, counter_name, instance_name, cntr_value, cntr_type, value_delta, value_per_second FROM #PerfmonStats WHERE Pass = 2';

                            exec sp_executesql @stringtoexecute,
                                 N'@SrvName NVARCHAR(128), @CheckDate datetimeoffset',
                                 @localservername, @startsampletime;

                            /* Delete history older than @OutputTableRetentionDays */
                            set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                + @outputschemaname + ''') DELETE '
                                + @outputdatabasename + '.'
                                + @outputschemaname + '.'
                                + @outputtablenameperfmonstats
                                + ' WHERE ServerName = @SrvName AND CheckDate < @CheckDate ;';

                            exec sp_executesql @stringtoexecute,
                                 N'@SrvName NVARCHAR(128), @CheckDate date',
                                 @localservername, @outputtablecleanupdate;


                        end;
                    else
                        if (SUBSTRING(@outputtablenameperfmonstats, 2, 2) = '##')
                            begin
                                set @stringtoexecute = N' IF (OBJECT_ID(''tempdb..'
                                    + @outputtablenameperfmonstats
                                    + ''') IS NULL) CREATE TABLE '
                                    + @outputtablenameperfmonstats
                                    + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                [object_name] NVARCHAR(128) NOT NULL,
                [counter_name] NVARCHAR(128) NOT NULL,
                [instance_name] NVARCHAR(128) NULL,
                [cntr_value] BIGINT NULL,
                [cntr_type] INT NOT NULL,
                [value_delta] BIGINT NULL,
                [value_per_second] DECIMAL(18,2) NULL,
                PRIMARY KEY CLUSTERED (ID ASC));'
                                    + ' INSERT '
                                    + @outputtablenameperfmonstats
                                    +
                                                       ' (ServerName, CheckDate, object_name, counter_name, instance_name, cntr_value, cntr_type, value_delta, value_per_second) SELECT '
                                    + CAST(SERVERPROPERTY('ServerName') as nvarchar(128))
                                    +
                                                       ' @SrvName, @CheckDate, object_name, counter_name, instance_name, cntr_value, cntr_type, value_delta, value_per_second FROM #PerfmonStats WHERE Pass = 2';

                                exec sp_executesql @stringtoexecute,
                                     N'@SrvName NVARCHAR(128), @CheckDate datetimeoffset',
                                     @localservername, @startsampletime;
                            end;
                        else
                            if (SUBSTRING(@outputtablenameperfmonstats, 2, 1) = '#')
                                begin
                                    raiserror ('Due to the nature of Dymamic SQL, only global (i.e. double pound (##)) temp tables are supported for @OutputTableName', 16, 0);
                                end;


                    /* @OutputTableNameWaitStats lets us export the results to a permanent table */
                    if @outputdatabasename is not null
                        and @outputschemaname is not null
                        and @outputtablenamewaitstats is not null
                        and @outputtablenamewaitstats not like '#%'
                        and EXISTS(select *
                                   from sys.databases
                                   where QUOTENAME([name]) = @outputdatabasename)
                        begin
                            /* Create the table */
                            set @stringtoexecute = 'USE '
                                + @outputdatabasename
                                + '; IF EXISTS(SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                + @outputschemaname
                                + ''') AND NOT EXISTS (SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
                                + @outputschemaname + ''' AND QUOTENAME(TABLE_NAME) = '''
                                + @outputtablenamewaitstats + ''') ' + @linefeed
                                + 'BEGIN' + @linefeed
                                + 'CREATE TABLE '
                                + @outputschemaname + '.'
                                + @outputtablenamewaitstats
                                + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                wait_type NVARCHAR(60),
                wait_time_ms BIGINT,
                signal_wait_time_ms BIGINT,
                waiting_tasks_count BIGINT ,
                PRIMARY KEY CLUSTERED (ID));' + @linefeed
                                + 'CREATE NONCLUSTERED INDEX IX_ServerName_wait_type_CheckDate_Includes ON ' +
                                                   @outputschemaname + '.' + @outputtablenamewaitstats + @linefeed
                                +
                                                   '(ServerName, wait_type, CheckDate) INCLUDE (wait_time_ms, signal_wait_time_ms, waiting_tasks_count);' +
                                                   @linefeed
                                + 'END';

                            exec (@stringtoexecute);

                            /* Create the wait stats category table */
                            set @objectfullname = @outputdatabasename + N'.' + @outputschemaname + N'.' +
                                                  @outputtablenamewaitstats_categories;
                            if OBJECT_ID(@objectfullname) is null
                                begin
                                    set @stringtoexecute = 'USE '
                                        + @outputdatabasename
                                        + '; EXEC (''CREATE TABLE '
                                        + @outputschemaname + '.'
                                        + @outputtablenamewaitstats_categories +
                                                           ' (WaitType NVARCHAR(60) PRIMARY KEY CLUSTERED, WaitCategory NVARCHAR(128) NOT NULL, Ignorable BIT DEFAULT 0);'')';

                                    exec (@stringtoexecute);
                                end;

                            /* Make sure the wait stats category table has the current number of rows */
                            set @stringtoexecute = 'USE '
                                + @outputdatabasename
                                + '; EXEC (''IF (SELECT COALESCE(SUM(1),0) FROM ' + @outputschemaname + '.' +
                                                   @outputtablenamewaitstats_categories +
                                                   ') <> (SELECT COALESCE(SUM(1),0) FROM ##WaitCategories)' + @linefeed
                                + 'BEGIN ' + @linefeed
                                + 'TRUNCATE TABLE ' + @outputschemaname + '.' + @outputtablenamewaitstats_categories +
                                                   @linefeed
                                + 'INSERT INTO ' + @outputschemaname + '.' + @outputtablenamewaitstats_categories +
                                                   ' (WaitType, WaitCategory, Ignorable) SELECT WaitType, WaitCategory, Ignorable FROM ##WaitCategories;' +
                                                   @linefeed
                                + 'END'')';

                            exec (@stringtoexecute);


                            set @objectfullname = @outputdatabasename + N'.' + @outputschemaname + N'.' +
                                                  @outputtablenamewaitstats_view;

                            /* If the view exists without the most recently added columns, drop it. See Github #2162. */
                            if OBJECT_ID(@objectfullname) is not null
                                begin
                                    set @stringtoexecute =
                                                N'USE ' + @outputdatabasename + N'; IF NOT EXISTS (SELECT * FROM ' +
                                                @outputdatabasename + N'.sys.all_columns
                WHERE object_id = (OBJECT_ID(''' + @objectfullname + N''')) AND name = ''JoinKey'')
                DROP VIEW ' + @outputschemaname + N'.' + @outputtablenamewaitstats_view + N';';

                                    exec (@stringtoexecute);
                                end


                            /* Create the wait stats view */
                            if OBJECT_ID(@objectfullname) is null
                                begin
                                    set @stringtoexecute = 'USE '
                                        + @outputdatabasename
                                        + '; EXEC (''CREATE VIEW '
                                        + @outputschemaname + '.'
                                        + @outputtablenamewaitstats_view + ' AS ' + @linefeed
                                        + 'WITH RowDates as' + @linefeed
                                        + '(' + @linefeed
                                        + '        SELECT ' + @linefeed
                                        + '                ROW_NUMBER() OVER (ORDER BY [ServerName], [CheckDate]) ID,' +
                                                           @linefeed
                                        + '                [CheckDate]' + @linefeed
                                        + '        FROM ' + @outputschemaname + '.' + @outputtablenamewaitstats +
                                                           @linefeed
                                        + '        GROUP BY [ServerName], [CheckDate]' + @linefeed
                                        + '),' + @linefeed
                                        + 'CheckDates as' + @linefeed
                                        + '(' + @linefeed
                                        + '        SELECT ThisDate.CheckDate,' + @linefeed
                                        + '               LastDate.CheckDate as PreviousCheckDate' + @linefeed
                                        + '        FROM RowDates ThisDate' + @linefeed
                                        + '        JOIN RowDates LastDate' + @linefeed
                                        + '        ON ThisDate.ID = LastDate.ID + 1' + @linefeed
                                        + ')' + @linefeed
                                        +
                                                           'SELECT w.ServerName, w.CheckDate, w.wait_type, COALESCE(wc.WaitCategory, ''''Other'''') AS WaitCategory, COALESCE(wc.Ignorable,0) AS Ignorable' +
                                                           @linefeed
                                        + ', DATEDIFF(ss, wPrior.CheckDate, w.CheckDate) AS ElapsedSeconds' + @linefeed
                                        + ', (w.wait_time_ms - wPrior.wait_time_ms) AS wait_time_ms_delta' + @linefeed
                                        +
                                                           ', (w.wait_time_ms - wPrior.wait_time_ms) / 60000.0 AS wait_time_minutes_delta' +
                                                           @linefeed
                                        +
                                                           ', (w.wait_time_ms - wPrior.wait_time_ms) / 1000.0 / DATEDIFF(ss, wPrior.CheckDate, w.CheckDate) AS wait_time_minutes_per_minute' +
                                                           @linefeed
                                        +
                                                           ', (w.signal_wait_time_ms - wPrior.signal_wait_time_ms) AS signal_wait_time_ms_delta' +
                                                           @linefeed
                                        +
                                                           ', (w.waiting_tasks_count - wPrior.waiting_tasks_count) AS waiting_tasks_count_delta' +
                                                           @linefeed
                                        + ', w.ServerName + CAST(w.CheckDate AS NVARCHAR(50)) AS JoinKey' + @linefeed
                                        + 'FROM ' + @outputschemaname + '.' + @outputtablenamewaitstats + ' w' +
                                                           @linefeed
                                        + 'INNER HASH JOIN CheckDates Dates' + @linefeed
                                        + 'ON Dates.CheckDate = w.CheckDate' + @linefeed
                                        + 'INNER JOIN ' + @outputschemaname + '.' + @outputtablenamewaitstats +
                                                           ' wPrior ON w.ServerName = wPrior.ServerName AND w.wait_type = wPrior.wait_type AND Dates.PreviousCheckDate = wPrior.CheckDate' +
                                                           @linefeed
                                        + 'LEFT OUTER JOIN ' + @outputschemaname + '.' +
                                                           @outputtablenamewaitstats_categories +
                                                           ' wc ON w.wait_type = wc.WaitType' + @linefeed
                                        + 'WHERE DATEDIFF(MI, wPrior.CheckDate, w.CheckDate) BETWEEN 1 AND 60' +
                                                           @linefeed
                                        + 'AND [w].[wait_time_ms] >= [wPrior].[wait_time_ms];'')'

                                    exec (@stringtoexecute);
                                end;


                            set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                + @outputschemaname + ''') INSERT '
                                + @outputdatabasename + '.'
                                + @outputschemaname + '.'
                                + @outputtablenamewaitstats
                                +
                                                   ' (ServerName, CheckDate, wait_type, wait_time_ms, signal_wait_time_ms, waiting_tasks_count) SELECT '
                                +
                                                   ' @SrvName, @CheckDate, wait_type, wait_time_ms, signal_wait_time_ms, waiting_tasks_count FROM #WaitStats WHERE Pass = 2 AND wait_time_ms > 0 AND waiting_tasks_count > 0';

                            exec sp_executesql @stringtoexecute,
                                 N'@SrvName NVARCHAR(128), @CheckDate datetimeoffset',
                                 @localservername, @startsampletime;

                            /* Delete history older than @OutputTableRetentionDays */
                            set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                                + @outputdatabasename
                                + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                                + @outputschemaname + ''') DELETE '
                                + @outputdatabasename + '.'
                                + @outputschemaname + '.'
                                + @outputtablenamewaitstats
                                + ' WHERE ServerName = @SrvName AND CheckDate < @CheckDate ;';

                            exec sp_executesql @stringtoexecute,
                                 N'@SrvName NVARCHAR(128), @CheckDate date',
                                 @localservername, @outputtablecleanupdate;

                        end;
                    else
                        if (SUBSTRING(@outputtablenamewaitstats, 2, 2) = '##')
                            begin
                                set @stringtoexecute = N' IF (OBJECT_ID(''tempdb..'
                                    + @outputtablenamewaitstats
                                    + ''') IS NULL) CREATE TABLE '
                                    + @outputtablenamewaitstats
                                    + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                wait_type NVARCHAR(60),
                wait_time_ms BIGINT,
                signal_wait_time_ms BIGINT,
                waiting_tasks_count BIGINT ,
                PRIMARY KEY CLUSTERED (ID ASC));'
                                    + ' INSERT '
                                    + @outputtablenamewaitstats
                                    +
                                                       ' (ServerName, CheckDate, wait_type, wait_time_ms, signal_wait_time_ms, waiting_tasks_count) SELECT '
                                    +
                                                       ' @SrvName, @CheckDate, wait_type, wait_time_ms, signal_wait_time_ms, waiting_tasks_count FROM #WaitStats WHERE Pass = 2 AND wait_time_ms > 0 AND waiting_tasks_count > 0';

                                exec sp_executesql @stringtoexecute,
                                     N'@SrvName NVARCHAR(128), @CheckDate datetimeoffset',
                                     @localservername, @startsampletime;
                            end;
                        else
                            if (SUBSTRING(@outputtablenamewaitstats, 2, 1) = '#')
                                begin
                                    raiserror ('Due to the nature of Dymamic SQL, only global (i.e. double pound (##)) temp tables are supported for @OutputTableName', 16, 0);
                                end;


                    declare @separator as varchar(1);
                    if @outputtype = 'RSV'
                        set @separator = CHAR(31);
                    else
                        set @separator = ',';

                    if @outputtype = 'COUNT' and @sincestartup = 0
                        begin
                            select COUNT(*) as warnings
                            from #blitzfirstresults;
                        end;
                    else
                        if @outputtype = 'Opserver1' and @sincestartup = 0
                            begin

                                select                         r.[Priority],
                                                               r.[FindingsGroup],
                                                               r.[Finding],
                                                               r.[URL],
                                                               r.[Details],
                                                               r.[HowToStopIt],
                                                               r.[CheckID],
                                                               r.[StartTime],
                                                               r.[LoginName],
                                                               r.[NTUserName],
                                                               r.[OriginalLoginName],
                                                               r.[ProgramName],
                                                               r.[HostName],
                                                               r.[DatabaseID],
                                                               r.[DatabaseName],
                                                               r.[OpenTransactionCount],
                                                               r.[QueryPlan],
                                                               r.[QueryText],
                                                               qsnow.plan_handle            as planhandle,
                                                               qsnow.sql_handle             as sqlhandle,
                                                               qsnow.statement_start_offset as statementstartoffset,
                                                               qsnow.statement_end_offset   as statementendoffset,
                                    [Executions]             = qsnow.execution_count - (COALESCE(qsfirst.execution_count, 0)),
                                    [ExecutionsPercent]      = CAST(100.0 *
                                                                    (qsnow.execution_count - (COALESCE(qsfirst.execution_count, 0))) /
                                                                    (qstotal.execution_count - qstotalfirst.execution_count) as decimal(6, 2)),
                                    [Duration]               = qsnow.total_elapsed_time - (COALESCE(qsfirst.total_elapsed_time, 0)),
                                    [DurationPercent]        = CAST(100.0 *
                                                                    (qsnow.total_elapsed_time - (COALESCE(qsfirst.total_elapsed_time, 0))) /
                                                                    (qstotal.total_elapsed_time - qstotalfirst.total_elapsed_time) as decimal(6, 2)),
                                    [CPU]                    = qsnow.total_worker_time - (COALESCE(qsfirst.total_worker_time, 0)),
                                    [CPUPercent]             = CAST(100.0 *
                                                                    (qsnow.total_worker_time - (COALESCE(qsfirst.total_worker_time, 0))) /
                                                                    (qstotal.total_worker_time - qstotalfirst.total_worker_time) as decimal(6, 2)),
                                    [Reads]                  = qsnow.total_logical_reads -
                                                               (COALESCE(qsfirst.total_logical_reads, 0)),
                                    [ReadsPercent]           = CAST(100.0 * (qsnow.total_logical_reads -
                                                                             (COALESCE(qsfirst.total_logical_reads, 0))) /
                                                                    (qstotal.total_logical_reads - qstotalfirst.total_logical_reads) as decimal(6, 2)),
                                    [PlanCreationTime]       = CONVERT(nvarchar(100), qsnow.creation_time, 121),
                                    [TotalExecutions]        = qsnow.execution_count,
                                    [TotalExecutionsPercent] = CAST(
                                                                       100.0 * qsnow.execution_count / qstotal.execution_count as decimal(6, 2)),
                                    [TotalDuration]          = qsnow.total_elapsed_time,
                                    [TotalDurationPercent]   = CAST(
                                                                       100.0 * qsnow.total_elapsed_time / qstotal.total_elapsed_time as decimal(6, 2)),
                                    [TotalCPU]               = qsnow.total_worker_time,
                                    [TotalCPUPercent]        = CAST(
                                                                       100.0 * qsnow.total_worker_time / qstotal.total_worker_time as decimal(6, 2)),
                                    [TotalReads]             = qsnow.total_logical_reads,
                                    [TotalReadsPercent]      = CAST(
                                                                       100.0 * qsnow.total_logical_reads / qstotal.total_logical_reads as decimal(6, 2)),
                                                               r.[DetailsInt]
                                from #blitzfirstresults r
                                         left outer join #querystats qstotal on qstotal.pass = 0
                                         left outer join #querystats qstotalfirst on qstotalfirst.pass = -1
                                         left outer join #querystats qsnow on r.querystatsnowid = qsnow.id
                                         left outer join #querystats qsfirst on r.querystatsfirstid = qsfirst.id
                                order by r.priority,
                                         r.findingsgroup,
                                         case
                                             when r.checkid = 6 then detailsint
                                             else 0
                                             end desc,
                                         r.finding,
                                         r.id;
                            end;
                        else
                            if @outputtype in ('CSV', 'RSV') and @sincestartup = 0
                                begin

                                    select result = CAST([Priority] as nvarchar(100))
                                        + @separator + CAST(checkid as nvarchar(100))
                                        + @separator + COALESCE([FindingsGroup],
                                                                '(N/A)') + @separator
                                        + COALESCE([Finding], '(N/A)') + @separator
                                        + COALESCE(databasename, '(N/A)') + @separator
                                        + COALESCE([URL], '(N/A)') + @separator
                                        + COALESCE([Details], '(N/A)')
                                    from #blitzfirstresults
                                    order by priority,
                                             findingsgroup,
                                             case
                                                 when checkid = 6 then detailsint
                                                 else 0
                                                 end desc,
                                             finding,
                                             details;
                                end;
                            else
                                if @outputtype = 'Top10'
                                    begin
                                        /* Measure waits in hours */
                                        ;
                                        with max_batch as (
                                            select MAX(sampletime) as sampletime
                                            from #waitstats
                                        )
                                        select top 10 CAST(
                                                              DATEDIFF(mi, wd1.sampletime, wd2.sampletime) / 60.0 as decimal(18, 1)) as [Hours Sample],
                                                      wd1.wait_type,
                                                      COALESCE(wcat.waitcategory, 'Other')                                           as wait_category,
                                                      CAST(c.[Wait Time (Seconds)] / 60.0 / 60 as decimal(18, 1))                    as [Wait Time (Hours)],
                                                      CAST((wd2.wait_time_ms - wd1.wait_time_ms) / 1000.0 /
                                                           cores.cpu_count /
                                                           DATEDIFF(ss, wd1.sampletime, wd2.sampletime) as decimal(18, 1))           as [Per Core Per Hour],
                                                      (wd2.waiting_tasks_count - wd1.waiting_tasks_count)                            as [Number of Waits],
                                                      case
                                                          when (wd2.waiting_tasks_count - wd1.waiting_tasks_count) > 0
                                                              then
                                                              CAST((wd2.wait_time_ms - wd1.wait_time_ms) /
                                                                   (1.0 * (wd2.waiting_tasks_count - wd1.waiting_tasks_count)) as numeric(12, 1))
                                                          else 0 end                                                                 as [Avg ms Per Wait]
                                        from max_batch b
                                                 join #waitstats wd2 on
                                            wd2.sampletime = b.sampletime
                                                 join #waitstats wd1 on
                                                wd1.wait_type = wd2.wait_type and
                                                wd2.sampletime > wd1.sampletime
                                                 cross apply (select SUM(1) as cpu_count
                                                              from sys.dm_os_schedulers
                                                              where status = 'VISIBLE ONLINE'
                                                                and is_online = 1) as cores
                                                 cross apply (select CAST(
                                                                             (wd2.wait_time_ms - wd1.wait_time_ms) / 1000. as numeric(12, 1))               as [Wait Time (Seconds)],
                                                                     CAST(
                                                                             (wd2.signal_wait_time_ms - wd1.signal_wait_time_ms) / 1000. as numeric(12, 1)) as [Signal Wait Time (Seconds)]) as c
                                                 left outer join ##waitcategories wcat on wd1.wait_type = wcat.waittype
                                        where (wd2.waiting_tasks_count - wd1.waiting_tasks_count) > 0
                                          and wd2.wait_time_ms - wd1.wait_time_ms > 0
                                        order by [Wait Time (Seconds)] desc;
                                    end;
                                else
                                    if @expertmode = 0 and @outputtype <> 'NONE' and @outputxmlasnvarchar = 0 and
                                       @sincestartup = 0
                                        begin
                                            select [Priority],
                                                   [FindingsGroup],
                                                   [Finding],
                                                   [URL],
                                                   CAST(@stockdetailsheader + [Details] + @stockdetailsfooter as xml)   as details,
                                                   CAST(@stockwarningheader + howtostopit + @stockwarningfooter as xml) as howtostopit,
                                                   [QueryText],
                                                   [QueryPlan]
                                            from #blitzfirstresults
                                            where (@seconds > 0 or (priority in (0, 250, 251, 255))) /* For @Seconds = 0, filter out broken checks for now */
                                            order by priority,
                                                     findingsgroup,
                                                     case
                                                         when checkid = 6 then detailsint
                                                         else 0
                                                         end desc,
                                                     finding,
                                                     id,
                                                     CAST(details as nvarchar(4000));
                                        end;
                                    else
                                        if @outputtype <> 'NONE' and @outputxmlasnvarchar = 1 and @sincestartup = 0
                                            begin
                                                select [Priority],
                                                       [FindingsGroup],
                                                       [Finding],
                                                       [URL],
                                                       CAST(
                                                               @stockdetailsheader + [Details] + @stockdetailsfooter as nvarchar(max)) as details,
                                                       CAST([HowToStopIt] as nvarchar(max))                                            as howtostopit,
                                                       CAST([QueryText] as nvarchar(max))                                              as querytext,
                                                       CAST([QueryPlan] as nvarchar(max))                                              as queryplan
                                                from #blitzfirstresults
                                                where (@seconds > 0 or (priority in (0, 250, 251, 255))) /* For @Seconds = 0, filter out broken checks for now */
                                                order by priority,
                                                         findingsgroup,
                                                         case
                                                             when checkid = 6 then detailsint
                                                             else 0
                                                             end desc,
                                                         finding,
                                                         id,
                                                         CAST(details as nvarchar(4000));
                                            end;
                                        else
                                            if @expertmode = 1 and @outputtype <> 'NONE'
                                                begin
                                                    if @sincestartup = 0
                                                        select                         r.[Priority],
                                                                                       r.[FindingsGroup],
                                                                                       r.[Finding],
                                                                                       r.[URL],
                                                                                       CAST(@stockdetailsheader + r.[Details] + @stockdetailsfooter as xml)   as details,
                                                                                       CAST(@stockwarningheader + r.howtostopit + @stockwarningfooter as xml) as howtostopit,
                                                                                       r.[CheckID],
                                                                                       r.[StartTime],
                                                                                       r.[LoginName],
                                                                                       r.[NTUserName],
                                                                                       r.[OriginalLoginName],
                                                                                       r.[ProgramName],
                                                                                       r.[HostName],
                                                                                       r.[DatabaseID],
                                                                                       r.[DatabaseName],
                                                                                       r.[OpenTransactionCount],
                                                                                       r.[QueryPlan],
                                                                                       r.[QueryText],
                                                                                       qsnow.plan_handle                                                      as planhandle,
                                                                                       qsnow.sql_handle                                                       as sqlhandle,
                                                                                       qsnow.statement_start_offset                                           as statementstartoffset,
                                                                                       qsnow.statement_end_offset                                             as statementendoffset,
                                                            [Executions]             = qsnow.execution_count - (COALESCE(qsfirst.execution_count, 0)),
                                                            [ExecutionsPercent]      = CAST(100.0 *
                                                                                            (qsnow.execution_count - (COALESCE(qsfirst.execution_count, 0))) /
                                                                                            (qstotal.execution_count - qstotalfirst.execution_count) as decimal(6, 2)),
                                                            [Duration]               = qsnow.total_elapsed_time - (COALESCE(qsfirst.total_elapsed_time, 0)),
                                                            [DurationPercent]        = CAST(100.0 *
                                                                                            (qsnow.total_elapsed_time - (COALESCE(qsfirst.total_elapsed_time, 0))) /
                                                                                            (qstotal.total_elapsed_time - qstotalfirst.total_elapsed_time) as decimal(6, 2)),
                                                            [CPU]                    = qsnow.total_worker_time - (COALESCE(qsfirst.total_worker_time, 0)),
                                                            [CPUPercent]             = CAST(100.0 *
                                                                                            (qsnow.total_worker_time - (COALESCE(qsfirst.total_worker_time, 0))) /
                                                                                            (qstotal.total_worker_time - qstotalfirst.total_worker_time) as decimal(6, 2)),
                                                            [Reads]                  = qsnow.total_logical_reads -
                                                                                       (COALESCE(qsfirst.total_logical_reads, 0)),
                                                            [ReadsPercent]           = CAST(100.0 *
                                                                                            (qsnow.total_logical_reads -
                                                                                             (COALESCE(qsfirst.total_logical_reads, 0))) /
                                                                                            (qstotal.total_logical_reads - qstotalfirst.total_logical_reads) as decimal(6, 2)),
                                                            [PlanCreationTime]       = CONVERT(nvarchar(100), qsnow.creation_time, 121),
                                                            [TotalExecutions]        = qsnow.execution_count,
                                                            [TotalExecutionsPercent] = CAST(
                                                                                               100.0 * qsnow.execution_count / qstotal.execution_count as decimal(6, 2)),
                                                            [TotalDuration]          = qsnow.total_elapsed_time,
                                                            [TotalDurationPercent]   = CAST(
                                                                                               100.0 * qsnow.total_elapsed_time / qstotal.total_elapsed_time as decimal(6, 2)),
                                                            [TotalCPU]               = qsnow.total_worker_time,
                                                            [TotalCPUPercent]        = CAST(
                                                                                               100.0 * qsnow.total_worker_time / qstotal.total_worker_time as decimal(6, 2)),
                                                            [TotalReads]             = qsnow.total_logical_reads,
                                                            [TotalReadsPercent]      = CAST(
                                                                                               100.0 * qsnow.total_logical_reads / qstotal.total_logical_reads as decimal(6, 2)),
                                                                                       r.[DetailsInt]
                                                        from #blitzfirstresults r
                                                                 left outer join #querystats qstotal on qstotal.pass = 0
                                                                 left outer join #querystats qstotalfirst on qstotalfirst.pass = -1
                                                                 left outer join #querystats qsnow on r.querystatsnowid = qsnow.id
                                                                 left outer join #querystats qsfirst on r.querystatsfirstid = qsfirst.id
                                                        where (@seconds > 0 or (priority in (0, 250, 251, 255))) /* For @Seconds = 0, filter out broken checks for now */
                                                        order by r.priority,
                                                                 r.findingsgroup,
                                                                 case
                                                                     when r.checkid = 6 then detailsint
                                                                     else 0
                                                                     end desc,
                                                                 r.finding,
                                                                 r.id,
                                                                 CAST(r.details as nvarchar(4000));

                                                    -------------------------
                                                    --What happened: #WaitStats
                                                    -------------------------
                                                    if @seconds = 0
                                                        begin
                                                            /* Measure waits in hours */
                                                            ;
                                                            with max_batch as (
                                                                select MAX(sampletime) as sampletime
                                                                from #waitstats
                                                            )
                                                            select 'WAIT STATS'                                                                   as pattern,
                                                                   b.sampletime                                                                   as [Sample Ended],
                                                                   CAST(
                                                                           DATEDIFF(mi, wd1.sampletime, wd2.sampletime) / 60.0 as decimal(18, 1)) as [Hours Sample],
                                                                   wd1.wait_type,
                                                                   COALESCE(wcat.waitcategory, 'Other')                                           as wait_category,
                                                                   CAST(c.[Wait Time (Seconds)] / 60.0 / 60 as decimal(18, 1))                    as [Wait Time (Hours)],
                                                                   CAST((wd2.wait_time_ms - wd1.wait_time_ms) / 1000.0 /
                                                                        cores.cpu_count /
                                                                        DATEDIFF(ss, wd1.sampletime, wd2.sampletime) as decimal(18, 1))           as [Per Core Per Hour],
                                                                   CAST(c.[Signal Wait Time (Seconds)] / 60.0 / 60 as decimal(18, 1))             as [Signal Wait Time (Hours)],
                                                                   case
                                                                       when c.[Wait Time (Seconds)] > 0
                                                                           then CAST(
                                                                               100. * (c.[Signal Wait Time (Seconds)] / c.[Wait Time (Seconds)]) as numeric(4, 1))
                                                                       else 0 end                                                                 as [Percent Signal Waits],
                                                                   (wd2.waiting_tasks_count - wd1.waiting_tasks_count)                            as [Number of Waits],
                                                                   case
                                                                       when (wd2.waiting_tasks_count - wd1.waiting_tasks_count) > 0
                                                                           then
                                                                           CAST((wd2.wait_time_ms - wd1.wait_time_ms) /
                                                                                (1.0 * (wd2.waiting_tasks_count - wd1.waiting_tasks_count)) as numeric(12, 1))
                                                                       else 0 end                                                                 as [Avg ms Per Wait],
                                                                   N'https://www.sqlskills.com/help/waits/' + LOWER(wd1.wait_type) + '/'          as url
                                                            from max_batch b
                                                                     join #waitstats wd2 on
                                                                wd2.sampletime = b.sampletime
                                                                     join #waitstats wd1 on
                                                                    wd1.wait_type = wd2.wait_type and
                                                                    wd2.sampletime > wd1.sampletime
                                                                     cross apply (select SUM(1) as cpu_count
                                                                                  from sys.dm_os_schedulers
                                                                                  where status = 'VISIBLE ONLINE'
                                                                                    and is_online = 1) as cores
                                                                     cross apply (select CAST(
                                                                                                 (wd2.wait_time_ms - wd1.wait_time_ms) / 1000. as numeric(12, 1))               as [Wait Time (Seconds)],
                                                                                         CAST(
                                                                                                 (wd2.signal_wait_time_ms - wd1.signal_wait_time_ms) / 1000. as numeric(12, 1)) as [Signal Wait Time (Seconds)]) as c
                                                                     left outer join ##waitcategories wcat on wd1.wait_type = wcat.waittype
                                                            where (wd2.waiting_tasks_count - wd1.waiting_tasks_count) > 0
                                                              and wd2.wait_time_ms - wd1.wait_time_ms > 0
                                                            order by [Wait Time (Seconds)] desc;
                                                        end;
                                                    else
                                                        begin
                                                            /* Measure waits in seconds */
                                                            ;
                                                            with max_batch as (
                                                                select MAX(sampletime) as sampletime
                                                                from #waitstats
                                                            )
                                                            select 'WAIT STATS'                                                                as pattern,
                                                                   b.sampletime                                                                as [Sample Ended],
                                                                   DATEDIFF(ss, wd1.sampletime, wd2.sampletime)                                as [Seconds Sample],
                                                                   wd1.wait_type,
                                                                   COALESCE(wcat.waitcategory, 'Other')                                        as wait_category,
                                                                   c.[Wait Time (Seconds)],
                                                                   CAST(
                                                                               (CAST(wd2.wait_time_ms - wd1.wait_time_ms as money)) /
                                                                               1000.0 / cores.cpu_count /
                                                                               DATEDIFF(ss, wd1.sampletime, wd2.sampletime) as decimal(18, 1)) as [Per Core Per Second],
                                                                   c.[Signal Wait Time (Seconds)],
                                                                   case
                                                                       when c.[Wait Time (Seconds)] > 0
                                                                           then CAST(
                                                                               100. * (c.[Signal Wait Time (Seconds)] / c.[Wait Time (Seconds)]) as numeric(4, 1))
                                                                       else 0 end                                                              as [Percent Signal Waits],
                                                                   (wd2.waiting_tasks_count - wd1.waiting_tasks_count)                         as [Number of Waits],
                                                                   case
                                                                       when (wd2.waiting_tasks_count - wd1.waiting_tasks_count) > 0
                                                                           then
                                                                           CAST((wd2.wait_time_ms - wd1.wait_time_ms) /
                                                                                (1.0 * (wd2.waiting_tasks_count - wd1.waiting_tasks_count)) as numeric(12, 1))
                                                                       else 0 end                                                              as [Avg ms Per Wait],
                                                                   N'https://www.sqlskills.com/help/waits/' + LOWER(wd1.wait_type) + '/'       as url
                                                            from max_batch b
                                                                     join #waitstats wd2 on
                                                                wd2.sampletime = b.sampletime
                                                                     join #waitstats wd1 on
                                                                    wd1.wait_type = wd2.wait_type and
                                                                    wd2.sampletime > wd1.sampletime
                                                                     cross apply (select SUM(1) as cpu_count
                                                                                  from sys.dm_os_schedulers
                                                                                  where status = 'VISIBLE ONLINE'
                                                                                    and is_online = 1) as cores
                                                                     cross apply (select CAST(
                                                                                                 (wd2.wait_time_ms - wd1.wait_time_ms) / 1000. as numeric(12, 1))               as [Wait Time (Seconds)],
                                                                                         CAST(
                                                                                                 (wd2.signal_wait_time_ms - wd1.signal_wait_time_ms) / 1000. as numeric(12, 1)) as [Signal Wait Time (Seconds)]) as c
                                                                     left outer join ##waitcategories wcat on wd1.wait_type = wcat.waittype
                                                            where (wd2.waiting_tasks_count - wd1.waiting_tasks_count) > 0
                                                              and wd2.wait_time_ms - wd1.wait_time_ms > 0
                                                            order by [Wait Time (Seconds)] desc;
                                                        end;

                                                    -------------------------
                                                    --What happened: #FileStats
                                                    -------------------------
                                                    with readstats as (
                                                        select 'PHYSICAL READS'                                        as pattern,
                                                               ROW_NUMBER() over (order by wd2.avg_stall_read_ms desc) as stallrank,
                                                               wd2.sampletime                                          as [Sample Time],
                                                               DATEDIFF(ss, wd1.sampletime, wd2.sampletime)            as [Sample (seconds)],
                                                               wd1.databasename,
                                                               wd1.filelogicalname                                     as [File Name],
                                                               UPPER(SUBSTRING(wd1.physicalname, 1, 2))                as [Drive],
                                                               wd1.sizeondiskmb,
                                                               (wd2.num_of_reads - wd1.num_of_reads)                   as [# Reads/Writes],
                                                               case
                                                                   when wd2.num_of_reads - wd1.num_of_reads > 0
                                                                       then CAST(
                                                                           (wd2.bytes_read - wd1.bytes_read) / 1024. / 1024. as numeric(21, 1))
                                                                   else 0
                                                                   end                                                 as [MB Read/Written],
                                                               wd2.avg_stall_read_ms                                   as [Avg Stall (ms)],
                                                               wd1.physicalname                                        as [file physical name]
                                                        from #filestats wd2
                                                                 join #filestats wd1 on wd2.sampletime > wd1.sampletime
                                                            and wd1.databaseid = wd2.databaseid
                                                            and wd1.fileid = wd2.fileid
                                                    ),
                                                         writestats as (
                                                             select 'PHYSICAL WRITES'                                        as pattern,
                                                                    ROW_NUMBER() over (order by wd2.avg_stall_write_ms desc) as stallrank,
                                                                    wd2.sampletime                                           as [Sample Time],
                                                                    DATEDIFF(ss, wd1.sampletime, wd2.sampletime)             as [Sample (seconds)],
                                                                    wd1.databasename,
                                                                    wd1.filelogicalname                                      as [File Name],
                                                                    UPPER(SUBSTRING(wd1.physicalname, 1, 2))                 as [Drive],
                                                                    wd1.sizeondiskmb,
                                                                    (wd2.num_of_writes - wd1.num_of_writes)                  as [# Reads/Writes],
                                                                    case
                                                                        when wd2.num_of_writes - wd1.num_of_writes > 0
                                                                            then CAST(
                                                                                (wd2.bytes_written - wd1.bytes_written) / 1024. / 1024. as numeric(21, 1))
                                                                        else 0
                                                                        end                                                  as [MB Read/Written],
                                                                    wd2.avg_stall_write_ms                                   as [Avg Stall (ms)],
                                                                    wd1.physicalname                                         as [file physical name]
                                                             from #filestats wd2
                                                                      join #filestats wd1
                                                                           on wd2.sampletime > wd1.sampletime
                                                                               and wd1.databaseid = wd2.databaseid
                                                                               and wd1.fileid = wd2.fileid
                                                         )
                                                    select pattern,
                                                           [Sample Time],
                                                           [Sample (seconds)],
                                                           [File Name],
                                                           [Drive],
                                                           [# Reads/Writes],
                                                           [MB Read/Written],
                                                           [Avg Stall (ms)],
                                                           [file physical name]
                                                    from readstats
                                                    where stallrank <= 5
                                                      and [MB Read/Written] > 0
                                                    union all
                                                    select pattern,
                                                           [Sample Time],
                                                           [Sample (seconds)],
                                                           [File Name],
                                                           [Drive],
                                                           [# Reads/Writes],
                                                           [MB Read/Written],
                                                           [Avg Stall (ms)],
                                                           [file physical name]
                                                    from writestats
                                                    where stallrank <= 5
                                                      and [MB Read/Written] > 0;


                                                    -------------------------
                                                    --What happened: #PerfmonStats
                                                    -------------------------

                                                    select 'PERFMON'                                           as pattern,
                                                           plast.[object_name],
                                                           plast.counter_name,
                                                           plast.instance_name,
                                                           pfirst.sampletime                                   as firstsampletime,
                                                           pfirst.cntr_value                                   as firstsamplevalue,
                                                           plast.sampletime                                    as lastsampletime,
                                                           plast.cntr_value                                    as lastsamplevalue,
                                                           plast.cntr_value - pfirst.cntr_value                as valuedelta,
                                                           ((1.0 * plast.cntr_value - pfirst.cntr_value) /
                                                            DATEDIFF(ss, pfirst.sampletime, plast.sampletime)) as valuepersecond
                                                    from #perfmonstats plast
                                                             inner join #perfmonstats pfirst
                                                                        on pfirst.[object_name] = plast.[object_name] and
                                                                           pfirst.counter_name = plast.counter_name and
                                                                           (pfirst.instance_name = plast.instance_name or
                                                                            (pfirst.instance_name is null and plast.instance_name is null))
                                                                            and plast.id > pfirst.id
                                                    where plast.cntr_value <> pfirst.cntr_value
                                                    order by pattern, plast.[object_name], plast.counter_name,
                                                             plast.instance_name;


                                                    -------------------------
                                                    --What happened: #QueryStats
                                                    -------------------------
                                                    if @checkprocedurecache = 1
                                                        begin

                                                            select qsnow.*, qsfirst.*
                                                            from #querystats qsnow
                                                                     inner join #querystats qsfirst
                                                                                on qsnow.[sql_handle] = qsfirst.[sql_handle] and
                                                                                   qsnow.statement_start_offset = qsfirst.statement_start_offset and
                                                                                   qsnow.statement_end_offset = qsfirst.statement_end_offset and
                                                                                   qsnow.plan_generation_num = qsfirst.plan_generation_num and
                                                                                   qsnow.plan_handle = qsfirst.plan_handle and
                                                                                   qsfirst.pass = 1
                                                            where qsnow.pass = 2;
                                                        end;
                                                    else
                                                        begin
                                                            select 'Plan Cache'                                                                 as [Pattern],
                                                                   'Plan cache not analyzed'                                                    as [Finding],
                                                                   'Use @CheckProcedureCache = 1 or run sp_BlitzCache for more analysis'        as [More Info],
                                                                   CONVERT(xml,
                                                                           @stockdetailsheader + 'firstresponderkit.org' + @stockdetailsfooter) as [Details];
                                                        end;
                                                end;

                    drop table #blitzfirstresults;

                    /* What's running right now? This is the first and last result set. */
                    if @sincestartup = 0 and @seconds > 0 and @expertmode = 1 and @outputtype <> 'NONE'
                        begin
                            if OBJECT_ID('master.dbo.sp_BlitzWho') is null and OBJECT_ID('dbo.sp_BlitzWho') is null
                                begin
                                    print N'sp_BlitzWho is not installed in the current database_files.  You can get a copy from http://FirstResponderKit.org';
                                end;
                            else
                                begin
                                    exec (@blitzwho);
                                end;
                        end; /* IF @SinceStartup = 0 AND @Seconds > 0 AND @ExpertMode = 1 AND @OutputType <> 'NONE'   -   What's running right now? This is the first and last result set. */

                end; /* IF @LogMessage IS NULL */
end; /* ELSE IF @OutputType = 'SCHEMA' */

    set nocount off;
go



/* How to run it:
EXEC dbo.sp_BlitzFirst

With extra diagnostic info:
EXEC dbo.sp_BlitzFirst @ExpertMode = 1;

Saving output to tables:
EXEC sp_BlitzFirst
  @OutputDatabaseName = 'DBAtools'
, @OutputSchemaName = 'dbo'
, @OutputTableName = 'BlitzFirst'
, @OutputTableNameFileStats = 'BlitzFirst_FileStats'
, @OutputTableNamePerfmonStats = 'BlitzFirst_PerfmonStats'
, @OutputTableNameWaitStats = 'BlitzFirst_WaitStats'
, @OutputTableNameBlitzCache = 'BlitzCache'
, @OutputTableNameBlitzWho = 'BlitzWho'
*/
set ansi_nulls on;
set ansi_padding on;
set ansi_warnings on;
set arithabort on;
set concat_null_yields_null on;
set quoted_identifier on;
set statistics io off;
set statistics time off;
go

if OBJECT_ID('dbo.sp_BlitzIndex') is null
    exec ('CREATE PROCEDURE dbo.sp_BlitzIndex AS RETURN 0;');
go

alter procedure dbo.sp_blitzindex @databasename nvarchar(128) = null, /*Defaults to current DB if not specified*/
                                  @schemaname nvarchar(128) = null, /*Requires table_name as well.*/
                                  @tablename nvarchar(128) = null, /*Requires schema_name as well.*/
                                  @mode tinyint=0, /*0=Diagnose, 1=Summarize, 2=Index Usage Detail, 3=Missing Index Detail, 4=Diagnose Details*/
    /*Note:@Mode doesn't matter if you're specifying schema_name and @TableName.*/
                                  @filter tinyint = 0, /* 0=no filter (default). 1=No low-usage warnings for objects with 0 reads. 2=Only warn for objects >= 500MB */
    /*Note:@Filter doesn't do anything unless @Mode=0*/
                                  @skippartitions bit = 0,
                                  @skipstatistics bit = 1,
                                  @getalldatabases bit = 0,
                                  @bringthepain bit = 0,
                                  @ignoredatabases nvarchar(max) = null, /* Comma-delimited list of databases you want to skip */
                                  @thresholdmb int = 250 /* Number of megabytes that an object must be before we include it in basic results */,
                                  @outputtype varchar(20) = 'TABLE',
                                  @outputservername nvarchar(256) = null,
                                  @outputdatabasename nvarchar(256) = null,
                                  @outputschemaname nvarchar(256) = null,
                                  @outputtablename nvarchar(256) = null,
                                  @includeinactiveindexes bit = 0 /* Will skip indexes with no reads or writes */,
                                  @help tinyint = 0,
                                  @debug bit = 0,
                                  @version varchar(30) = null output,
                                  @versiondate datetime = null output,
                                  @versioncheckmode bit = 0
    with recompile
as
    set nocount on;
    set transaction isolation level read uncommitted;

select @version = '7.97', @versiondate = '20200712';
    set @outputtype = UPPER(@outputtype);

    if (@versioncheckmode = 1)
        begin
            return;
        end;

    if @help = 1
        print '
/*
sp_BlitzIndex from http://FirstResponderKit.org

This script analyzes the design and performance of your indexes.

To learn more, visit http://FirstResponderKit.org where you can download new
versions for free, watch training videos on how it works, get more info on
the findings, contribute your own code, and more.

Known limitations of this version:
 - Only Microsoft-supported versions of SQL Server. Sorry, 2005 and 2000.
 - The @OutputDatabaseName parameters are not functional yet. To check the
   status of this enhancement request, visit:
   https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/221
 - Does not analyze columnstore, spatial, XML, or full text indexes. If you
   would like to contribute code to analyze those, head over to Github and
   check out the issues list: http://FirstResponderKit.org
 - Index create statements are just to give you a rough idea of the syntax. It includes filters and fillfactor.
 --        Example 1: index creates use ONLINE=? instead of ONLINE=ON / ONLINE=OFF. This is because it is important
           for the user to understand if it is going to be offline and not just run a script.
 --        Example 2: they do not include all the options the index may have been created with (padding, compression
           filegroup/partition scheme etc.)
 --        (The compression and filegroup index create syntax is not trivial because it is set at the partition
           level and is not trivial to code.)
 - Does not advise you about data modeling for clustered indexes and primary keys (primarily looks for signs of insanity.)

Unknown limitations of this version:
 - We knew them once, but we forgot.


MIT License

Copyright (c) 2020 Brent Ozar Unlimited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
';


declare @scriptversionname nvarchar(50);
declare @daysuptime numeric(23, 2);
declare @databaseid int;
declare @objectid int;
declare @dsql nvarchar(max);
declare @params nvarchar(max);
declare @msg nvarchar(4000);
declare @errorseverity int;
declare @errorstate int;
declare @rowcount bigint;
declare @sqlserverproductversion nvarchar(128);
declare @sqlserveredition int;
declare @filtermb int;
declare @collation nvarchar(256);
declare @numdatabases int;
declare @linefeed nvarchar(5);
declare @daysuptimeinsertvalue nvarchar(256);
declare @databasetoignore nvarchar(max);

    set @linefeed = CHAR(13) + CHAR(10);
select @sqlserverproductversion = CAST(SERVERPROPERTY('ProductVersion') as nvarchar(128));
select @sqlserveredition = CAST(SERVERPROPERTY('EngineEdition') as int); /* We default to online index creates where EngineEdition=3*/
    set @filtermb = 250;
select @scriptversionname = 'sp_BlitzIndex(TM) v' + @version + ' - ' + DATENAME(mm, @versiondate) + ' ' +
                            RIGHT('0' + DATENAME(dd, @versiondate), 2) + ', ' + DATENAME(yy, @versiondate);
    set @ignoredatabases = REPLACE(REPLACE(LTRIM(RTRIM(@ignoredatabases)), CHAR(10), ''), CHAR(13), '');

    raiserror (N'Starting run. %s', 0,1, @scriptversionname) with nowait;

    if (@outputtype not in ('TABLE', 'NONE'))
        begin
            raiserror ('Invalid value for parameter @OutputType. Expected: (TABLE;NONE)',12,1);
            return;
        end;

    if (@outputtype = 'NONE')
        begin
            if (@outputtablename is null or @outputschemaname is null or @outputdatabasename is null)
                begin
                    raiserror ('This procedure should be called with a value for @Output* parameters, as @OutputType is set to NONE',12,1);
                    return;
                end;
            if (@bringthepain = 1)
                begin
                    raiserror ('Incompatible Parameters: @BringThePain set to 1 and @OutputType set to NONE',12,1);
                    return;
                end;
            /* Eventually limit by mode
    IF(@Mode not in (0,4))
	BEGIN
        RAISERROR('Incompatible Parameters: @Mode set to %d and @OutputType set to NONE',12,1,@Mode);
        RETURN;
	END;
	*/
        end;

    if OBJECT_ID('tempdb..#IndexSanity') is not null
        drop table #indexsanity;

    if OBJECT_ID('tempdb..#IndexPartitionSanity') is not null
        drop table #indexpartitionsanity;

    if OBJECT_ID('tempdb..#IndexSanitySize') is not null
        drop table #indexsanitysize;

    if OBJECT_ID('tempdb..#IndexColumns') is not null
        drop table #indexcolumns;

    if OBJECT_ID('tempdb..#MissingIndexes') is not null
        drop table #missingindexes;

    if OBJECT_ID('tempdb..#ForeignKeys') is not null
        drop table #foreignkeys;

    if OBJECT_ID('tempdb..#BlitzIndexResults') is not null
        drop table #blitzindexresults;

    if OBJECT_ID('tempdb..#IndexCreateTsql') is not null
        drop table #indexcreatetsql;

    if OBJECT_ID('tempdb..#DatabaseList') is not null
        drop table #databaselist;

    if OBJECT_ID('tempdb..#Statistics') is not null
        drop table #statistics;

    if OBJECT_ID('tempdb..#PartitionCompressionInfo') is not null
        drop table #partitioncompressioninfo;

    if OBJECT_ID('tempdb..#ComputedColumns') is not null
        drop table #computedcolumns;

    if OBJECT_ID('tempdb..#TraceStatus') is not null
        drop table #tracestatus;

    if OBJECT_ID('tempdb..#TemporalTables') is not null
        drop table #temporaltables;

    if OBJECT_ID('tempdb..#CheckConstraints') is not null
        drop table #checkconstraints;

    if OBJECT_ID('tempdb..#FilteredIndexes') is not null
        drop table #filteredindexes;

    if OBJECT_ID('tempdb..#Ignore_Databases') is not null
        drop table #ignore_databases

    raiserror (N'Create temp tables.',0,1) with nowait;
    create table #blitzindexresults
    (
        blitz_result_id int identity primary key,
        check_id int not null,
        index_sanity_id int null,
        priority int null,
        findings_group nvarchar(4000) not null,
        finding nvarchar(200) not null,
        [database_name] nvarchar(128) null,
        url nvarchar(200) not null,
        details nvarchar(max) not null,
        index_definition nvarchar(max) not null,
        secret_columns nvarchar(max) null,
        index_usage_summary nvarchar(max) null,
        index_size_summary nvarchar(max) null,
        create_tsql nvarchar(max) null,
        more_info nvarchar(max) null
    );

    create table #indexsanity
    (
        [index_sanity_id] int identity primary key clustered,
        [database_id] smallint not null,
        [object_id] int not null,
        [index_id] int not null,
        [index_type] tinyint not null,
        [database_name] nvarchar(128) not null,
        [schema_name] nvarchar(128) not null,
        [object_name] nvarchar(128) not null,
        index_name nvarchar(128) null,
        key_column_names nvarchar(max) null,
        key_column_names_with_sort_order nvarchar(max) null,
        key_column_names_with_sort_order_no_types nvarchar(max) null,
        count_key_columns int null,
        include_column_names nvarchar(max) null,
        include_column_names_no_types nvarchar(max) null,
        count_included_columns int null,
        partition_key_column_name nvarchar(max) null,
        filter_definition nvarchar(max) not null,
        is_indexed_view bit not null,
        is_unique bit not null,
        is_primary_key bit not null,
        is_xml bit not null,
        is_spatial bit not null,
        is_nc_columnstore bit not null,
        is_cx_columnstore bit not null,
        is_in_memory_oltp bit not null,
        is_disabled bit not null,
        is_hypothetical bit not null,
        is_padded bit not null,
        fill_factor smallint not null,
        user_seeks bigint not null,
        user_scans bigint not null,
        user_lookups bigint not null,
        user_updates bigint null,
        last_user_seek datetime null,
        last_user_scan datetime null,
        last_user_lookup datetime null,
        last_user_update datetime null,
        is_referenced_by_foreign_key bit default (0),
        secret_columns nvarchar(max) null,
        count_secret_columns int null,
        create_date datetime not null,
        modify_date datetime not null,
        filter_columns_not_in_index nvarchar(max),
        [db_schema_object_name] as [schema_name] + N'.' + [object_name],
        [db_schema_object_indexid] as [schema_name] + N'.' + [object_name]
            + case
                  when [index_name] is not null then N'.' + index_name
                  else N''
                                          end + N' (' + CAST(index_id as nvarchar(20)) + N')',
        first_key_column_name as case
                                     when count_key_columns > 1
                                         then LEFT(key_column_names, CHARINDEX(',', key_column_names, 0) - 1)
                                     else key_column_names
            end,
        index_definition as
                case
                    when partition_key_column_name is not null
                        then N'[PARTITIONED BY:' + partition_key_column_name + N']'
                    else ''
                    end +
                case index_id
                    when 0 then N'[HEAP] '
                    when 1 then N'[CX] '
                    else N'' end + case
                                       when is_indexed_view = 1 then N'[VIEW] '
                                       else N'' end + case
                                                          when is_primary_key = 1 then N'[PK] '
                                                          else N'' end + case
                                                                             when is_xml = 1 then N'[XML] '
                                                                             else N'' end + case
                                                                                                when is_spatial = 1
                                                                                                    then N'[SPATIAL] '
                                                                                                else N'' end + case
                                                                                                                   when is_nc_columnstore = 1
                                                                                                                       then N'[COLUMNSTORE] '
                                                                                                                   else N'' end +
                case
                    when is_in_memory_oltp = 1 then N'[IN-MEMORY] '
                    else N'' end + case
                                       when is_disabled = 1 then N'[DISABLED] '
                                       else N'' end + case
                                                          when is_hypothetical = 1 then N'[HYPOTHETICAL] '
                                                          else N'' end + case
                                                                             when is_unique = 1 and is_primary_key = 0
                                                                                 then N'[UNIQUE] '
                                                                             else N'' end + case
                                                                                                when count_key_columns > 0
                                                                                                    then
                                                                                                        N'[' +
                                                                                                        CAST(count_key_columns as nvarchar(10)) +
                                                                                                        N' KEY'
                                                                                                        +
                                                                                                        case when count_key_columns > 1 then N'S' else N'' end
                                                                                                        + N'] ' +
                                                                                                        LTRIM(key_column_names_with_sort_order)
                                                                                                else N'' end + case
                                                                                                                   when count_included_columns > 0
                                                                                                                       then
                                                                                                                           N' [' +
                                                                                                                           CAST(count_included_columns as nvarchar(10)) +
                                                                                                                           N' INCLUDE' +
                                                                                                                           + case when count_included_columns > 1 then N'S' else N'' end
                                                                                                                           +
                                                                                                                           N'] ' +
                                                                                                                           include_column_names
                                                                                                                   else N'' end +
                case
                    when filter_definition <> N'' then N' [FILTER] ' + filter_definition
                    else N'' end,
        [total_reads] as user_seeks + user_scans + user_lookups,
        [reads_per_write] as CAST(case
                                      when user_updates > 0
                                          then (user_seeks + user_scans + user_lookups) / (1.0 * user_updates)
                                      else 0 end as money),
        [index_usage_summary] as N'Reads: ' +
                                 REPLACE(CONVERT(nvarchar(30), CAST((user_seeks + user_scans + user_lookups) as money),
                                                               1), N'.00', N'')
            + case
                  when user_seeks + user_scans + user_lookups > 0 then
                          N' ('
                          + RTRIM(
                                      case
                                          when user_seeks > 0 then
                                                  REPLACE(CONVERT(nvarchar(30), CAST((user_seeks) as money), 1), N'.00',
                                                          N'') + N' seek '
                                          else N'' end
                                      + case
                                            when user_scans > 0 then
                                                    REPLACE(CONVERT(nvarchar(30), CAST((user_scans) as money), 1),
                                                            N'.00', N'') + N' scan '
                                            else N'' end
                                      + case
                                            when user_lookups > 0 then
                                                    REPLACE(CONVERT(nvarchar(30), CAST((user_lookups) as money), 1),
                                                            N'.00', N'') + N' lookup'
                                            else N'' end
                              )
                          + N') '
                  else N' ' end
            + N'Writes:' +
                                 REPLACE(CONVERT(nvarchar(30), CAST(user_updates as money), 1), N'.00', N''),
        [more_info] as
            case
                when is_in_memory_oltp = 1
                    then N'EXEC dbo.sp_BlitzInMemoryOLTP @dbName=' + QUOTENAME([database_name], N'''') +
                         N', @tableName=' + QUOTENAME([object_name], N'''') + N';'
                else N'EXEC dbo.sp_BlitzIndex @DatabaseName=' + QUOTENAME([database_name], N'''') +
                     N', @SchemaName=' + QUOTENAME([schema_name], N'''') + N', @TableName=' +
                     QUOTENAME([object_name], N'''') + N';' end
    );
    raiserror (N'Adding UQ index on #IndexSanity (database_id, object_id, index_id)',0,1) with nowait;
    if not EXISTS(select 1
                  from tempdb.sys.indexes
                  where name = 'uq_database_id_object_id_index_id')
    create unique index uq_database_id_object_id_index_id on #indexsanity (database_id, object_id, index_id);


    create table #indexpartitionsanity
    (
        [index_partition_sanity_id] int identity,
        [index_sanity_id] int null,
        [database_id] int not null,
        [object_id] int not null,
        [schema_name] nvarchar(128) not null,
        [index_id] int not null,
        [partition_number] int not null,
        row_count bigint not null,
        reserved_mb numeric(29, 2) not null,
        reserved_lob_mb numeric(29, 2) not null,
        reserved_row_overflow_mb numeric(29, 2) not null,
        leaf_insert_count bigint null,
        leaf_delete_count bigint null,
        leaf_update_count bigint null,
        range_scan_count bigint null,
        singleton_lookup_count bigint null,
        forwarded_fetch_count bigint null,
        lob_fetch_in_pages bigint null,
        lob_fetch_in_bytes bigint null,
        row_overflow_fetch_in_pages bigint null,
        row_overflow_fetch_in_bytes bigint null,
        row_lock_count bigint null,
        row_lock_wait_count bigint null,
        row_lock_wait_in_ms bigint null,
        page_lock_count bigint null,
        page_lock_wait_count bigint null,
        page_lock_wait_in_ms bigint null,
        index_lock_promotion_attempt_count bigint null,
        index_lock_promotion_count bigint null,
        data_compression_desc nvarchar(60) null,
        page_latch_wait_count bigint null,
        page_latch_wait_in_ms bigint null,
        page_io_latch_wait_count bigint null,
        page_io_latch_wait_in_ms bigint null
    );

    create table #indexsanitysize
    (
        [index_sanity_size_id] int identity not null,
        [index_sanity_id] int null,
        [database_id] int not null,
        [schema_name] nvarchar(128) not null,
        partition_count int not null,
        total_rows bigint not null,
        total_reserved_mb numeric(29, 2) not null,
        total_reserved_lob_mb numeric(29, 2) not null,
        total_reserved_row_overflow_mb numeric(29, 2) not null,
        total_leaf_delete_count bigint null,
        total_leaf_update_count bigint null,
        total_range_scan_count bigint null,
        total_singleton_lookup_count bigint null,
        total_forwarded_fetch_count bigint null,
        total_row_lock_count bigint null,
        total_row_lock_wait_count bigint null,
        total_row_lock_wait_in_ms bigint null,
        avg_row_lock_wait_in_ms bigint null,
        total_page_lock_count bigint null,
        total_page_lock_wait_count bigint null,
        total_page_lock_wait_in_ms bigint null,
        avg_page_lock_wait_in_ms bigint null,
        total_index_lock_promotion_attempt_count bigint null,
        total_index_lock_promotion_count bigint null,
        data_compression_desc nvarchar(4000) null,
        page_latch_wait_count bigint null,
        page_latch_wait_in_ms bigint null,
        page_io_latch_wait_count bigint null,
        page_io_latch_wait_in_ms bigint null,
        index_size_summary as ISNULL(
                    case
                        when partition_count > 1
                            then N'[' + CAST(partition_count as nvarchar(10)) + N' PARTITIONS] '
                        else N''
                        end + REPLACE(CONVERT(nvarchar(30), CAST([total_rows] as money), 1), N'.00', N'') + N' rows; '
                    + case
                          when total_reserved_mb > 1024 then
                                  CAST(CAST(total_reserved_mb / 1024. as numeric(29, 1)) as nvarchar(30)) + N'GB'
                          else
                                  CAST(CAST(total_reserved_mb as numeric(29, 1)) as nvarchar(30)) + N'MB'
                        end
                    + case
                          when total_reserved_lob_mb > 1024 then
                                  N'; ' + CAST(CAST(total_reserved_lob_mb / 1024. as numeric(29, 1)) as nvarchar(30)) +
                                  N'GB LOB'
                          when total_reserved_lob_mb > 0 then
                                  N'; ' + CAST(CAST(total_reserved_lob_mb as numeric(29, 1)) as nvarchar(30)) +
                                  N'MB LOB'
                          else ''
                        end
                    + case
                          when total_reserved_row_overflow_mb > 1024 then
                                  N'; ' +
                                  CAST(CAST(total_reserved_row_overflow_mb / 1024. as numeric(29, 1)) as nvarchar(30)) +
                                  N'GB Row Overflow'
                          when total_reserved_row_overflow_mb > 0 then
                                  N'; ' + CAST(CAST(total_reserved_row_overflow_mb as numeric(29, 1)) as nvarchar(30)) +
                                  N'MB Row Overflow'
                          else ''
                        end,
                    N'Error- NULL in computed column'),
        index_op_stats as ISNULL(
                (
                        REPLACE(CONVERT(nvarchar(30), CAST(total_singleton_lookup_count as money), 1), N'.00', N'') +
                        N' singleton lookups; '
                        + REPLACE(CONVERT(nvarchar(30), CAST(total_range_scan_count as money), 1), N'.00', N'') +
                        N' scans/seeks; '
                        + REPLACE(CONVERT(nvarchar(30), CAST(total_leaf_delete_count as money), 1), N'.00', N'') +
                        N' deletes; '
                        + REPLACE(CONVERT(nvarchar(30), CAST(total_leaf_update_count as money), 1), N'.00', N'') +
                        N' updates; '
                        + case
                              when ISNULL(total_forwarded_fetch_count, 0) > 0 then
                                      REPLACE(CONVERT(nvarchar(30), CAST(total_forwarded_fetch_count as money), 1),
                                              N'.00', N'') + N' forward records fetched; '
                              else N'' end

                    /* rows will only be in this dmv when data is in memory for the table */
                    ), N'Table metadata not in memory'),
        index_lock_wait_summary as ISNULL(
                case
                    when total_row_lock_wait_count = 0 and total_page_lock_wait_count = 0 and
                         total_index_lock_promotion_attempt_count = 0 then N'0 lock waits.'
                    else
                            case
                                when total_row_lock_wait_count > 0 then
                                        N'Row lock waits: ' +
                                        REPLACE(CONVERT(nvarchar(30), CAST(total_row_lock_wait_count as money), 1),
                                                N'.00', N'')
                                        + N'; total duration: ' +
                                        case
                                            when total_row_lock_wait_in_ms >= 60000 then /*More than 1 min*/
                                                    REPLACE(CONVERT(nvarchar(30),
                                                                    CAST((total_row_lock_wait_in_ms / 60000) as money),
                                                                    1), N'.00', N'') + N' minutes; '
                                            else
                                                    REPLACE(CONVERT(nvarchar(30),
                                                                    CAST(ISNULL(total_row_lock_wait_in_ms / 1000, 0) as money),
                                                                    1), N'.00', N'') + N' seconds; '
                                            end
                                        + N'avg duration: ' +
                                        case
                                            when avg_row_lock_wait_in_ms >= 60000 then /*More than 1 min*/
                                                    REPLACE(CONVERT(nvarchar(30),
                                                                    CAST((avg_row_lock_wait_in_ms / 60000) as money),
                                                                    1), N'.00', N'') + N' minutes; '
                                            else
                                                    REPLACE(CONVERT(nvarchar(30),
                                                                    CAST(ISNULL(avg_row_lock_wait_in_ms / 1000, 0) as money),
                                                                    1), N'.00', N'') + N' seconds; '
                                            end
                                else N''
                                end +
                            case
                                when total_page_lock_wait_count > 0 then
                                        N'Page lock waits: ' +
                                        REPLACE(CONVERT(nvarchar(30), CAST(total_page_lock_wait_count as money), 1),
                                                N'.00', N'')
                                        + N'; total duration: ' +
                                        case
                                            when total_page_lock_wait_in_ms >= 60000 then /*More than 1 min*/
                                                    REPLACE(CONVERT(nvarchar(30),
                                                                    CAST((total_page_lock_wait_in_ms / 60000) as money),
                                                                    1), N'.00', N'') + N' minutes; '
                                            else
                                                    REPLACE(CONVERT(nvarchar(30),
                                                                    CAST(ISNULL(total_page_lock_wait_in_ms / 1000, 0) as money),
                                                                    1), N'.00', N'') + N' seconds; '
                                            end
                                        + N'avg duration: ' +
                                        case
                                            when avg_page_lock_wait_in_ms >= 60000 then /*More than 1 min*/
                                                    REPLACE(CONVERT(nvarchar(30),
                                                                    CAST((avg_page_lock_wait_in_ms / 60000) as money),
                                                                    1), N'.00', N'') + N' minutes; '
                                            else
                                                    REPLACE(CONVERT(nvarchar(30),
                                                                    CAST(ISNULL(avg_page_lock_wait_in_ms / 1000, 0) as money),
                                                                    1), N'.00', N'') + N' seconds; '
                                            end
                                else N''
                                end +
                            case
                                when total_index_lock_promotion_attempt_count > 0 then
                                        N'Lock escalation attempts: ' + REPLACE(CONVERT(nvarchar(30),
                                                                                        CAST(total_index_lock_promotion_attempt_count as money),
                                                                                        1), N'.00', N'')
                                        + N'; Actual Escalations: ' + REPLACE(CONVERT(nvarchar(30),
                                                                                      CAST(ISNULL(total_index_lock_promotion_count, 0) as money),
                                                                                      1), N'.00', N'') + N'.'
                                else N''
                                end
                    end
            , 'Error- NULL in computed column')
    );

    create table #indexcolumns
    (
        [database_id] int not null,
        [schema_name] nvarchar(128),
        [object_id] int not null,
        [index_id] int not null,
        [key_ordinal] int null,
        is_included_column bit null,
        is_descending_key bit null,
        [partition_ordinal] int null,
        column_name nvarchar(256) not null,
        system_type_name nvarchar(256) not null,
        max_length smallint not null,
        [precision] tinyint not null,
        [scale] tinyint not null,
        collation_name nvarchar(256) null,
        is_nullable bit null,
        is_identity bit null,
        is_computed bit null,
        is_replicated bit null,
        is_sparse bit null,
        is_filestream bit null,
        seed_value decimal(38, 0) null,
        increment_value decimal(38, 0) null,
        last_value decimal(38, 0) null,
        is_not_for_replication bit null
    );
    create clustered index clix_database_id_object_id_index_id on #indexcolumns
        (database_id, object_id, index_id);

    create table #missingindexes
    (
        [database_id] int not null,
        [object_id] int not null,
        [database_name] nvarchar(128) not null,
        [schema_name] nvarchar(128) not null,
        [table_name] nvarchar(128),
        [statement] nvarchar(512) not null,
        magic_benefit_number as ((user_seeks + user_scans) * avg_total_user_cost * avg_user_impact),
        avg_total_user_cost numeric(29, 4) not null,
        avg_user_impact numeric(29, 1) not null,
        user_seeks bigint not null,
        user_scans bigint not null,
        unique_compiles bigint null,
        equality_columns nvarchar(4000),
        inequality_columns nvarchar(4000),
        included_columns nvarchar(4000),
        is_low bit,
        [index_estimated_impact] as
                REPLACE(CONVERT(nvarchar(256), CAST(CAST(
                        (user_seeks + user_scans)
                    as bigint) as money), 1), '.00', '') + N' use'
                + case when (user_seeks + user_scans) > 1 then N's' else N'' end
                + N'; Impact: ' + CAST(avg_user_impact as nvarchar(30))
                + N'%; Avg query cost: '
                + CAST(avg_total_user_cost as nvarchar(30)),
        [missing_index_details] as
                case
                    when equality_columns is not null then N'EQUALITY: ' + equality_columns + N' '
                    else N''
                    end + case
                              when inequality_columns is not null then N'INEQUALITY: ' + inequality_columns + N' '
                              else N''
                    end + case
                              when included_columns is not null then N'INCLUDES: ' + included_columns + N' '
                              else N''
                    end,
        [create_tsql] as N'CREATE INDEX ['
            + REPLACE(REPLACE(REPLACE(REPLACE(
                                                  ISNULL(equality_columns, N'') +
                                                  case
                                                      when equality_columns is not null and inequality_columns is not null
                                                          then N'_'
                                                      else N'' end
                                                  + ISNULL(inequality_columns, ''), ',', '')
                                  , '[', ''), ']', ''), ' ', '_')
            + case when included_columns is not null then N'_Includes' else N'' end + N'] ON '
            + [statement] + N' (' + ISNULL(equality_columns, N'')
            + case when equality_columns is not null and inequality_columns is not null then N', ' else N'' end
            + case when inequality_columns is not null then inequality_columns else N'' end +
                         ') ' + case
                                    when included_columns is not null then N' INCLUDE (' + included_columns + N')'
                                    else N'' end
            + N' WITH ('
            + N'FILLFACTOR=100, ONLINE=?, SORT_IN_TEMPDB=?, DATA_COMPRESSION=?'
            + N')'
            + N';',
        [more_info] as N'EXEC dbo.sp_BlitzIndex @DatabaseName=' + QUOTENAME([database_name], '''') +
                       N', @SchemaName=' + QUOTENAME([schema_name], '''') + N', @TableName=' +
                       QUOTENAME([table_name], '''') + N';'
    );

    create table #foreignkeys
    (
        [database_id] int not null,
        [database_name] nvarchar(128) not null,
        [schema_name] nvarchar(128) not null,
        foreign_key_name nvarchar(256),
        parent_object_id int,
        parent_object_name nvarchar(256),
        referenced_object_id int,
        referenced_object_name nvarchar(256),
        is_disabled bit,
        is_not_trusted bit,
        is_not_for_replication bit,
        parent_fk_columns nvarchar(max),
        referenced_fk_columns nvarchar(max),
        update_referential_action_desc nvarchar(16),
        delete_referential_action_desc nvarchar(60)
    );

    create table #indexcreatetsql
    (
        index_sanity_id int not null,
        create_tsql nvarchar(max) not null
    );

    create table #databaselist
    (
        databasename nvarchar(256),
        secondary_role_allow_connections_desc nvarchar(50)

    );

    create table #partitioncompressioninfo
    (
        [index_sanity_id] int null,
        [partition_compression_detail] nvarchar(4000) null
    );

    create table #statistics
    (
        database_id int not null,
        database_name nvarchar(256) not null,
        table_name nvarchar(128) null,
        schema_name nvarchar(128) null,
        index_name nvarchar(128) null,
        column_names nvarchar(max) null,
        statistics_name nvarchar(128) null,
        last_statistics_update datetime null,
        days_since_last_stats_update int null,
        rows bigint null,
        rows_sampled bigint null,
        percent_sampled decimal(18, 1) null,
        histogram_steps int null,
        modification_counter bigint null,
        percent_modifications decimal(18, 1) null,
        modifications_before_auto_update int null,
        index_type_desc nvarchar(128) null,
        table_create_date datetime null,
        table_modify_date datetime null,
        no_recompute bit null,
        has_filter bit null,
        filter_definition nvarchar(max) null
    );

    create table #computedcolumns
    (
        index_sanity_id int identity (1, 1) not null,
        database_name nvarchar(128) null,
        database_id int not null,
        table_name nvarchar(128) not null,
        schema_name nvarchar(128) not null,
        column_name nvarchar(128) null,
        is_nullable bit null,
        definition nvarchar(max) null,
        uses_database_collation bit not null,
        is_persisted bit not null,
        is_computed bit not null,
        is_function int not null,
        column_definition nvarchar(max) null
    );

    create table #tracestatus
    (
        traceflag nvarchar(10),
        status bit,
        global bit,
        session bit
    );

    create table #temporaltables
    (
        index_sanity_id int identity (1, 1) not null,
        database_name nvarchar(128) not null,
        database_id int not null,
        schema_name nvarchar(128) not null,
        table_name nvarchar(128) not null,
        history_table_name nvarchar(128) not null,
        history_schema_name nvarchar(128) not null,
        start_column_name nvarchar(128) not null,
        end_column_name nvarchar(128) not null,
        period_name nvarchar(128) not null
    );

    create table #checkconstraints
    (
        index_sanity_id int identity (1, 1) not null,
        database_name nvarchar(128) null,
        database_id int not null,
        table_name nvarchar(128) not null,
        schema_name nvarchar(128) not null,
        constraint_name nvarchar(128) null,
        is_disabled bit null,
        definition nvarchar(max) null,
        uses_database_collation bit not null,
        is_not_trusted bit not null,
        is_function int not null,
        column_definition nvarchar(max) null
    );

    create table #filteredindexes
    (
        index_sanity_id int identity (1, 1) not null,
        database_name nvarchar(128) null,
        database_id int not null,
        schema_name nvarchar(128) not null,
        table_name nvarchar(128) not null,
        index_name nvarchar(128) null,
        column_name nvarchar(128) null
    );

    create table #ignore_databases
    (
        databasename nvarchar(128),
        reason nvarchar(100)
    );

/* Sanitize our inputs */
select @outputservername = QUOTENAME(@outputservername),
       @outputdatabasename = QUOTENAME(@outputdatabasename),
       @outputschemaname = QUOTENAME(@outputschemaname),
       @outputtablename = QUOTENAME(@outputtablename);


    if @getalldatabases = 1
        begin
            insert into #databaselist (databasename)
            select DB_NAME(database_id)
            from sys.databases
            where user_access_desc = 'MULTI_USER'
              and state_desc = 'ONLINE'
              and database_id > 4
              and DB_NAME(database_id) not like 'ReportServer%'
              and DB_NAME(database_id) not like 'rdsadmin%'
              and is_distributor = 0
            option ( recompile );

            /* Skip non-readable databases in an AG - see Github issue #1160 */
            if EXISTS(select *
                      from sys.all_objects o
                               inner join sys.all_columns c on o.object_id = c.object_id and
                                                               o.name = 'dm_hadr_availability_replica_states' and
                                                               c.name = 'role_desc')
                begin
                    set @dsql = N'UPDATE #DatabaseList SET secondary_role_allow_connections_desc = ''NO'' WHERE DatabaseName IN (
                        SELECT d.name
                        FROM sys.dm_hadr_availability_replica_states rs
                        INNER JOIN sys.databases d ON rs.replica_id = d.replica_id
                        INNER JOIN sys.availability_replicas r ON rs.replica_id = r.replica_id
                        WHERE rs.role_desc = ''SECONDARY''
                        AND r.secondary_role_allow_connections_desc = ''NO'')
						OPTION    ( RECOMPILE );';
                    exec sp_executesql @dsql;

                    if EXISTS(select * from #databaselist where secondary_role_allow_connections_desc = 'NO')
                        begin
                            insert #blitzindexresults (priority, check_id, findings_group, finding, database_name, url,
                                                       details, index_definition,
                                                       index_usage_summary, index_size_summary)
                            values (1,
                                    0,
                                    N'Skipped non-readable AG secondary databases.',
                                    N'You are running this on an AG secondary, and some of your databases are configured as non-readable when this is a secondary node.',
                                    N'To analyze those databases, run sp_BlitzIndex on the primary, or on a readable secondary.',
                                    'http://FirstResponderKit.org', '', '', '', '');
                        end;
                end;

            if @ignoredatabases is not null
                and LEN(@ignoredatabases) > 0
                begin
                    raiserror (N'Setting up filter to ignore databases', 0, 1) with nowait;
                    set @databasetoignore = '';

                    while LEN(@ignoredatabases) > 0
                        begin
                            if PATINDEX('%,%', @ignoredatabases) > 0
                                begin
                                    set @databasetoignore =
                                            SUBSTRING(@ignoredatabases, 0, PATINDEX('%,%', @ignoredatabases));

                                    insert into #ignore_databases (databasename, reason)
                                    select LTRIM(RTRIM(@databasetoignore)),
                                           'Specified in the @IgnoreDatabases parameter'
                                    option (recompile);

                                    set @ignoredatabases = SUBSTRING(@ignoredatabases, LEN(@databasetoignore + ',') + 1,
                                                                     LEN(@ignoredatabases));
                                end;
                            else
                                begin
                                    set @databasetoignore = @ignoredatabases;
                                    set @ignoredatabases = null;

                                    insert into #ignore_databases (databasename, reason)
                                    select LTRIM(RTRIM(@databasetoignore)),
                                           'Specified in the @IgnoreDatabases parameter'
                                    option (recompile);
                                end;
                        end;

                end

        end;
    else
        begin
            insert into #databaselist
                (databasename)
            select case
                       when @databasename is null or @databasename = N''
                           then DB_NAME()
                       else @databasename end;
        end;

    set @numdatabases = (select COUNT(*)
                         from #databaselist);
    set @msg = N'Number of databases to examine: ' + CAST(@numdatabases as nvarchar(50));
    raiserror (@msg,0,1) with nowait;


/* Running on 50+ databases can take a reaaallly long time, so we want explicit permission to do so (and only after warning about it) */


begin try
    if @numdatabases >= 50 and @bringthepain != 1 and @tablename is null
        begin

            insert #blitzindexresults (priority, check_id, findings_group, finding, url, details, index_definition,
                                       index_usage_summary, index_size_summary)
            values (-1,
                    0,
                    @scriptversionname,
                    case
                        when @getalldatabases = 1 then N'All Databases'
                        else N'Database ' + QUOTENAME(@databasename) + N' as of ' +
                             CONVERT(nvarchar(16), GETDATE(), 121) end,
                    N'From Your Community Volunteers',
                    N'http://FirstResponderKit.org',
                    N'',
                    N'',
                    N'');
            insert #blitzindexresults (priority, check_id, findings_group, finding, database_name, url, details,
                                       index_definition,
                                       index_usage_summary, index_size_summary)
            values (1,
                    0,
                    N'You''re trying to run sp_BlitzIndex on a server with ' + CAST(@numdatabases as nvarchar(8)) +
                    N' databases. ',
                    N'Running sp_BlitzIndex on a server with 50+ databases may cause temporary insanity for the server and/or user.',
                    N'If you''re sure you want to do this, run again with the parameter @BringThePain = 1.',
                    'http://FirstResponderKit.org',
                    '',
                    '',
                    '',
                    '');

            if (@outputtype <> 'NONE')
                begin
                    select bir.blitz_result_id,
                           bir.check_id,
                           bir.index_sanity_id,
                           bir.priority,
                           bir.findings_group,
                           bir.finding,
                           bir.database_name,
                           bir.url,
                           bir.details,
                           bir.index_definition,
                           bir.secret_columns,
                           bir.index_usage_summary,
                           bir.index_size_summary,
                           bir.create_tsql,
                           bir.more_info
                    from #blitzindexresults as bir;
                    raiserror ('Running sp_BlitzIndex on a server with 50+ databases may cause temporary insanity for the server', 12, 1);
                end;

            return;

        end;
end try
begin catch
    raiserror (N'Failure to execute due to number of databases.', 0,1) with nowait;

    select @msg = ERROR_MESSAGE(),
           @errorseverity = ERROR_SEVERITY(),
           @errorstate = ERROR_STATE();

    raiserror (@msg, @errorseverity, @errorstate);

    while @@trancount > 0
        rollback;

    return;
end catch;


    raiserror (N'Checking partition counts to exclude databases with over 100 partitions',0,1) with nowait;
    if @bringthepain = 0 and @skippartitions = 0 and @tablename is null
        begin
            declare partition_cursor cursor for
                select dl.databasename
                from #databaselist dl
                         left outer join #ignore_databases i on dl.databasename = i.databasename
                where COALESCE(dl.secondary_role_allow_connections_desc, 'OK') <> 'NO'
                  and i.databasename is null

            open partition_cursor
            fetch next from partition_cursor into @databasename

            while @@FETCH_STATUS = 0
                begin
                    /* Count the total number of partitions */
                    set @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                    SELECT @RowcountOUT = SUM(1) FROM ' + QUOTENAME(@databasename) +
                                '.sys.partitions WHERE partition_number > 1 OPTION    ( RECOMPILE );';
                    exec sp_executesql @dsql, N'@RowcountOUT BIGINT OUTPUT', @rowcountout = @rowcount output;
                    if @rowcount > 100
                        begin
                            raiserror (N'Skipping database %s because > 100 partitions were found. To check this database, you must set @BringThePain = 1.',0,1,@databasename) with nowait;
                            insert into #ignore_databases (databasename, reason)
                            select @databasename, 'Over 100 partitions found - use @BringThePain = 1 to analyze'
                        end;
                    fetch next from partition_cursor into @databasename
                end;
            close partition_cursor
            deallocate partition_cursor

        end;

insert #blitzindexresults (priority, check_id, findings_group, finding, url, details, index_definition,
                           index_usage_summary, index_size_summary)
select 1,
       0,
       'Database Skipped',
       i.databasename,
       'http://FirstResponderKit.org',
       i.reason,
       '',
       '',
       ''
from #ignore_databases i;


/* Last startup */
select @daysuptime = CAST(DATEDIFF(hour, create_date, GETDATE()) / 24. as numeric(23, 2))
from sys.databases
where database_id = 2;

    if @daysuptime = 0 or @daysuptime is null
        set @daysuptime = .01;

select @daysuptimeinsertvalue =
       'Server: ' + (CONVERT(varchar(256), (SERVERPROPERTY('ServerName')))) + ' Days Uptime: ' + RTRIM(@daysuptime);


/* Permission granted or unnecessary? Ok, let's go! */

    raiserror (N'Starting loop through databases',0,1) with nowait;
declare
    c1 cursor
        local fast_forward
        for
        select dl.databasename
        from #databaselist dl
                 left outer join #ignore_databases i on dl.databasename = i.databasename
        where COALESCE(dl.secondary_role_allow_connections_desc, 'OK') <> 'NO'
          and i.databasename is null
        order by dl.databasename;

    open c1;
    fetch next from c1 into @databasename;
    while @@FETCH_STATUS = 0
        begin

            raiserror (@linefeed, 0, 1) with nowait;
            raiserror (@linefeed, 0, 1) with nowait;
            raiserror (@databasename, 0, 1) with nowait;

            select @databaseid = [database_id]
            from sys.databases
            where [name] = @databasename
              and user_access_desc = 'MULTI_USER'
              and state_desc = 'ONLINE';

            ----------------------------------------
--STEP 1: OBSERVE THE PATIENT
--This step puts index information into temp tables.
----------------------------------------
            begin try
                begin

                    --Validate SQL Server Version

                    if (select LEFT(@sqlserverproductversion,
                                    CHARINDEX('.', @sqlserverproductversion, 0) - 1
                                   )) <= 9
                        begin
                            set @msg =
                                        N'sp_BlitzIndex is only supported on SQL Server 2008 and higher. The version of this instance is: ' +
                                        @sqlserverproductversion;
                            raiserror (@msg,16,1);
                        end;

                    --Short circuit here if database name does not exist.
                    if @databasename is null or @databaseid is null
                        begin
                            set @msg = 'Database does not exist or is not online/multi-user: cannot proceed.';
                            raiserror (@msg,16,1);
                        end;

                    --Validate parameters.
                    if (@mode not in (0, 1, 2, 3, 4))
                        begin
                            set @msg =
                                    N'Invalid @Mode parameter. 0=diagnose, 1=summarize, 2=index detail, 3=missing index detail, 4=diagnose detail';
                            raiserror (@msg,16,1);
                        end;

                    if (@mode <> 0 and @tablename is not null)
                        begin
                            set @msg =
                                    N'Setting the @Mode doesn''t change behavior if you supply @TableName. Use default @Mode=0 to see table detail.';
                            raiserror (@msg,16,1);
                        end;

                    if ((@mode <> 0 or @tablename is not null) and @filter <> 0)
                        begin
                            set @msg =
                                    N'@Filter only applies when @Mode=0 and @TableName is not specified. Please try again.';
                            raiserror (@msg,16,1);
                        end;

                    if (@schemaname is not null and @tablename is null)
                        begin
                            set @msg =
                                    'We can''t run against a whole schema! Specify a @TableName, or leave both NULL for diagnosis.';
                            raiserror (@msg,16,1);
                        end;


                    if (@tablename is not null and @schemaname is null)
                        begin
                            set @schemaname = N'dbo';
                            set @msg = '@SchemaName wasn''t specified-- assuming schema=dbo.';
                            raiserror (@msg,1,1) with nowait;
                        end;

                    --If a table is specified, grab the object id.
                    --Short circuit if it doesn't exist.
                    if @tablename is not null
                        begin
                            set @dsql = N'
                    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                    SELECT  @ObjectID= OBJECT_ID
                    FROM    ' + QUOTENAME(@databasename) + N'.sys.objects AS so
                    JOIN    ' + QUOTENAME(@databasename) + N'.sys.schemas AS sc on
                        so.schema_id=sc.schema_id
                    where so.type in (''U'', ''V'')
                    and so.name=' + QUOTENAME(@tablename, '''') + N'
                    and sc.name=' + QUOTENAME(@schemaname, '''') + N'
                    /*Has a row in sys.indexes. This lets us get indexed views.*/
                    and exists (
                        SELECT si.name
                        FROM ' + QUOTENAME(@databasename) + '.sys.indexes AS si
                        WHERE so.object_id=si.object_id)
                    OPTION (RECOMPILE);';

                            set @params = '@ObjectID INT OUTPUT';

                            if @dsql is null
                                raiserror ('@dsql is null',16,1);

                            exec sp_executesql @dsql, @params, @objectid=@objectid output;

                            if @objectid is null
                                begin
                                    set @msg =
                                                N'Oh, this is awkward. I can''t find the table or indexed view you''re looking for in that database.' +
                                                CHAR(10) +
                                                N'Please check your parameters.';
                                    raiserror (@msg,1,1);
                                    return;
                                end;
                        end;

                    --set @collation
                    select @collation = collation_name
                    from sys.databases
                    where database_id = @databaseid;

                    --insert columns for clustered indexes and heaps
                    --collect info on identity columns for this one
                    set @dsql = N'/* sp_BlitzIndex */
				SET LOCK_TIMEOUT 1000; /* To fix locking bug in sys.identity_columns. See Github issue #2176. */
				SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                SELECT ' + CAST(@databaseid as nvarchar(16)) + ',
					s.name,
                    si.object_id,
                    si.index_id,
                    sc.key_ordinal,
                    sc.is_included_column,
                    sc.is_descending_key,
                    sc.partition_ordinal,
                    c.name as column_name,
                    st.name as system_type_name,
                    c.max_length,
                    c.[precision],
                    c.[scale],
                    c.collation_name,
                    c.is_nullable,
                    c.is_identity,
                    c.is_computed,
                    c.is_replicated,
                    ' + case
                                                                                                                           when @sqlserverproductversion not like '9%'
                                                                                                                               then N'c.is_sparse'
                                                                                                                           else N'NULL as is_sparse' end + N',
                    ' + case
                                                                                                                                                                                       when @sqlserverproductversion not like '9%'
                                                                                                                                                                                           then N'c.is_filestream'
                                                                                                                                                                                       else N'NULL as is_filestream' end + N',
                    CAST(ic.seed_value AS DECIMAL(38,0)),
                    CAST(ic.increment_value AS DECIMAL(38,0)),
                    CAST(ic.last_value AS DECIMAL(38,0)),
                    ic.is_not_for_replication
                FROM    ' + QUOTENAME(@databasename) + N'.sys.indexes si
                JOIN    ' + QUOTENAME(@databasename) + N'.sys.columns c ON
                    si.object_id=c.object_id
                LEFT JOIN ' + QUOTENAME(@databasename) + N'.sys.index_columns sc ON
                    sc.object_id = si.object_id
                    and sc.index_id=si.index_id
                    AND sc.column_id=c.column_id
                LEFT JOIN ' + QUOTENAME(@databasename) + N'.sys.identity_columns ic ON
                    c.object_id=ic.object_id and
                    c.column_id=ic.column_id
                JOIN ' + QUOTENAME(@databasename) + N'.sys.types st ON
                    c.system_type_id=st.system_type_id
                    AND c.user_type_id=st.user_type_id
				JOIN ' + QUOTENAME(@databasename) + N'.sys.objects AS so  ON si.object_id = so.object_id
																		  AND so.is_ms_shipped = 0
				JOIN ' + QUOTENAME(@databasename) + N'.sys.schemas AS s ON s.schema_id = so.schema_id
                WHERE si.index_id in (0,1) '
                        + case
                              when @objectid is not null
                                  then N' AND si.object_id=' + CAST(@objectid as nvarchar(30))
                              else N'' end
                        + N'OPTION (RECOMPILE);';

                    if @dsql is null
                        raiserror ('@dsql is null',16,1);

                    raiserror (N'Inserting data into #IndexColumns for clustered indexes and heaps',0,1) with nowait;
                    if @debug = 1
                        begin
                            print SUBSTRING(@dsql, 0, 4000);
                            print SUBSTRING(@dsql, 4000, 8000);
                            print SUBSTRING(@dsql, 8000, 12000);
                            print SUBSTRING(@dsql, 12000, 16000);
                            print SUBSTRING(@dsql, 16000, 20000);
                            print SUBSTRING(@dsql, 20000, 24000);
                            print SUBSTRING(@dsql, 24000, 28000);
                            print SUBSTRING(@dsql, 28000, 32000);
                            print SUBSTRING(@dsql, 32000, 36000);
                            print SUBSTRING(@dsql, 36000, 40000);
                        end;
                    begin try
                        insert #indexcolumns (database_id, [schema_name], [object_id], index_id, key_ordinal,
                                              is_included_column, is_descending_key, partition_ordinal,
                                              column_name, system_type_name, max_length, precision, scale,
                                              collation_name, is_nullable, is_identity, is_computed,
                                              is_replicated, is_sparse, is_filestream, seed_value, increment_value,
                                              last_value, is_not_for_replication)
                            exec sp_executesql @dsql;
                    end try
                    begin catch
                        raiserror (N'Failure inserting data into #IndexColumns for clustered indexes and heaps.', 0,1) with nowait;

                        if @dsql is not null
                            begin
                                set @msg = 'Last @dsql: ' + @dsql;
                                raiserror (@msg, 0, 1) with nowait;
                            end;

                        select @msg = @databasename + N' database failed to process. ' + ERROR_MESSAGE(),
                               @errorseverity = 0,
                               @errorstate = ERROR_STATE();
                        raiserror (@msg,@errorseverity, @errorstate ) with nowait;

                        while @@trancount > 0
                            rollback;

                        return;
                    end catch;


                    --insert columns for nonclustered indexes
                    --this uses a full join to sys.index_columns
                    --We don't collect info on identity columns here. They may be in NC indexes, but we just analyze identities in the base table.
                    set @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                SELECT ' + CAST(@databaseid as nvarchar(16)) + ',
					s.name,
                    si.object_id,
                    si.index_id,
                    sc.key_ordinal,
                    sc.is_included_column,
                    sc.is_descending_key,
                    sc.partition_ordinal,
                    c.name as column_name,
                    st.name as system_type_name,
                    c.max_length,
                    c.[precision],
                    c.[scale],
                    c.collation_name,
                    c.is_nullable,
                    c.is_identity,
                    c.is_computed,
                    c.is_replicated,
                    ' + case
                                                                                                                           when @sqlserverproductversion not like '9%'
                                                                                                                               then N'c.is_sparse'
                                                                                                                           else N'NULL AS is_sparse' end + N',
                    ' + case
                                                                                                                                                                                       when @sqlserverproductversion not like '9%'
                                                                                                                                                                                           then N'c.is_filestream'
                                                                                                                                                                                       else N'NULL AS is_filestream' end + N'
                FROM    ' + QUOTENAME(@databasename) + N'.sys.indexes AS si
                JOIN    ' + QUOTENAME(@databasename) + N'.sys.columns AS c ON
                    si.object_id=c.object_id
                JOIN ' + QUOTENAME(@databasename) + N'.sys.index_columns AS sc ON
                    sc.object_id = si.object_id
                    and sc.index_id=si.index_id
                    AND sc.column_id=c.column_id
                JOIN ' + QUOTENAME(@databasename) + N'.sys.types AS st ON
                    c.system_type_id=st.system_type_id
                    AND c.user_type_id=st.user_type_id
				JOIN ' + QUOTENAME(@databasename) + N'.sys.objects AS so  ON si.object_id = so.object_id
																		  AND so.is_ms_shipped = 0
				JOIN ' + QUOTENAME(@databasename) + N'.sys.schemas AS s ON s.schema_id = so.schema_id
                WHERE si.index_id not in (0,1) '
                        + case
                              when @objectid is not null
                                  then N' AND si.object_id=' + CAST(@objectid as nvarchar(30))
                              else N'' end
                        + N'OPTION (RECOMPILE);';

                    if @dsql is null
                        raiserror ('@dsql is null',16,1);

                    raiserror (N'Inserting data into #IndexColumns for nonclustered indexes',0,1) with nowait;
                    if @debug = 1
                        begin
                            print SUBSTRING(@dsql, 0, 4000);
                            print SUBSTRING(@dsql, 4000, 8000);
                            print SUBSTRING(@dsql, 8000, 12000);
                            print SUBSTRING(@dsql, 12000, 16000);
                            print SUBSTRING(@dsql, 16000, 20000);
                            print SUBSTRING(@dsql, 20000, 24000);
                            print SUBSTRING(@dsql, 24000, 28000);
                            print SUBSTRING(@dsql, 28000, 32000);
                            print SUBSTRING(@dsql, 32000, 36000);
                            print SUBSTRING(@dsql, 36000, 40000);
                        end;
                    insert #indexcolumns (database_id, [schema_name], [object_id], index_id, key_ordinal,
                                          is_included_column, is_descending_key, partition_ordinal,
                                          column_name, system_type_name, max_length, precision, scale, collation_name,
                                          is_nullable, is_identity, is_computed,
                                          is_replicated, is_sparse, is_filestream)
                        exec sp_executesql @dsql;

                    set @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                SELECT  ' + CAST(@databaseid as nvarchar(10)) + N' AS database_id,
                        so.object_id,
                        si.index_id,
                        si.type,
                        @i_DatabaseName AS database_name,
                        COALESCE(sc.NAME, ''Unknown'') AS [schema_name],
                        COALESCE(so.name, ''Unknown'') AS [object_name],
                        COALESCE(si.name, ''Unknown'') AS [index_name],
                        CASE    WHEN so.[type] = CAST(''V'' AS CHAR(2)) THEN 1 ELSE 0 END,
                        si.is_unique,
                        si.is_primary_key,
                        CASE when si.type = 3 THEN 1 ELSE 0 END AS is_XML,
                        CASE when si.type = 4 THEN 1 ELSE 0 END AS is_spatial,
                        CASE when si.type = 6 THEN 1 ELSE 0 END AS is_NC_columnstore,
                        CASE when si.type = 5 then 1 else 0 end as is_CX_columnstore,
                        CASE when si.data_space_id = 0 then 1 else 0 end as is_in_memory_oltp,
                        si.is_disabled,
                        si.is_hypothetical,
                        si.is_padded,
                        si.fill_factor,'
                        + case
                              when @sqlserverproductversion not like '9%' then N'
                        CASE WHEN si.filter_definition IS NOT NULL THEN si.filter_definition
                             ELSE N''''
                        END AS filter_definition'
                              else N''''' AS filter_definition' end + N'
                        , ISNULL(us.user_seeks, 0),
                        ISNULL(us.user_scans, 0),
                        ISNULL(us.user_lookups, 0),
                        ISNULL(us.user_updates, 0),
                        us.last_user_seek,
                        us.last_user_scan,
                        us.last_user_lookup,
                        us.last_user_update,
                        so.create_date,
                        so.modify_date
                FROM    ' + QUOTENAME(@databasename) + N'.sys.indexes AS si WITH (NOLOCK)
                        JOIN ' + QUOTENAME(@databasename) + N'.sys.objects AS so WITH (NOLOCK) ON si.object_id = so.object_id
                                               AND so.is_ms_shipped = 0 /*Exclude objects shipped by Microsoft*/
                                               AND so.type <> ''TF'' /*Exclude table valued functions*/
                        JOIN ' + QUOTENAME(@databasename) + N'.sys.schemas sc ON so.schema_id = sc.schema_id
                        LEFT JOIN sys.dm_db_index_usage_stats AS us WITH (NOLOCK) ON si.[object_id] = us.[object_id]
                                                                       AND si.index_id = us.index_id
                                                                       AND us.database_id = ' +
                                CAST(@databaseid as nvarchar(10)) + N'
                WHERE    si.[type] IN ( 0, 1, 2, 3, 4, 5, 6 )
                /* Heaps, clustered, nonclustered, XML, spatial, Cluster Columnstore, NC Columnstore */ ' +
                                case
                                    when @tablename is not null
                                        then N' and so.name=' + QUOTENAME(@tablename, N'''') + N' '
                                    else N'' end +
                                case
                                    when (@includeinactiveindexes = 0
                                        and @mode in (0, 4)
                                        and @tablename is null)
                                        then N'AND ( us.user_seeks + us.user_scans + us.user_lookups + us.user_updates ) > 0'
                                    else N''
                                    end
                        + N'OPTION    ( RECOMPILE );
        ';
                    if @dsql is null
                        raiserror ('@dsql is null',16,1);

                    raiserror (N'Inserting data into #IndexSanity',0,1) with nowait;
                    if @debug = 1
                        begin
                            print SUBSTRING(@dsql, 0, 4000);
                            print SUBSTRING(@dsql, 4000, 8000);
                            print SUBSTRING(@dsql, 8000, 12000);
                            print SUBSTRING(@dsql, 12000, 16000);
                            print SUBSTRING(@dsql, 16000, 20000);
                            print SUBSTRING(@dsql, 20000, 24000);
                            print SUBSTRING(@dsql, 24000, 28000);
                            print SUBSTRING(@dsql, 28000, 32000);
                            print SUBSTRING(@dsql, 32000, 36000);
                            print SUBSTRING(@dsql, 36000, 40000);
                        end;
                    insert #indexsanity ([database_id], [object_id], [index_id], [index_type], [database_name],
                                         [schema_name], [object_name],
                                         index_name, is_indexed_view, is_unique, is_primary_key, is_xml, is_spatial,
                                         is_nc_columnstore, is_cx_columnstore, is_in_memory_oltp,
                                         is_disabled, is_hypothetical, is_padded, fill_factor, filter_definition,
                                         user_seeks, user_scans,
                                         user_lookups, user_updates, last_user_seek, last_user_scan, last_user_lookup,
                                         last_user_update,
                                         create_date, modify_date)
                        exec sp_executesql @dsql, @params = N'@i_DatabaseName NVARCHAR(128)',
                             @i_databasename = @databasename;


                    raiserror (N'Checking partition count',0,1) with nowait;
                    if @bringthepain = 0 and @skippartitions = 0 and @tablename is null
                        begin
                            /* Count the total number of partitions */
                            set @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                        SELECT @RowcountOUT = SUM(1) FROM ' + QUOTENAME(@databasename) +
                                        '.sys.partitions WHERE partition_number > 1 OPTION    ( RECOMPILE );';
                            exec sp_executesql @dsql, N'@RowcountOUT BIGINT OUTPUT', @rowcountout = @rowcount output;
                            if @rowcount > 100
                                begin
                                    raiserror (N'Setting @SkipPartitions = 1 because > 100 partitions were found. To check them, you must set @BringThePain = 1.',0,1) with nowait;
                                    set @skippartitions = 1;
                                    insert #blitzindexresults (priority, check_id, findings_group, finding, url,
                                                               details, index_definition,
                                                               index_usage_summary, index_size_summary)
                                    values (1, 0,
                                            'Some Checks Were Skipped',
                                            '@SkipPartitions Forced to 1',
                                            'http://FirstResponderKit.org', CAST(@rowcount as nvarchar(50)) +
                                                                            ' partitions found. To analyze them, use @BringThePain = 1.',
                                            'We try to keep things quick - and warning, running @BringThePain = 1 can take tens of minutes.',
                                            '', '');
                                end;
                        end;


                    if (@skippartitions = 0)
                        begin
                            if (select LEFT(@sqlserverproductversion,
                                            CHARINDEX('.', @sqlserverproductversion, 0) - 1)) <=
                               2147483647 --Make change here
                                begin

                                    raiserror (N'Preferring non-2012 syntax with LEFT JOIN to sys.dm_db_index_operational_stats',0,1) with nowait;

                                    --NOTE: If you want to use the newer syntax for 2012+, you'll have to change 2147483647 to 11 on line ~819
                                    --This change was made because on a table with lots of paritions, the OUTER APPLY was crazy slow.
                                    set @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                        SELECT  ' + CAST(@databaseid as nvarchar(10)) + ' AS database_id,
                                ps.object_id,
								s.name,
                                ps.index_id,
                                ps.partition_number,
                                ps.row_count,
                                ps.reserved_page_count * 8. / 1024. AS reserved_MB,
                                ps.lob_reserved_page_count * 8. / 1024. AS reserved_LOB_MB,
                                ps.row_overflow_reserved_page_count * 8. / 1024. AS reserved_row_overflow_MB,
                            ' + case
                                                                                                                                                            when @sqlserverproductversion not like '9%'
                                                                                                                                                                then N'par.data_compression_desc '
                                                                                                                                                            else N'null as data_compression_desc ' end + N',
                                SUM(os.leaf_insert_count),
                                SUM(os.leaf_delete_count),
                                SUM(os.leaf_update_count),
                                SUM(os.range_scan_count),
                                SUM(os.singleton_lookup_count),
                                SUM(os.forwarded_fetch_count),
                                SUM(os.lob_fetch_in_pages),
                                SUM(os.lob_fetch_in_bytes),
                                SUM(os.row_overflow_fetch_in_pages),
                                SUM(os.row_overflow_fetch_in_bytes),
                                SUM(os.row_lock_count),
                                SUM(os.row_lock_wait_count),
                                SUM(os.row_lock_wait_in_ms),
                                SUM(os.page_lock_count),
                                SUM(os.page_lock_wait_count),
                                SUM(os.page_lock_wait_in_ms),
                                SUM(os.index_lock_promotion_attempt_count),
                                SUM(os.index_lock_promotion_count),
								SUM(os.page_latch_wait_count),
								SUM(os.page_latch_wait_in_ms),
								SUM(os.page_io_latch_wait_count),
								SUM(os.page_io_latch_wait_in_ms)
                    FROM    ' + QUOTENAME(@databasename) + '.sys.dm_db_partition_stats AS ps
                    JOIN ' + QUOTENAME(@databasename) + '.sys.partitions AS par on ps.partition_id=par.partition_id
                    JOIN ' + QUOTENAME(@databasename) + '.sys.objects AS so ON ps.object_id = so.object_id
                               AND so.is_ms_shipped = 0 /*Exclude objects shipped by Microsoft*/
                               AND so.type <> ''TF'' /*Exclude table valued functions*/
					JOIN ' + QUOTENAME(@databasename) + '.sys.schemas AS s ON s.schema_id = so.schema_id
                    LEFT JOIN ' + QUOTENAME(@databasename) + '.sys.dm_db_index_operational_stats('
                                        + CAST(@databaseid as nvarchar(10)) + ', NULL, NULL,NULL) AS os ON
                    ps.object_id=os.object_id and ps.index_id=os.index_id and ps.partition_number=os.partition_number
                    WHERE 1=1
                    ' + case
                                                                                                          when @objectid is not null
                                                                                                              then N'AND so.object_id=' + CAST(@objectid as nvarchar(30)) + N' '
                                                                                                          else N' ' end + '
                    ' + case
                                                                                                                                                      when @filter = 2
                                                                                                                                                          then
                                                                                                                                                              N'AND ps.reserved_page_count * 8./1024. > ' +
                                                                                                                                                              CAST(@filtermb as nvarchar(5)) +
                                                                                                                                                              N' '
                                                                                                                                                      else N' ' end + '
            GROUP BY ps.object_id,
								s.name,
                                ps.index_id,
                                ps.partition_number,
                                ps.row_count,
                                ps.reserved_page_count,
                                ps.lob_reserved_page_count,
                                ps.row_overflow_reserved_page_count,
                            ' + case
                                                                                                                                                                                                          when @sqlserverproductversion not like '9%'
                                                                                                                                                                                                              then N'par.data_compression_desc '
                                                                                                                                                                                                          else N'null as data_compression_desc ' end + N'
			ORDER BY ps.object_id,  ps.index_id, ps.partition_number
            OPTION    ( RECOMPILE );
            ';
                                end;
                            else
                                begin
                                    raiserror (N'Using 2012 syntax to query sys.dm_db_index_operational_stats',0,1) with nowait;
                                    --This is the syntax that will be used if you change 2147483647 to 11 on line ~819.
                                    --If you have a lot of paritions and this suddenly starts running for a long time, change it back.
                                    set @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                        SELECT  ' + CAST(@databaseid as nvarchar(10)) + ' AS database_id,
                                ps.object_id,
								s.name,
                                ps.index_id,
                                ps.partition_number,
                                ps.row_count,
                                ps.reserved_page_count * 8. / 1024. AS reserved_MB,
                                ps.lob_reserved_page_count * 8. / 1024. AS reserved_LOB_MB,
                                ps.row_overflow_reserved_page_count * 8. / 1024. AS reserved_row_overflow_MB,
                                ' + case
                                                                                                                                                                when @sqlserverproductversion not like '9%'
                                                                                                                                                                    then N'par.data_compression_desc '
                                                                                                                                                                else N'null as data_compression_desc' end + N',
                                SUM(os.leaf_insert_count),
                                SUM(os.leaf_delete_count),
                                SUM(os.leaf_update_count),
                                SUM(os.range_scan_count),
                                SUM(os.singleton_lookup_count),
                                SUM(os.forwarded_fetch_count),
                                SUM(os.lob_fetch_in_pages),
                                SUM(os.lob_fetch_in_bytes),
                                SUM(os.row_overflow_fetch_in_pages),
                                SUM(os.row_overflow_fetch_in_bytes),
                                SUM(os.row_lock_count),
                                SUM(os.row_lock_wait_count),
                                SUM(os.row_lock_wait_in_ms),
                                SUM(os.page_lock_count),
                                SUM(os.page_lock_wait_count),
                                SUM(os.page_lock_wait_in_ms),
                                SUM(os.index_lock_promotion_attempt_count),
                                SUM(os.index_lock_promotion_count),
								SUM(os.page_latch_wait_count),
								SUM(os.page_latch_wait_in_ms),
								SUM(os.page_io_latch_wait_count),
								SUM(os.page_io_latch_wait_in_ms)
                        FROM    ' + QUOTENAME(@databasename) + N'.sys.dm_db_partition_stats AS ps
                        JOIN ' + QUOTENAME(@databasename) + N'.sys.partitions AS par on ps.partition_id=par.partition_id
                        JOIN ' + QUOTENAME(@databasename) + N'.sys.objects AS so ON ps.object_id = so.object_id
                                   AND so.is_ms_shipped = 0 /*Exclude objects shipped by Microsoft*/
                                   AND so.type <> ''TF'' /*Exclude table valued functions*/
						JOIN ' + QUOTENAME(@databasename) + '.sys.schemas AS s ON s.schema_id = so.schema_id
                        OUTER APPLY ' + QUOTENAME(@databasename) + N'.sys.dm_db_index_operational_stats('
                                        + CAST(@databaseid as nvarchar(10)) + N', ps.object_id, ps.index_id,ps.partition_number) AS os
                        WHERE 1=1
                        ' + case
                                                                                                              when @objectid is not null
                                                                                                                  then N'AND so.object_id=' + CAST(@objectid as nvarchar(30)) + N' '
                                                                                                              else N' ' end + N'
                        ' + case
                                                                                                                                                              when @filter = 2
                                                                                                                                                                  then
                                                                                                                                                                      N'AND ps.reserved_page_count * 8./1024. > ' +
                                                                                                                                                                      CAST(@filtermb as nvarchar(5)) +
                                                                                                                                                                      N' '
                                                                                                                                                              else N' ' end + '
	            GROUP BY ps.object_id,
								s.name,
                                ps.index_id,
                                ps.partition_number,
                                ps.row_count,
                                ps.reserved_page_count,
                                ps.lob_reserved_page_count,
                                ps.row_overflow_reserved_page_count,
                            ' + case
                                                                                                                                                                                                                  when @sqlserverproductversion not like '9%'
                                                                                                                                                                                                                      then N'par.data_compression_desc '
                                                                                                                                                                                                                  else N'null as data_compression_desc ' end + N'
				ORDER BY ps.object_id,  ps.index_id, ps.partition_number
                OPTION    ( RECOMPILE );
                ';
                                end;

                            if @dsql is null
                                raiserror ('@dsql is null',16,1);

                            raiserror (N'Inserting data into #IndexPartitionSanity',0,1) with nowait;
                            if @debug = 1
                                begin
                                    print SUBSTRING(@dsql, 0, 4000);
                                    print SUBSTRING(@dsql, 4000, 8000);
                                    print SUBSTRING(@dsql, 8000, 12000);
                                    print SUBSTRING(@dsql, 12000, 16000);
                                    print SUBSTRING(@dsql, 16000, 20000);
                                    print SUBSTRING(@dsql, 20000, 24000);
                                    print SUBSTRING(@dsql, 24000, 28000);
                                    print SUBSTRING(@dsql, 28000, 32000);
                                    print SUBSTRING(@dsql, 32000, 36000);
                                    print SUBSTRING(@dsql, 36000, 40000);
                                end;
                            insert #indexpartitionsanity ([database_id],
                                                          [object_id],
                                                          [schema_name],
                                                          index_id,
                                                          partition_number,
                                                          row_count,
                                                          reserved_mb,
                                                          reserved_lob_mb,
                                                          reserved_row_overflow_mb,
                                                          data_compression_desc,
                                                          leaf_insert_count,
                                                          leaf_delete_count,
                                                          leaf_update_count,
                                                          range_scan_count,
                                                          singleton_lookup_count,
                                                          forwarded_fetch_count,
                                                          lob_fetch_in_pages,
                                                          lob_fetch_in_bytes,
                                                          row_overflow_fetch_in_pages,
                                                          row_overflow_fetch_in_bytes,
                                                          row_lock_count,
                                                          row_lock_wait_count,
                                                          row_lock_wait_in_ms,
                                                          page_lock_count,
                                                          page_lock_wait_count,
                                                          page_lock_wait_in_ms,
                                                          index_lock_promotion_attempt_count,
                                                          index_lock_promotion_count,
                                                          page_latch_wait_count,
                                                          page_latch_wait_in_ms,
                                                          page_io_latch_wait_count,
                                                          page_io_latch_wait_in_ms)
                                exec sp_executesql @dsql;

                        end; --End Check For @SkipPartitions = 0


                    raiserror (N'Inserting data into #MissingIndexes',0,1) with nowait;
                    set @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                SELECT  id.database_id, id.object_id, @i_DatabaseName, sc.[name], so.[name], id.statement , gs.avg_total_user_cost,
                        gs.avg_user_impact, gs.user_seeks, gs.user_scans, gs.unique_compiles,id.equality_columns,
                        id.inequality_columns,id.included_columns
                FROM    sys.dm_db_missing_index_groups ig
                        JOIN sys.dm_db_missing_index_details id ON ig.index_handle = id.index_handle
                        JOIN sys.dm_db_missing_index_group_stats gs ON ig.index_group_handle = gs.group_handle
                        JOIN ' + QUOTENAME(@databasename) + N'.sys.objects so on
                            id.object_id=so.object_id
                        JOIN ' + QUOTENAME(@databasename) + N'.sys.schemas sc on
                            so.schema_id=sc.schema_id
                WHERE    id.database_id = ' + CAST(@databaseid as nvarchar(30)) + '
                ' + case
                                                                                                                                                                                                                                                                  when @objectid is null
                                                                                                                                                                                                                                                                      then N''
                                                                                                                                                                                                                                                                  else N'and id.object_id=' + CAST(@objectid as nvarchar(30))
                        end +
                                N'OPTION (RECOMPILE);';

                    if @dsql is null
                        raiserror ('@dsql is null',16,1);
                    if @debug = 1
                        begin
                            print SUBSTRING(@dsql, 0, 4000);
                            print SUBSTRING(@dsql, 4000, 8000);
                            print SUBSTRING(@dsql, 8000, 12000);
                            print SUBSTRING(@dsql, 12000, 16000);
                            print SUBSTRING(@dsql, 16000, 20000);
                            print SUBSTRING(@dsql, 20000, 24000);
                            print SUBSTRING(@dsql, 24000, 28000);
                            print SUBSTRING(@dsql, 28000, 32000);
                            print SUBSTRING(@dsql, 32000, 36000);
                            print SUBSTRING(@dsql, 36000, 40000);
                        end;
                    insert #missingindexes ([database_id], [object_id], [database_name], [schema_name], [table_name],
                                            [statement], avg_total_user_cost,
                                            avg_user_impact, user_seeks, user_scans, unique_compiles, equality_columns,
                                            inequality_columns, included_columns)
                        exec sp_executesql @dsql, @params = N'@i_DatabaseName NVARCHAR(128)',
                             @i_databasename = @databasename;

                    set @dsql = N'
            SELECT DB_ID(N' + QUOTENAME(@databasename, '''') + N') AS [database_id],
			    @i_DatabaseName AS database_name,
				s.name,
                fk_object.name AS foreign_key_name,
                parent_object.[object_id] AS parent_object_id,
                parent_object.name AS parent_object_name,
                referenced_object.[object_id] AS referenced_object_id,
                referenced_object.name AS referenced_object_name,
                fk.is_disabled,
                fk.is_not_trusted,
                fk.is_not_for_replication,
                parent.fk_columns,
                referenced.fk_columns,
                [update_referential_action_desc],
                [delete_referential_action_desc]
            FROM ' + QUOTENAME(@databasename) + N'.sys.foreign_keys fk
            JOIN ' + QUOTENAME(@databasename) + N'.sys.objects fk_object ON fk.object_id=fk_object.object_id
            JOIN ' + QUOTENAME(@databasename) + N'.sys.objects parent_object ON fk.parent_object_id=parent_object.object_id
            JOIN ' + QUOTENAME(@databasename) + N'.sys.objects referenced_object ON fk.referenced_object_id=referenced_object.object_id
			JOIN ' + QUOTENAME(@databasename) + N'.sys.schemas AS s ON fk.schema_id=s.schema_id
            CROSS APPLY ( SELECT  STUFF( (SELECT  N'', '' + c_parent.name AS fk_columns
                                            FROM    ' + QUOTENAME(@databasename) + N'.sys.foreign_key_columns fkc
                                            JOIN ' + QUOTENAME(@databasename) + N'.sys.columns c_parent ON fkc.parent_object_id=c_parent.[object_id]
                                                AND fkc.parent_column_id=c_parent.column_id
                                            WHERE    fk.parent_object_id=fkc.parent_object_id
                                                AND fk.[object_id]=fkc.constraint_object_id
                                            ORDER BY fkc.constraint_column_id
                                    FOR      XML PATH('''') ,
                                              TYPE).value(''.'', ''nvarchar(max)''), 1, 1, '''')/*This is how we remove the first comma*/ ) parent ( fk_columns )
            CROSS APPLY ( SELECT  STUFF( (SELECT  N'', '' + c_referenced.name AS fk_columns
                                            FROM    ' + QUOTENAME(@databasename) + N'.sys.    foreign_key_columns fkc
                                            JOIN ' + QUOTENAME(@databasename) + N'.sys.columns c_referenced ON fkc.referenced_object_id=c_referenced.[object_id]
                                                AND fkc.referenced_column_id=c_referenced.column_id
                                            WHERE    fk.referenced_object_id=fkc.referenced_object_id
                                                and fk.[object_id]=fkc.constraint_object_id
                                            ORDER BY fkc.constraint_column_id  /*order by col name, we don''t have anything better*/
                                    FOR      XML PATH('''') ,
                                              TYPE).value(''.'', ''nvarchar(max)''), 1, 1, '''') ) referenced ( fk_columns )
            ' + case
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         when @objectid is not null
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             then
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 'WHERE fk.parent_object_id=' +
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 CAST(@objectid as nvarchar(30)) +
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 N' OR fk.referenced_object_id=' +
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 CAST(@objectid as nvarchar(30)) +
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 N' '
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         else N' ' end + '
            ORDER BY parent_object_name, foreign_key_name
			OPTION (RECOMPILE);';
                    if @dsql is null
                        raiserror ('@dsql is null',16,1);

                    raiserror (N'Inserting data into #ForeignKeys',0,1) with nowait;
                    if @debug = 1
                        begin
                            print SUBSTRING(@dsql, 0, 4000);
                            print SUBSTRING(@dsql, 4000, 8000);
                            print SUBSTRING(@dsql, 8000, 12000);
                            print SUBSTRING(@dsql, 12000, 16000);
                            print SUBSTRING(@dsql, 16000, 20000);
                            print SUBSTRING(@dsql, 20000, 24000);
                            print SUBSTRING(@dsql, 24000, 28000);
                            print SUBSTRING(@dsql, 28000, 32000);
                            print SUBSTRING(@dsql, 32000, 36000);
                            print SUBSTRING(@dsql, 36000, 40000);
                        end;
                    insert #foreignkeys ([database_id], [database_name], [schema_name], foreign_key_name,
                                         parent_object_id, parent_object_name, referenced_object_id,
                                         referenced_object_name,
                                         is_disabled, is_not_trusted, is_not_for_replication, parent_fk_columns,
                                         referenced_fk_columns,
                                         [update_referential_action_desc], [delete_referential_action_desc])
                        exec sp_executesql @dsql, @params = N'@i_DatabaseName NVARCHAR(128)',
                             @i_databasename = @databasename;


                    if @skipstatistics = 0 and DB_NAME() = @databasename /* Can only get stats in the current database - see https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/1947 */
                        begin
                            if ((PARSENAME(@sqlserverproductversion, 4) >= 12)
                                or (PARSENAME(@sqlserverproductversion, 4) = 11 and
                                    PARSENAME(@sqlserverproductversion, 2) >= 3000)
                                or (PARSENAME(@sqlserverproductversion, 4) = 10 and
                                    PARSENAME(@sqlserverproductversion, 3) = 50 and
                                    PARSENAME(@sqlserverproductversion, 2) >= 2500))
                                begin
                                    raiserror (N'Gathering Statistics Info With Newer Syntax.',0,1) with nowait;
                                    set @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
				SELECT DB_ID(N' + QUOTENAME(@databasename, '''') + N') AS [database_id],
				    @i_DatabaseName AS database_name,
					obj.name AS table_name,
					sch.name AS schema_name,
			        ISNULL(i.name, ''System Or User Statistic'') AS index_name,
			        ca.column_names AS column_names,
			        s.name AS statistics_name,
			        CONVERT(DATETIME, ddsp.last_updated) AS last_statistics_update,
			        DATEDIFF(DAY, ddsp.last_updated, GETDATE()) AS days_since_last_stats_update,
			        ddsp.rows,
			        ddsp.rows_sampled,
			        CAST(ddsp.rows_sampled / ( 1. * NULLIF(ddsp.rows, 0) ) * 100 AS DECIMAL(18, 1)) AS percent_sampled,
			        ddsp.steps AS histogram_steps,
			        ddsp.modification_counter,
			        CASE WHEN ddsp.modification_counter > 0
			             THEN CAST(ddsp.modification_counter / ( 1. * NULLIF(ddsp.rows, 0) ) * 100 AS DECIMAL(18, 1))
			             ELSE ddsp.modification_counter
			        END AS percent_modifications,
			        CASE WHEN ddsp.rows < 500 THEN 500
			             ELSE CAST(( ddsp.rows * .20 ) + 500 AS INT)
			        END AS modifications_before_auto_update,
			        ISNULL(i.type_desc, ''System Or User Statistic - N/A'') AS index_type_desc,
			        CONVERT(DATETIME, obj.create_date) AS table_create_date,
			        CONVERT(DATETIME, obj.modify_date) AS table_modify_date,
					s.no_recompute,
					s.has_filter,
					s.filter_definition
			FROM    ' + QUOTENAME(@databasename) + N'.sys.stats AS s
			JOIN    ' + QUOTENAME(@databasename) + N'.sys.objects obj
			ON      s.object_id = obj.object_id
			JOIN    ' + QUOTENAME(@databasename) + N'.sys.schemas sch
			ON		sch.schema_id = obj.schema_id
			LEFT JOIN    ' + QUOTENAME(@databasename) + N'.sys.indexes AS i
			ON      i.object_id = s.object_id
			        AND i.index_id = s.stats_id
			OUTER APPLY ' + QUOTENAME(@databasename) + N'.sys.dm_db_stats_properties(s.object_id, s.stats_id) AS ddsp
			CROSS APPLY ( SELECT  STUFF((SELECT   '', '' + c.name
						  FROM     ' + QUOTENAME(@databasename) + N'.sys.stats_columns AS sc
						  JOIN     ' + QUOTENAME(@databasename) + N'.sys.columns AS c
						  ON       sc.column_id = c.column_id AND sc.object_id = c.object_id
						  WHERE    sc.stats_id = s.stats_id AND sc.object_id = s.object_id
						  ORDER BY sc.stats_column_id
						  FOR   XML PATH(''''), TYPE).value(''.'', ''nvarchar(max)''), 1, 2, '''')
						) ca (column_names)
			WHERE obj.is_ms_shipped = 0
			OPTION (RECOMPILE);';

                                    if @dsql is null
                                        raiserror ('@dsql is null',16,1);

                                    raiserror (N'Inserting data into #Statistics',0,1) with nowait;
                                    if @debug = 1
                                        begin
                                            print SUBSTRING(@dsql, 0, 4000);
                                            print SUBSTRING(@dsql, 4000, 8000);
                                            print SUBSTRING(@dsql, 8000, 12000);
                                            print SUBSTRING(@dsql, 12000, 16000);
                                            print SUBSTRING(@dsql, 16000, 20000);
                                            print SUBSTRING(@dsql, 20000, 24000);
                                            print SUBSTRING(@dsql, 24000, 28000);
                                            print SUBSTRING(@dsql, 28000, 32000);
                                            print SUBSTRING(@dsql, 32000, 36000);
                                            print SUBSTRING(@dsql, 36000, 40000);
                                        end;
                                    insert #statistics (database_id, database_name, table_name, schema_name, index_name,
                                                        column_names, statistics_name, last_statistics_update,
                                                        days_since_last_stats_update, rows, rows_sampled,
                                                        percent_sampled, histogram_steps, modification_counter,
                                                        percent_modifications, modifications_before_auto_update,
                                                        index_type_desc, table_create_date, table_modify_date,
                                                        no_recompute, has_filter, filter_definition)
                                        exec sp_executesql @dsql, @params = N'@i_DatabaseName NVARCHAR(128)',
                                             @i_databasename = @databasename;
                                end;
                            else
                                begin
                                    raiserror (N'Gathering Statistics Info With Older Syntax.',0,1) with nowait;
                                    set @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
							SELECT DB_ID(N' + QUOTENAME(@databasename, '''') + N') AS [database_id],
							    @i_DatabaseName AS database_name,
								obj.name AS table_name,
								sch.name AS schema_name,
						        ISNULL(i.name, ''System Or User Statistic'') AS index_name,
						        ca.column_names  AS column_names,
						        s.name AS statistics_name,
						        CONVERT(DATETIME, STATS_DATE(s.object_id, s.stats_id)) AS last_statistics_update,
						        DATEDIFF(DAY, STATS_DATE(s.object_id, s.stats_id), GETDATE()) AS days_since_last_stats_update,
						        si.rowcnt,
						        si.rowmodctr,
						        CASE WHEN si.rowmodctr > 0 THEN CAST(si.rowmodctr / ( 1. * NULLIF(si.rowcnt, 0) ) * 100 AS DECIMAL(18, 1))
						             ELSE si.rowmodctr
						        END AS percent_modifications,
						        CASE WHEN si.rowcnt < 500 THEN 500
						             ELSE CAST(( si.rowcnt * .20 ) + 500 AS INT)
						        END AS modifications_before_auto_update,
						        ISNULL(i.type_desc, ''System Or User Statistic - N/A'') AS index_type_desc,
						        CONVERT(DATETIME, obj.create_date) AS table_create_date,
						        CONVERT(DATETIME, obj.modify_date) AS table_modify_date,
								s.no_recompute,
								'
                                        + case
                                              when @sqlserverproductversion not like '9%'
                                                  then N's.has_filter,
									   s.filter_definition'
                                              else N'NULL AS has_filter,
								       NULL AS filter_definition' end
                                        + N'
						FROM    ' + QUOTENAME(@databasename) + N'.sys.stats AS s
						INNER HASH JOIN    ' + QUOTENAME(@databasename) + N'.sys.sysindexes si
						ON      si.name = s.name AND s.object_id = si.id
						INNER HASH JOIN    ' + QUOTENAME(@databasename) + N'.sys.objects obj
						ON      s.object_id = obj.object_id
						INNER HASH JOIN    ' + QUOTENAME(@databasename) + N'.sys.schemas sch
						ON		sch.schema_id = obj.schema_id
						LEFT HASH JOIN ' + QUOTENAME(@databasename) + N'.sys.indexes AS i
						ON      i.object_id = s.object_id
						        AND i.index_id = s.stats_id
						CROSS APPLY ( SELECT  STUFF((SELECT   '', '' + c.name
									  FROM     ' + QUOTENAME(@databasename) + N'.sys.stats_columns AS sc
									  JOIN     ' + QUOTENAME(@databasename) + N'.sys.columns AS c
									  ON       sc.column_id = c.column_id AND sc.object_id = c.object_id
									  WHERE    sc.stats_id = s.stats_id AND sc.object_id = s.object_id
									  ORDER BY sc.stats_column_id
									  FOR   XML PATH(''''), TYPE).value(''.'', ''nvarchar(max)''), 1, 2, '''')
									) ca (column_names)
						WHERE obj.is_ms_shipped = 0
						AND si.rowcnt > 0
						OPTION (RECOMPILE);';

                                    if @dsql is null
                                        raiserror ('@dsql is null',16,1);

                                    raiserror (N'Inserting data into #Statistics',0,1) with nowait;
                                    if @debug = 1
                                        begin
                                            print SUBSTRING(@dsql, 0, 4000);
                                            print SUBSTRING(@dsql, 4000, 8000);
                                            print SUBSTRING(@dsql, 8000, 12000);
                                            print SUBSTRING(@dsql, 12000, 16000);
                                            print SUBSTRING(@dsql, 16000, 20000);
                                            print SUBSTRING(@dsql, 20000, 24000);
                                            print SUBSTRING(@dsql, 24000, 28000);
                                            print SUBSTRING(@dsql, 28000, 32000);
                                            print SUBSTRING(@dsql, 32000, 36000);
                                            print SUBSTRING(@dsql, 36000, 40000);
                                        end;
                                    insert #statistics(database_id, database_name, table_name, schema_name, index_name,
                                                       column_names, statistics_name,
                                                       last_statistics_update, days_since_last_stats_update, rows,
                                                       modification_counter,
                                                       percent_modifications, modifications_before_auto_update,
                                                       index_type_desc, table_create_date, table_modify_date,
                                                       no_recompute, has_filter, filter_definition)
                                        exec sp_executesql @dsql, @params = N'@i_DatabaseName NVARCHAR(128)',
                                             @i_databasename = @databasename;
                                end;

                        end;

                    if (PARSENAME(@sqlserverproductversion, 4) >= 10)
                        begin
                            raiserror (N'Gathering Computed Column Info.',0,1) with nowait;
                            set @dsql = N'SELECT DB_ID(@i_DatabaseName) AS [database_id],
							   @i_DatabaseName AS database_name,
   					   		   t.name AS table_name,
   					           s.name AS schema_name,
   					           c.name AS column_name,
   					           cc.is_nullable,
   					           cc.definition,
   					           cc.uses_database_collation,
   					           cc.is_persisted,
   					           cc.is_computed,
   					   		   CASE WHEN cc.definition LIKE ''%|].|[%'' ESCAPE ''|'' THEN 1 ELSE 0 END AS is_function,
   					   		   ''ALTER TABLE '' + QUOTENAME(s.name) + ''.'' + QUOTENAME(t.name) +
   					   		   '' ADD '' + QUOTENAME(c.name) + '' AS '' + cc.definition  +
							   CASE WHEN is_persisted = 1 THEN '' PERSISTED'' ELSE '''' END + '';'' COLLATE DATABASE_DEFAULT AS [column_definition]
   					   FROM    ' + QUOTENAME(@databasename) + N'.sys.computed_columns AS cc
   					   JOIN    ' + QUOTENAME(@databasename) + N'.sys.columns AS c
   					   ON      cc.object_id = c.object_id
   					   		   AND cc.column_id = c.column_id
   					   JOIN    ' + QUOTENAME(@databasename) + N'.sys.tables AS t
   					   ON      t.object_id = cc.object_id
   					   JOIN    ' + QUOTENAME(@databasename) + N'.sys.schemas AS s
   					   ON      s.schema_id = t.schema_id
					   OPTION (RECOMPILE);';

                            if @dsql is null raiserror ('@dsql is null',16,1);

                            insert #computedcolumns
                            (database_id, [database_name], table_name, schema_name, column_name, is_nullable,
                             definition,
                             uses_database_collation, is_persisted, is_computed, is_function, column_definition)
                                exec sp_executesql @dsql, @params = N'@i_DatabaseName NVARCHAR(128)',
                                     @i_databasename = @databasename;

                        end;

                    raiserror (N'Gathering Trace Flag Information',0,1) with nowait;
                    insert #tracestatus
                        exec ('DBCC TRACESTATUS(-1) WITH NO_INFOMSGS');

                    if (PARSENAME(@sqlserverproductversion, 4) >= 13)
                        begin
                            raiserror (N'Gathering Temporal Table Info',0,1) with nowait;
                            set @dsql = N'SELECT ' + QUOTENAME(@databasename, '''') + N' AS database_name,
								   DB_ID(N' + QUOTENAME(@databasename, '''') + N') AS [database_id],
								   s.name AS schema_name,
								   t.name AS table_name,
								   oa.hsn as history_schema_name,
								   oa.htn AS history_table_name,
								   c1.name AS start_column_name,
								   c2.name AS end_column_name,
								   p.name AS period_name
							FROM ' + QUOTENAME(@databasename) + N'.sys.periods AS p
							INNER JOIN ' + QUOTENAME(@databasename) + N'.sys.tables AS t
							ON  p.object_id = t.object_id
							INNER JOIN ' + QUOTENAME(@databasename) + N'.sys.columns AS c1
							ON  t.object_id = c1.object_id
							    AND p.start_column_id = c1.column_id
							INNER JOIN ' + QUOTENAME(@databasename) + N'.sys.columns AS c2
							ON  t.object_id = c2.object_id
							    AND p.end_column_id = c2.column_id
							INNER JOIN ' + QUOTENAME(@databasename) + N'.sys.schemas AS s
							ON t.schema_id = s.schema_id
							CROSS APPLY ( SELECT s2.name as hsn, t2.name htn
							              FROM ' + QUOTENAME(@databasename) + N'.sys.tables AS t2
										  INNER JOIN ' + QUOTENAME(@databasename) + N'.sys.schemas AS s2
										  ON t2.schema_id = s2.schema_id
							              WHERE t2.object_id = t.history_table_id
							              AND t2.temporal_type = 1 /*History table*/ ) AS oa
							WHERE t.temporal_type IN ( 2, 4 ) /*BOL currently points to these types, but has no definition for 4*/
							OPTION (RECOMPILE);
							';

                            if @dsql is null
                                raiserror ('@dsql is null',16,1);

                            insert #temporaltables (database_name, database_id, schema_name, table_name,
                                                    history_table_name,
                                                    history_schema_name, start_column_name, end_column_name,
                                                    period_name)
                                exec sp_executesql @dsql;

                            set @dsql = N'SELECT DB_ID(@i_DatabaseName) AS [database_id],
             				   @i_DatabaseName AS database_name,
             		   		   t.name AS table_name,
             		           s.name AS schema_name,
             		           cc.name AS constraint_name,
             		           cc.is_disabled,
             		           cc.definition,
             		           cc.uses_database_collation,
             		           cc.is_not_trusted,
             		   		   CASE WHEN cc.definition LIKE ''%|].|[%'' ESCAPE ''|'' THEN 1 ELSE 0 END AS is_function,
             		   		   ''ALTER TABLE '' + QUOTENAME(s.name) + ''.'' + QUOTENAME(t.name) +
             		   		   '' ADD CONSTRAINT '' + QUOTENAME(cc.name) + '' CHECK '' + cc.definition  + '';'' COLLATE DATABASE_DEFAULT AS [column_definition]
             		   FROM    ' + QUOTENAME(@databasename) + N'.sys.check_constraints AS cc
             		   JOIN    ' + QUOTENAME(@databasename) + N'.sys.tables AS t
             		   ON      t.object_id = cc.parent_object_id
             		   JOIN    ' + QUOTENAME(@databasename) + N'.sys.schemas AS s
             		   ON      s.schema_id = t.schema_id
             		   OPTION (RECOMPILE);';

                            insert #checkconstraints
                            (database_id, [database_name], table_name, schema_name, constraint_name, is_disabled,
                             definition,
                             uses_database_collation, is_not_trusted, is_function, column_definition)
                                exec sp_executesql @dsql, @params = N'@i_DatabaseName NVARCHAR(128)',
                                     @i_databasename = @databasename;


                            set @dsql = N'SELECT DB_ID(@i_DatabaseName) AS [database_id],
             				   @i_DatabaseName AS database_name,
                               s.name AS missing_schema_name,
                               t.name AS missing_table_name,
                               i.name AS missing_index_name,
                               c.name AS missing_column_name
                        FROM   ' + QUOTENAME(@databasename) + N'.sys.sql_expression_dependencies AS sed
                        JOIN   ' + QUOTENAME(@databasename) + N'.sys.tables AS t
                            ON t.object_id = sed.referenced_id
                        JOIN   ' + QUOTENAME(@databasename) + N'.sys.schemas AS s
                            ON t.schema_id = s.schema_id
                        JOIN   ' + QUOTENAME(@databasename) + N'.sys.indexes AS i
                            ON i.object_id = sed.referenced_id
                            AND i.index_id = sed.referencing_minor_id
                        JOIN   ' + QUOTENAME(@databasename) + N'.sys.columns AS c
                            ON c.object_id = sed.referenced_id
                            AND c.column_id = sed.referenced_minor_id
                        WHERE  sed.referencing_class = 7
                        AND    sed.referenced_class = 1
                        AND    i.has_filter = 1
                        AND    NOT EXISTS (   SELECT 1/0
                                              FROM   ' + QUOTENAME(@databasename) + N'.sys.index_columns AS ic
                                              WHERE  ic.index_id = sed.referencing_minor_id
                                              AND    ic.column_id = sed.referenced_minor_id
                                              AND    ic.object_id = sed.referenced_id )
                        OPTION(RECOMPILE);'

                            insert #filteredindexes (database_id, database_name, schema_name, table_name, index_name,
                                                     column_name)
                                exec sp_executesql @dsql, @params = N'@i_DatabaseName NVARCHAR(128)',
                                     @i_databasename = @databasename;


                        end;

                end;
            end try
            begin catch
                raiserror (N'Failure populating temp tables.', 0,1) with nowait;

                if @dsql is not null
                    begin
                        set @msg = 'Last @dsql: ' + @dsql;
                        raiserror (@msg, 0, 1) with nowait;
                    end;

                select @msg = @databasename + N' database failed to process. ' + ERROR_MESSAGE(),
                       @errorseverity = ERROR_SEVERITY(),
                       @errorstate = ERROR_STATE();
                raiserror (@msg,@errorseverity, @errorstate ) with nowait;


                while @@trancount > 0
                    rollback;

                return;
            end catch;
            fetch next from c1 into @databasename;
        end;
    deallocate c1;


    ----------------------------------------
--STEP 2: PREP THE TEMP TABLES
--EVERY QUERY AFTER THIS GOES AGAINST TEMP TABLES ONLY.
----------------------------------------

    raiserror (N'Updating #IndexSanity.key_column_names',0,1) with nowait;
update #indexsanity
set key_column_names = d1.key_column_names
from #indexsanity si
         cross apply (select RTRIM(STUFF((select N', ' + c.column_name
                                                     + N' {' + system_type_name + N' ' +
                                                 case max_length
                                                     when -1 then N'(max)'
                                                     else
                                                         case
                                                             when system_type_name in (N'char', N'varchar', N'binary', N'varbinary')
                                                                 then N'(' + CAST(max_length as nvarchar(20)) + N')'
                                                             when system_type_name in (N'nchar', N'nvarchar')
                                                                 then N'(' + CAST(max_length / 2 as nvarchar(20)) + N')'
                                                             else ''
                                                             end
                                                     end
                                                     + N'}'
                                                     as col_definition
                                          from #indexcolumns c
                                          where c.database_id = si.database_id
                                            and c.schema_name = si.schema_name
                                            and c.object_id = si.object_id
                                            and c.index_id = si.index_id
                                            and c.is_included_column = 0 /*Just Keys*/
                                            and c.key_ordinal > 0 /*Ignore non-key columns, such as partitioning keys*/
                                          order by c.object_id, c.index_id, c.key_ordinal
                                          for xml path('') ,type).value('.', 'nvarchar(max)'), 1, 1, ''))
) d1 (key_column_names);

    raiserror (N'Updating #IndexSanity.partition_key_column_name',0,1) with nowait;
update #indexsanity
set partition_key_column_name = d1.partition_key_column_name
from #indexsanity si
         cross apply (select RTRIM(STUFF((select N', ' + c.column_name as col_definition
                                          from #indexcolumns c
                                          where c.database_id = si.database_id
                                            and c.schema_name = si.schema_name
                                            and c.object_id = si.object_id
                                            and c.index_id = si.index_id
                                            and c.partition_ordinal <> 0 /*Just Partitioned Keys*/
                                          order by c.object_id, c.index_id, c.key_ordinal
                                          for xml path('') , type).value('.', 'nvarchar(max)'), 1, 1, ''))) d1
    (partition_key_column_name);

    raiserror (N'Updating #IndexSanity.key_column_names_with_sort_order',0,1) with nowait;
update #indexsanity
set key_column_names_with_sort_order = d2.key_column_names_with_sort_order
from #indexsanity si
         cross apply (select RTRIM(STUFF((select N', ' + c.column_name + case c.is_descending_key
                                                                             when 1 then N' DESC'
                                                                             else N''
    end
                                                     + N' {' + system_type_name + N' ' +
                                                 case max_length
                                                     when -1 then N'(max)'
                                                     else
                                                         case
                                                             when system_type_name in (N'char', N'varchar', N'binary', N'varbinary')
                                                                 then N'(' + CAST(max_length as nvarchar(20)) + N')'
                                                             when system_type_name in (N'nchar', N'nvarchar')
                                                                 then N'(' + CAST(max_length / 2 as nvarchar(20)) + N')'
                                                             else ''
                                                             end
                                                     end
                                                     + N'}'
                                                     as col_definition
                                          from #indexcolumns c
                                          where c.database_id = si.database_id
                                            and c.schema_name = si.schema_name
                                            and c.object_id = si.object_id
                                            and c.index_id = si.index_id
                                            and c.is_included_column = 0 /*Just Keys*/
                                            and c.key_ordinal > 0 /*Ignore non-key columns, such as partitioning keys*/
                                          order by c.object_id, c.index_id, c.key_ordinal
                                          for xml path('') , type).value('.', 'nvarchar(max)'), 1, 1, ''))
) d2 (key_column_names_with_sort_order);

    raiserror (N'Updating #IndexSanity.key_column_names_with_sort_order_no_types (for create tsql)',0,1) with nowait;
update #indexsanity
set key_column_names_with_sort_order_no_types = d2.key_column_names_with_sort_order_no_types
from #indexsanity si
         cross apply (select RTRIM(STUFF((select N', ' + QUOTENAME(c.column_name) + case c.is_descending_key
                                                                                        when 1 then N' DESC'
                                                                                        else N''
    end as col_definition
                                          from #indexcolumns c
                                          where c.database_id = si.database_id
                                            and c.schema_name = si.schema_name
                                            and c.object_id = si.object_id
                                            and c.index_id = si.index_id
                                            and c.is_included_column = 0 /*Just Keys*/
                                            and c.key_ordinal > 0 /*Ignore non-key columns, such as partitioning keys*/
                                          order by c.object_id, c.index_id, c.key_ordinal
                                          for xml path('') , type).value('.', 'nvarchar(max)'), 1, 1, ''))
) d2 (key_column_names_with_sort_order_no_types);

    raiserror (N'Updating #IndexSanity.include_column_names',0,1) with nowait;
update #indexsanity
set include_column_names = d3.include_column_names
from #indexsanity si
         cross apply (select RTRIM(STUFF((select N', ' + c.column_name
                                                     + N' {' + system_type_name + N' ' +
                                                 CAST(max_length as nvarchar(50)) + N'}'
                                          from #indexcolumns c
                                          where c.database_id = si.database_id
                                            and c.schema_name = si.schema_name
                                            and c.object_id = si.object_id
                                            and c.index_id = si.index_id
                                            and c.is_included_column = 1 /*Just includes*/
                                          order by c.column_name /*Order doesn't matter in includes,
                                this is here to make rows easy to compare.*/
                                          for xml path('') , type).value('.', 'nvarchar(max)'), 1, 1, ''))
) d3 (include_column_names);

    raiserror (N'Updating #IndexSanity.include_column_names_no_types (for create tsql)',0,1) with nowait;
update #indexsanity
set include_column_names_no_types = d3.include_column_names_no_types
from #indexsanity si
         cross apply (select RTRIM(STUFF((select N', ' + QUOTENAME(c.column_name)
                                          from #indexcolumns c
                                          where c.database_id = si.database_id
                                            and c.schema_name = si.schema_name
                                            and c.object_id = si.object_id
                                            and c.index_id = si.index_id
                                            and c.is_included_column = 1 /*Just includes*/
                                          order by c.column_name /*Order doesn't matter in includes,
                                this is here to make rows easy to compare.*/
                                          for xml path('') , type).value('.', 'nvarchar(max)'), 1, 1, ''))
) d3 (include_column_names_no_types);

    raiserror (N'Updating #IndexSanity.count_key_columns and count_include_columns',0,1) with nowait;
update #indexsanity
set count_included_columns = d4.count_included_columns,
    count_key_columns      = d4.count_key_columns
from #indexsanity si
         cross apply (select SUM(case
                                     when is_included_column = 'true' then 1
                                     else 0
    end)                              as count_included_columns,
                             SUM(case
                                     when is_included_column = 'false' and c.key_ordinal > 0 then 1
                                     else 0
                                 end) as count_key_columns
                      from #indexcolumns c
                      where c.database_id = si.database_id
                        and c.schema_name = si.schema_name
                        and c.object_id = si.object_id
                        and c.index_id = si.index_id
) as d4 (count_included_columns, count_key_columns);

    raiserror (N'Updating index_sanity_id on #IndexPartitionSanity',0,1) with nowait;
update #indexpartitionsanity
set index_sanity_id = i.index_sanity_id
from #indexpartitionsanity ps
         join #indexsanity i on ps.[object_id] = i.[object_id]
    and ps.index_id = i.index_id
    and i.database_id = ps.database_id
    and i.schema_name = ps.schema_name;


    raiserror (N'Inserting data into #IndexSanitySize',0,1) with nowait;
insert #indexsanitysize ([index_sanity_id], [database_id], [schema_name], partition_count, total_rows,
                         total_reserved_mb,
                         total_reserved_lob_mb, total_reserved_row_overflow_mb, total_range_scan_count,
                         total_singleton_lookup_count, total_leaf_delete_count, total_leaf_update_count,
                         total_forwarded_fetch_count, total_row_lock_count,
                         total_row_lock_wait_count, total_row_lock_wait_in_ms, avg_row_lock_wait_in_ms,
                         total_page_lock_count, total_page_lock_wait_count, total_page_lock_wait_in_ms,
                         avg_page_lock_wait_in_ms, total_index_lock_promotion_attempt_count,
                         total_index_lock_promotion_count, data_compression_desc,
                         page_latch_wait_count, page_latch_wait_in_ms, page_io_latch_wait_count,
                         page_io_latch_wait_in_ms)
select index_sanity_id,
       ipp.database_id,
       ipp.schema_name,
       COUNT(*),
       SUM(row_count),
       SUM(reserved_mb),
       SUM(reserved_lob_mb),
       SUM(reserved_row_overflow_mb),
       SUM(range_scan_count),
       SUM(singleton_lookup_count),
       SUM(leaf_delete_count),
       SUM(leaf_update_count),
       SUM(forwarded_fetch_count),
       SUM(row_lock_count),
       SUM(row_lock_wait_count),
       SUM(row_lock_wait_in_ms),
       case
           when SUM(row_lock_wait_in_ms) > 0 then
               SUM(row_lock_wait_in_ms) / (1. * SUM(row_lock_wait_count))
           else 0 end as avg_row_lock_wait_in_ms,
       SUM(page_lock_count),
       SUM(page_lock_wait_count),
       SUM(page_lock_wait_in_ms),
       case
           when SUM(page_lock_wait_in_ms) > 0 then
               SUM(page_lock_wait_in_ms) / (1. * SUM(page_lock_wait_count))
           else 0 end as avg_page_lock_wait_in_ms,
       SUM(index_lock_promotion_attempt_count),
       SUM(index_lock_promotion_count),
       LEFT(MAX(data_compression_info.data_compression_rollup), 4000),
       SUM(page_latch_wait_count),
       SUM(page_latch_wait_in_ms),
       SUM(page_io_latch_wait_count),
       SUM(page_io_latch_wait_in_ms)
from #indexpartitionsanity ipp
         /* individual partitions can have distinct compression settings, just roll them into a list here*/
         outer apply (select STUFF((
                                       select N', ' + data_compression_desc
                                       from #indexpartitionsanity ipp2
                                       where ipp.[object_id] = ipp2.[object_id]
                                         and ipp.[index_id] = ipp2.[index_id]
                                         and ipp.database_id = ipp2.database_id
                                         and ipp.schema_name = ipp2.schema_name
                                       order by ipp2.partition_number
                                       for xml path(''),type).value('.', 'nvarchar(max)'), 1, 1,
                                   '')) data_compression_info(data_compression_rollup)
group by index_sanity_id, ipp.database_id, ipp.schema_name
order by index_sanity_id
option ( recompile );

    raiserror (N'Determining index usefulness',0,1) with nowait;
update #missingindexes
set is_low = case
                 when (user_seeks + user_scans) < 5000
                     or unique_compiles = 1
                     then 1
                 else 0
    end;

    raiserror (N'Updating #IndexSanity.referenced_by_foreign_key',0,1) with nowait;
update #indexsanity
set is_referenced_by_foreign_key=1
from #indexsanity s
         join #foreignkeys fk on
        s.object_id = fk.referenced_object_id
        and s.database_id = fk.database_id
        and LEFT(s.key_column_names, LEN(fk.referenced_fk_columns)) = fk.referenced_fk_columns;

    raiserror (N'Update index_secret on #IndexSanity for NC indexes.',0,1) with nowait;
update nc
set secret_columns=
        N'[' +
        case tb.count_key_columns when 0 then '1' else CAST(tb.count_key_columns as nvarchar(10)) end +
        case nc.is_unique when 1 then N' INCLUDE' else N' KEY' end +
        case when tb.count_key_columns > 1 then N'S] ' else N'] ' end +
        case tb.index_id
            when 0 then '[RID]'
            else LTRIM(tb.key_column_names) +
                /* Uniquifiers only needed on non-unique clustereds-- not heaps */
                 case tb.is_unique when 0 then ' [UNIQUIFIER]' else N'' end
            end
  , count_secret_columns=
    case tb.index_id
        when 0 then 1
        else
                tb.count_key_columns +
                case tb.is_unique when 0 then 1 else 0 end
        end
from #indexsanity as nc
         join #indexsanity as tb on nc.object_id = tb.object_id
    and nc.database_id = tb.database_id
    and nc.schema_name = tb.schema_name
    and tb.index_id in (0, 1)
where nc.index_id > 1;

    raiserror (N'Update index_secret on #IndexSanity for heaps and non-unique clustered.',0,1) with nowait;
update tb
set secret_columns= case tb.index_id when 0 then '[RID]' else '[UNIQUIFIER]' end
  , count_secret_columns = 1
from #indexsanity as tb
where tb.index_id = 0 /*Heaps-- these have the RID */
   or (tb.index_id = 1 and tb.is_unique = 0); /* Non-unique CX: has uniquifer (when needed) */


    raiserror (N'Populate #IndexCreateTsql.',0,1) with nowait;
insert #indexcreatetsql (index_sanity_id, create_tsql)
select index_sanity_id,
       ISNULL(
               case index_id
                   when 0 then N'ALTER TABLE ' + QUOTENAME([database_name]) + N'.' + QUOTENAME([schema_name]) + N'.' +
                               QUOTENAME([object_name]) + ' REBUILD;'
                   else
                       case
                           when is_xml = 1 or is_spatial = 1 or is_in_memory_oltp = 1
                               then N'' /* Not even trying for these just yet...*/
                           else
                                   case
                                       when is_primary_key = 1 then
                                               N'ALTER TABLE ' + QUOTENAME([database_name]) + N'.' +
                                               QUOTENAME([schema_name]) +
                                               N'.' + QUOTENAME([object_name]) +
                                               N' ADD CONSTRAINT [' +
                                               index_name +
                                               N'] PRIMARY KEY ' +
                                               case when index_id = 1 then N'CLUSTERED (' else N'(' end +
                                               key_column_names_with_sort_order_no_types + N' )'
                                       when is_cx_columnstore = 1 then
                                               N'CREATE CLUSTERED COLUMNSTORE INDEX ' + QUOTENAME(index_name) +
                                               N' on ' + QUOTENAME([database_name]) + N'.' + QUOTENAME([schema_name]) +
                                               N'.' + QUOTENAME([object_name])
                                       else /*Else not a PK or cx columnstore */
                                               N'CREATE ' +
                                               case when is_unique = 1 then N'UNIQUE ' else N'' end +
                                               case when index_id = 1 then N'CLUSTERED ' else N'' end +
                                               case
                                                   when is_nc_columnstore = 1 then N'NONCLUSTERED COLUMNSTORE '
                                                   else N'' end +
                                               N'INDEX ['
                                               + index_name + N'] ON ' +
                                               QUOTENAME([database_name]) + N'.' +
                                               QUOTENAME([schema_name]) + N'.' + QUOTENAME([object_name]) +
                                               case
                                                   when is_nc_columnstore = 1 then
                                                       N' (' + ISNULL(include_column_names_no_types, '') + N' )'
                                                   else /*Else not columnstore */
                                                           N' (' +
                                                           ISNULL(key_column_names_with_sort_order_no_types, '') + N' )'
                                                           + case
                                                                 when include_column_names_no_types is not null then
                                                                     N' INCLUDE (' + include_column_names_no_types + N')'
                                                                 else N''
                                                               end
                                                   end /*End non-columnstore case */
                                               + case
                                                     when filter_definition <> N'' then N' WHERE ' + filter_definition
                                                     else N'' end
                                       end /*End Non-PK index CASE */
                                   + case
                                         when is_nc_columnstore = 0 and is_cx_columnstore = 0 then
                                                 N' WITH ('
                                                 + N'FILLFACTOR=' + case fill_factor
                                                                        when 0 then N'100'
                                                                        else CAST(fill_factor as nvarchar(5)) end + ', '
                                                 + N'ONLINE=?, SORT_IN_TEMPDB=?, DATA_COMPRESSION=?'
                                                 + N')'
                                         else N'' end
                                   + N';'
                           end /*End non-spatial and non-xml CASE */
                   end, '[Unknown Error]')
           as create_tsql
from #indexsanity;

    raiserror (N'Populate #PartitionCompressionInfo.',0,1) with nowait;
with maps
         as
         (
             select ips.index_sanity_id,
                    ips.partition_number,
                    ips.data_compression_desc,
                    ips.partition_number -
                    ROW_NUMBER() over ( partition by ips.index_sanity_id, ips.data_compression_desc
                        order by ips.partition_number ) as rn
             from #indexpartitionsanity as ips
         )
select *
into #maps
from maps;

with grps
         as
         (
             select MIN(maps.partition_number) as minkey,
                    MAX(maps.partition_number) as maxkey,
                    maps.index_sanity_id,
                    maps.data_compression_desc
             from #maps as maps
             group by maps.rn, maps.index_sanity_id, maps.data_compression_desc
         )
select *
into #grps
from grps;

insert #partitioncompressioninfo (index_sanity_id, partition_compression_detail)
select distinct grps.index_sanity_id,
                SUBSTRING(
                        (STUFF(
                                (select N', ' + N' Partition'
                                            + case
                                                  when grps2.minkey < grps2.maxkey
                                                      then
                                                          + N's ' + CAST(grps2.minkey as nvarchar(10)) + N' - '
                                                          + CAST(grps2.maxkey as nvarchar(10)) + N' use ' +
                                                          grps2.data_compression_desc
                                                  else
                                                          N' ' + CAST(grps2.minkey as nvarchar(10)) + N' uses ' +
                                                          grps2.data_compression_desc
                                            end as partitions
                                 from #grps as grps2
                                 where grps2.index_sanity_id = grps.index_sanity_id
                                 order by grps2.minkey, grps2.maxkey
                                 for xml path(''), type).value('.', 'NVARCHAR(MAX)'), 1, 1, '')), 0,
                        8000) as partition_compression_detail
from #grps as grps;

    raiserror (N'Update #PartitionCompressionInfo.',0,1) with nowait;
update sz
set sz.data_compression_desc = pci.partition_compression_detail
from #indexsanitysize sz
         join #partitioncompressioninfo as pci
              on pci.index_sanity_id = sz.index_sanity_id;

    raiserror (N'Update #IndexSanity for filtered indexes with columns not in the index definition.',0,1) with nowait;
update #indexsanity
set filter_columns_not_in_index = d1.filter_columns_not_in_index
from #indexsanity si
         cross apply (select RTRIM(STUFF((select N', ' + c.column_name as col_definition
                                          from #filteredindexes as c
                                          where c.database_id = si.database_id
                                            and c.schema_name = si.schema_name
                                            and c.table_name = si.object_name
                                            and c.index_name = si.index_name
                                          order by c.index_sanity_id
                                          for xml path('') , type).value('.', 'nvarchar(max)'), 1, 1, ''))) d1
    (filter_columns_not_in_index);


    if @debug = 1
        begin
            select '#IndexSanity' as table_name, * from #indexsanity;
            select '#IndexPartitionSanity' as table_name, * from #indexpartitionsanity;
            select '#IndexSanitySize' as table_name, * from #indexsanitysize;
            select '#IndexColumns' as table_name, * from #indexcolumns;
            select '#MissingIndexes' as table_name, * from #missingindexes;
            select '#ForeignKeys' as table_name, * from #foreignkeys;
            select '#BlitzIndexResults' as table_name, * from #blitzindexresults;
            select '#IndexCreateTsql' as table_name, * from #indexcreatetsql;
            select '#DatabaseList' as table_name, * from #databaselist;
            select '#Statistics' as table_name, * from #statistics;
            select '#PartitionCompressionInfo' as table_name, * from #partitioncompressioninfo;
            select '#ComputedColumns' as table_name, * from #computedcolumns;
            select '#TraceStatus' as table_name, * from #tracestatus;
            select '#CheckConstraints' as table_name, * from #checkconstraints;
            select '#FilteredIndexes' as table_name, * from #filteredindexes;
        end


    ----------------------------------------
--STEP 3: DIAGNOSE THE PATIENT
----------------------------------------


begin try
    ----------------------------------------
--If @TableName is specified, just return information for that table.
--The @Mode parameter doesn't matter if you're looking at a specific table.
----------------------------------------
    if @tablename is not null
        begin
            raiserror (N'@TableName specified, giving detail only on that table.', 0,1) with nowait;

            --We do a left join here in case this is a disabled NC.
            --In that case, it won't have any size info/pages allocated.


            with table_mode_cte as (
                select s.db_schema_object_indexid,
                       s.key_column_names,
                       s.index_definition,
                       ISNULL(s.secret_columns, N'')                                                  as secret_columns,
                       s.fill_factor,
                       s.index_usage_summary,
                       sz.index_op_stats,
                       ISNULL(sz.index_size_summary, '') /*disabled NCs will be null*/                as index_size_summary,
                       partition_compression_detail,
                       ISNULL(sz.index_lock_wait_summary, '')                                         as index_lock_wait_summary,
                       s.is_referenced_by_foreign_key,
                       (select COUNT(*)
                        from #foreignkeys fk
                        where fk.parent_object_id = s.object_id
                          and PATINDEX(fk.parent_fk_columns, s.key_column_names) = 1)                 as fks_covered_by_index,
                       s.last_user_seek,
                       s.last_user_scan,
                       s.last_user_lookup,
                       s.last_user_update,
                       s.create_date,
                       s.modify_date,
                       sz.page_latch_wait_count,
                       CONVERT(varchar(10), (sz.page_latch_wait_in_ms / 1000) / 86400) + ':' +
                       CONVERT(varchar(20), DATEADD(s, (sz.page_latch_wait_in_ms / 1000), 0),
                                            108)                                                      as page_latch_wait_time,
                       sz.page_io_latch_wait_count,
                       CONVERT(varchar(10), (sz.page_io_latch_wait_in_ms / 1000) / 86400) + ':' +
                       CONVERT(varchar(20), DATEADD(s, (sz.page_io_latch_wait_in_ms / 1000), 0),
                                            108)                                                      as page_io_latch_wait_time,
                       ct.create_tsql,
                       case
                           when s.is_primary_key = 1 and s.index_definition <> '[HEAP]'
                               then N'--ALTER TABLE ' + QUOTENAME(s.[database_name]) + N'.' +
                                    QUOTENAME(s.[schema_name]) + N'.' + QUOTENAME(s.[object_name])
                               + N' DROP CONSTRAINT ' + QUOTENAME(s.index_name) + N';'
                           when s.is_primary_key = 0 and s.index_definition <> '[HEAP]'
                               then N'--DROP INDEX ' + QUOTENAME(s.index_name) + N' ON ' +
                                    QUOTENAME(s.[database_name]) + N'.' +
                                    QUOTENAME(s.[schema_name]) + N'.' + QUOTENAME(s.[object_name]) + N';'
                           else N''
                           end                                                                        as drop_tsql,
                       1                                                                              as display_order
                from #indexsanity s
                         left join #indexsanitysize sz on
                    s.index_sanity_id = sz.index_sanity_id
                         left join #indexcreatetsql ct on
                    s.index_sanity_id = ct.index_sanity_id
                         left join #partitioncompressioninfo pci on
                    pci.index_sanity_id = s.index_sanity_id
                where s.[object_id] = @objectid
                union all
                select N'Database ' + QUOTENAME(@databasename) + N' as of ' + CONVERT(nvarchar(16), GETDATE(), 121) +
                       N' (' + @scriptversionname + ')',
                       N'SQL Server First Responder Kit',
                       N'http://FirstResponderKit.org',
                       N'From Your Community Volunteers',
                       null,
                       @daysuptimeinsertvalue,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       null,
                       0 as display_order
            )
            select db_schema_object_indexid     as [Details: db_schema.table.index(indexid)],
                   index_definition             as [Definition: [Property]] ColumnName {datatype maxbytes}],
                   secret_columns               as [Secret Columns],
                   fill_factor                  as [Fillfactor],
                   index_usage_summary          as [Usage Stats],
                   index_op_stats               as [Op Stats],
                   index_size_summary           as [Size],
                   partition_compression_detail as [Compression Type],
                   index_lock_wait_summary      as [Lock Waits],
                   is_referenced_by_foreign_key as [Referenced by FK?],
                   fks_covered_by_index         as [FK Covered by Index?],
                   last_user_seek               as [Last User Seek],
                   last_user_scan               as [Last User Scan],
                   last_user_lookup             as [Last User Lookup],
                   last_user_update             as [Last User Write],
                   create_date                  as [Created],
                   modify_date                  as [Last Modified],
                   page_latch_wait_count        as [Page Latch Wait Count],
                   page_latch_wait_time         as [Page Latch Wait Time (D:H:M:S)],
                   page_io_latch_wait_count     as [Page IO Latch Wait Count],
                   page_io_latch_wait_time      as [Page IO Latch Wait Time (D:H:M:S)],
                   create_tsql                  as [Create TSQL],
                   drop_tsql                    as [Drop TSQL]
            from table_mode_cte
            order by display_order asc, key_column_names asc
            option ( recompile );

            if (select top 1 [object_id] from #missingindexes mi) is not null
                begin
                    ;

                    with create_date as (
                        select i.database_id,
                               i.schema_name,
                               i.[object_id],
                               ISNULL(NULLIF(MAX(DATEDIFF(day, i.create_date, SYSDATETIME())), 0), 1) as create_days
                        from #indexsanity as i
                        group by i.database_id, i.schema_name, i.object_id
                    )
                    select N'Missing index.'                       as finding,
                           N'http://BrentOzar.com/go/Indexaphobia' as url,
                           mi.[statement] +
                           ' Est. Benefit: '
                               + case
                                     when magic_benefit_number >= 922337203685477 then '>= 922,337,203,685,477'
                                     else REPLACE(CONVERT(nvarchar(256), CAST(CAST(
                                             (magic_benefit_number / case
                                                                         when cd.create_days < @daysuptime
                                                                             then cd.create_days
                                                                         else @daysuptime end)
                                         as bigint) as money), 1), '.00', '')
                               end                                 as [Estimated Benefit],
                           missing_index_details                   as [Missing Index Request],
                           index_estimated_impact                  as [Estimated Impact],
                           create_tsql                             as [Create TSQL]
                    from #missingindexes mi
                             left join create_date as cd
                                       on mi.[object_id] = cd.object_id
                                           and mi.database_id = cd.database_id
                                           and mi.schema_name = cd.schema_name
                    where mi.[object_id] = @objectid
                        /* Minimum benefit threshold = 100k/day of uptime OR since table creation date, whichever is lower*/
                      and (magic_benefit_number /
                           case when cd.create_days < @daysuptime then cd.create_days else @daysuptime end) >= 100000
                    order by magic_benefit_number desc
                    option ( recompile );
                end;
            else
                select 'No missing indexes.' as finding;

            select column_name                                      as [Column Name],
                   (select COUNT(*)
                    from #indexcolumns c2
                    where c2.column_name = c.column_name
                      and c2.key_ordinal is not null)
                       + case
                             when c.index_id = 1 and c.key_ordinal is not null then
                                     -1 + (select COUNT(distinct index_id)
                                           from #indexcolumns c3
                                           where c3.index_id not in (0, 1))
                             else 0 end
                                                                    as [Found In],
                   system_type_name +
                   case max_length
                       when -1 then N' (max)'
                       else
                           case
                               when system_type_name in (N'char', N'varchar', N'binary', N'varbinary')
                                   then N' (' + CAST(max_length as nvarchar(20)) + N')'
                               when system_type_name in (N'nchar', N'nvarchar')
                                   then N' (' + CAST(max_length / 2 as nvarchar(20)) + N')'
                               else ''
                               end
                       end
                                                                    as [Type],
                   case is_computed when 1 then 'yes' else '' end   as [Computed?],
                   max_length                                       as [Length (max bytes)],
                   [precision]                                      as [Prec],
                   [scale]                                          as [Scale],
                   case is_nullable when 1 then 'yes' else '' end   as [Nullable?],
                   case is_identity when 1 then 'yes' else '' end   as [Identity?],
                   case is_replicated when 1 then 'yes' else '' end as [Replicated?],
                   case is_sparse when 1 then 'yes' else '' end     as [Sparse?],
                   case is_filestream when 1 then 'yes' else '' end as [Filestream?],
                   collation_name                                   as [Collation]
            from #indexcolumns as c
            where index_id in (0, 1);

            if (select top 1 parent_object_id from #foreignkeys) is not null
                begin
                    select [database_name] + N':' + parent_object_name + N': ' + foreign_key_name as [Foreign Key],
                           parent_fk_columns                                                      as [Foreign Key Columns],
                           referenced_object_name                                                 as [Referenced Table],
                           referenced_fk_columns                                                  as [Referenced Table Columns],
                           is_disabled                                                            as [Is Disabled?],
                           is_not_trusted                                                         as [Not Trusted?],
                           is_not_for_replication                                                    [Not for Replication?],
                           [update_referential_action_desc]                                       as [Cascading Updates?],
                           [delete_referential_action_desc]                                       as [Cascading Deletes?]
                    from #foreignkeys
                    order by [Foreign Key]
                    option ( recompile );
                end;
            else
                select 'No foreign keys.' as finding;

            /* Show histograms for all stats on this table. More info: https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/1900 */
            if EXISTS(select * from sys.all_objects where name = 'dm_db_stats_histogram')
                begin
                    set @dsql = N'SELECT s.name AS [Stat Name], c.name AS [Leading Column Name], hist.step_number AS [Step Number],
                        hist.range_high_key AS [Range High Key], hist.range_rows AS [Range Rows],
                        hist.equal_rows AS [Equal Rows], hist.distinct_range_rows AS [Distinct Range Rows], hist.average_range_rows AS [Average Range Rows],
                        s.auto_created AS [Auto-Created], s.user_created AS [User-Created],
                        props.last_updated AS [Last Updated], s.stats_id AS [StatsID]
                    FROM sys.stats AS s
                    INNER JOIN sys.stats_columns sc ON s.object_id = sc.object_id AND s.stats_id = sc.stats_id AND sc.stats_column_id = 1
                    INNER JOIN sys.columns c ON sc.object_id = c.object_id AND sc.column_id = c.column_id
                    CROSS APPLY sys.dm_db_stats_properties(s.object_id, s.stats_id) AS props
                    CROSS APPLY sys.dm_db_stats_histogram(s.[object_id], s.stats_id) AS hist
                    WHERE s.object_id = @ObjectID
                    ORDER BY s.auto_created, s.user_created, s.name, hist.step_number;';
                    exec sp_executesql @dsql, N'@ObjectID INT', @objectid;
                end


        end;

        --If @TableName is NOT specified...
--Act based on the @Mode and @Filter. (@Filter applies only when @Mode=0 "diagnose")
    else
        begin
            ;
            if @mode in (0, 4) /* DIAGNOSE*/
                begin
                    ;
                    raiserror (N'@Mode=0 or 4, we are diagnosing.', 0,1) with nowait;

                    ----------------------------------------
                    --Multiple Index Personalities: Check_id 0-10
                    ----------------------------------------
                    begin
                        ;

                        --SELECT  [object_id], key_column_names, database_id
                        --                   FROM        #IndexSanity
                        --                   WHERE  index_type IN (1,2) /* Clustered, NC only*/
                        --                        AND is_hypothetical = 0
                        --                        AND is_disabled = 0
                        --                   GROUP BY    [object_id], key_column_names, database_id
                        --                   HAVING    COUNT(*) > 1


                        raiserror ('check_id 1: Duplicate keys', 0,1) with nowait;
                        with duplicate_indexes
                                 as (select [object_id], key_column_names, database_id, [schema_name]
                                     from #indexsanity as ip
                                     where index_type in (1, 2) /* Clustered, NC only*/
                                       and is_hypothetical = 0
                                       and is_disabled = 0
                                       and is_primary_key = 0
                                       and EXISTS(
                                             select 1 / 0
                                             from #indexsanitysize ips
                                             where ip.index_sanity_id = ips.index_sanity_id
                                               and ip.database_id = ips.database_id
                                               and ip.schema_name = ips.schema_name
                                               and ips.total_reserved_mb >= case
                                                                                when (@getalldatabases = 1 or @mode = 0)
                                                                                    then @thresholdmb
                                                                                else ips.total_reserved_mb
                                                 end
                                         )
                                     group by [object_id], key_column_names, database_id, [schema_name]
                                     having COUNT(*) > 1)
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 1                                                                             as check_id,
                               ip.index_sanity_id,
                               50                                                                            as priority,
                               'Multiple Index Personalities'                                                as findings_group,
                               'Duplicate keys'                                                              as finding,
                               [database_name]                                                               as [Database Name],
                               N'http://BrentOzar.com/go/duplicateindex'                                     as url,
                               N'Index Name: ' + ip.index_name + N' Table Name: ' + ip.db_schema_object_name as details,
                               ip.index_definition,
                               ip.secret_columns,
                               ip.index_usage_summary,
                               ips.index_size_summary
                        from duplicate_indexes di
                                 join #indexsanity ip on di.[object_id] = ip.[object_id]
                            and ip.database_id = di.database_id
                            and ip.[schema_name] = di.[schema_name]
                            and di.key_column_names = ip.key_column_names
                                 join #indexsanitysize ips on ip.index_sanity_id = ips.index_sanity_id
                            and ip.database_id = ips.database_id
                            and ip.schema_name = ips.schema_name
                            /* WHERE clause limits to only @ThresholdMB or larger duplicate indexes when getting all databases or using PainRelief mode */
                        where ips.total_reserved_mb >= case
                                                           when (@getalldatabases = 1 or @mode = 0) then @thresholdmb
                                                           else ips.total_reserved_mb end
                          and ip.is_primary_key = 0
                        order by ip.object_id, ip.key_column_names_with_sort_order
                        option ( recompile );

                        raiserror ('check_id 2: Keys w/ identical leading columns.', 0,1) with nowait;
                        with borderline_duplicate_indexes
                                 as (select distinct database_id,
                                                     [object_id],
                                                     first_key_column_name,
                                                     key_column_names,
                                                     COUNT([object_id])
                                                           over ( partition by database_id, [object_id], first_key_column_name ) as number_dupes
                                     from #indexsanity
                                     where index_type in (1, 2) /* Clustered, NC only*/
                                       and is_hypothetical = 0
                                       and is_disabled = 0
                                       and is_primary_key = 0)
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 2                                         as check_id,
                               ip.index_sanity_id,
                               60                                        as priority,
                               'Multiple Index Personalities'            as findings_group,
                               'Borderline duplicate keys'               as finding,
                               [database_name]                           as [Database Name],
                               N'http://BrentOzar.com/go/duplicateindex' as url,
                               ip.db_schema_object_indexid               as details,
                               ip.index_definition,
                               ip.secret_columns,
                               ip.index_usage_summary,
                               ips.index_size_summary
                        from #indexsanity as ip
                                 join #indexsanitysize ips on ip.index_sanity_id = ips.index_sanity_id
                        where EXISTS(
                                select di.[object_id]
                                from borderline_duplicate_indexes as di
                                where di.[object_id] = ip.[object_id]
                                  and di.database_id = ip.database_id
                                  and di.first_key_column_name = ip.first_key_column_name
                                  and di.key_column_names <> ip.key_column_names
                                  and di.number_dupes > 1
                            )
                          and ip.is_primary_key = 0
                        order by ip.[schema_name], ip.[object_name], ip.key_column_names, ip.include_column_names
                        option ( recompile );

                    end;
                    ----------------------------------------
                    --Aggressive Indexes: Check_id 10-19
                    ----------------------------------------
                    begin
                        ;

                        raiserror (N'check_id 11: Total lock wait time > 5 minutes (row + page) with long average waits', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 11                                                                       as check_id,
                               i.index_sanity_id,
                               10                                                                       as priority,
                               N'Aggressive '
                                   + case COALESCE((select SUM(1)
                                                    from #indexsanity ime
                                                             inner join #indexsanity iothers
                                                                        on ime.database_id = iothers.database_id
                                                                            and ime.object_id = iothers.object_id
                                                                            and iothers.index_id > 1
                                                    where i.index_sanity_id = ime.index_sanity_id
                                                      and iothers.is_hypothetical = 0
                                                      and iothers.is_disabled = 0
                                                   ), 0)
                                         when 0 then N'Under-Indexing'
                                         when 1 then N'Under-Indexing'
                                         when 2 then N'Under-Indexing'
                                         when 3 then N'Under-Indexing'
                                         when 4 then N'Indexes'
                                         when 5 then N'Indexes'
                                         when 6 then N'Indexes'
                                         when 7 then N'Indexes'
                                         when 8 then N'Indexes'
                                         when 9 then N'Indexes'
                                         else N'Over-Indexing'
                                   end                                                                  as findings_group,
                               N'Total lock wait time > 5 minutes (row + page) with long average waits' as finding,
                               [database_name]                                                          as [Database Name],
                               N'http://BrentOzar.com/go/AggressiveIndexes'                             as url,
                               (i.db_schema_object_indexid + N': ' +
                                sz.index_lock_wait_summary + N' NC indexes on table: ') collate database_default +
                               CAST(COALESCE((select SUM(1)
                                              from #indexsanity ime
                                                       inner join #indexsanity iothers
                                                                  on ime.database_id = iothers.database_id
                                                                      and ime.object_id = iothers.object_id
                                                                      and iothers.index_id > 1
                                              where i.index_sanity_id = ime.index_sanity_id
                                                and iothers.is_hypothetical = 0
                                                and iothers.is_disabled = 0
                                             ), 0)
                                   as nvarchar(30))                                                     as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize as sz on i.index_sanity_id = sz.index_sanity_id
                        where (total_row_lock_wait_in_ms + total_page_lock_wait_in_ms) > 300000
                          and (sz.avg_page_lock_wait_in_ms + sz.avg_row_lock_wait_in_ms) > 5000
                        group by i.index_sanity_id, [database_name], i.db_schema_object_indexid,
                                 sz.index_lock_wait_summary, i.index_definition, i.secret_columns,
                                 i.index_usage_summary, sz.index_size_summary, sz.index_sanity_id
                        order by 4, [database_name], 8
                        option ( recompile );

                        raiserror (N'check_id 12: Total lock wait time > 5 minutes (row + page) with short average waits', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 12                                                                        as check_id,
                               i.index_sanity_id,
                               10                                                                        as priority,
                               N'Aggressive '
                                   + case COALESCE((select SUM(1)
                                                    from #indexsanity ime
                                                             inner join #indexsanity iothers
                                                                        on ime.database_id = iothers.database_id
                                                                            and ime.object_id = iothers.object_id
                                                                            and iothers.index_id > 1
                                                    where i.index_sanity_id = ime.index_sanity_id
                                                      and iothers.is_hypothetical = 0
                                                      and iothers.is_disabled = 0
                                                   ), 0)
                                         when 0 then N'Under-Indexing'
                                         when 1 then N'Under-Indexing'
                                         when 2 then N'Under-Indexing'
                                         when 3 then N'Under-Indexing'
                                         when 4 then N'Indexes'
                                         when 5 then N'Indexes'
                                         when 6 then N'Indexes'
                                         when 7 then N'Indexes'
                                         when 8 then N'Indexes'
                                         when 9 then N'Indexes'
                                         else N'Over-Indexing'
                                   end                                                                   as findings_group,
                               N'Total lock wait time > 5 minutes (row + page) with short average waits' as finding,
                               [database_name]                                                           as [Database Name],
                               N'http://BrentOzar.com/go/AggressiveIndexes'                              as url,
                               (i.db_schema_object_indexid + N': ' +
                                sz.index_lock_wait_summary + N' NC indexes on table: ') collate database_default +
                               CAST(COALESCE((select SUM(1)
                                              from #indexsanity ime
                                                       inner join #indexsanity iothers
                                                                  on ime.database_id = iothers.database_id
                                                                      and ime.object_id = iothers.object_id
                                                                      and iothers.index_id > 1
                                              where i.index_sanity_id = ime.index_sanity_id
                                                and iothers.is_hypothetical = 0
                                                and iothers.is_disabled = 0
                                             ), 0)
                                   as nvarchar(30))                                                      as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize as sz on i.index_sanity_id = sz.index_sanity_id
                        where (total_row_lock_wait_in_ms + total_page_lock_wait_in_ms) > 300000
                          and (sz.avg_page_lock_wait_in_ms + sz.avg_row_lock_wait_in_ms) < 5000
                        group by i.index_sanity_id, [database_name], i.db_schema_object_indexid,
                                 sz.index_lock_wait_summary, i.index_definition, i.secret_columns,
                                 i.index_usage_summary, sz.index_size_summary, sz.index_sanity_id
                        order by 4, [database_name], 8
                        option ( recompile );

                    end;

                    ----------------------------------------
                    --Index Hoarder: Check_id 20-29
                    ----------------------------------------
                    begin
                        raiserror (N'check_id 20: >=7 NC indexes on any given table. Yes, 7 is an arbitrary number.', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 20                                                                            as check_id,
                               MAX(i.index_sanity_id)                                                        as index_sanity_id,
                               100                                                                           as priority,
                               'Index Hoarder'                                                               as findings_group,
                               'Many NC indexes on a single table'                                           as finding,
                               [database_name]                                                               as [Database Name],
                               N'http://BrentOzar.com/go/IndexHoarder'                                       as url,
                               CAST(COUNT(*) as nvarchar(30)) + ' NC indexes on ' + i.db_schema_object_name  as details,
                               i.db_schema_object_name + ' (' + CAST(COUNT(*) as nvarchar(30)) +
                               ' indexes)'                                                                   as index_definition,
                               ''                                                                            as secret_columns,
                               REPLACE(CONVERT(nvarchar(30), CAST(SUM(total_reads) as money), 1), N'.00', N'') +
                               N' reads (ALL); '
                                   + REPLACE(CONVERT(nvarchar(30), CAST(SUM(user_updates) as money), 1), N'.00', N'') +
                               N' writes (ALL); ',
                               REPLACE(CONVERT(nvarchar(30), CAST(MAX(total_rows) as money), 1), N'.00', N'') +
                               N' rows (MAX)'
                                   + case
                                         when SUM(total_reserved_mb) > 1024 then
                                                 N'; ' + CAST(
                                                     CAST(SUM(total_reserved_mb) / 1024. as numeric(29, 1)) as nvarchar(30)) +
                                                 'GB (ALL)'
                                         when SUM(total_reserved_mb) > 0 then
                                                 N'; ' +
                                                 CAST(CAST(SUM(total_reserved_mb) as numeric(29, 1)) as nvarchar(30)) +
                                                 'MB (ALL)'
                                         else ''
                                   end                                                                       as index_size_summary
                        from #indexsanity i
                                 join #indexsanitysize ip on i.index_sanity_id = ip.index_sanity_id
                        where index_id not in (0, 1)
                        group by db_schema_object_name, [i].[database_name]
                        having COUNT(*) >= case
                                               when (@getalldatabases = 1 or @mode = 0)
                                                   then 21
                                               else 7
                            end
                        order by i.db_schema_object_name desc
                        option ( recompile );

                        if @filter = 1 /*@Filter=1 is "ignore unusued" */
                            begin
                                raiserror (N'Skipping checks on unused indexes (21 and 22) because @Filter=1', 0,1) with nowait;
                            end;
                        else /*Otherwise, go ahead and do the checks*/
                            begin
                                raiserror (N'check_id 21: >=5 percent of indexes are unused. Yes, 5 is an arbitrary number.', 0,1) with nowait;
                                declare @percent_nc_indexes_unused numeric(29, 1);
                                declare @nc_indexes_unused_reserved_mb numeric(29, 1);

                                select @percent_nc_indexes_unused = (100.00 * SUM(case
                                                                                      when total_reads = 0
                                                                                          then 1
                                                                                      else 0
                                    end)) / COUNT(*),
                                       @nc_indexes_unused_reserved_mb = SUM(case
                                                                                when total_reads = 0
                                                                                    then sz.total_reserved_mb
                                                                                else 0
                                           end)
                                from #indexsanity i
                                         join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                                where index_id not in (0, 1)
                                  and i.is_unique = 0
                                    /*Skipping tables created in the last week, or modified in past 2 days*/
                                  and i.create_date >= DATEADD(dd, -7, GETDATE())
                                  and i.modify_date > DATEADD(dd, -2, GETDATE())
                                option ( recompile );

                                if @percent_nc_indexes_unused >= 5
                                    insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group,
                                                               finding, [database_name], url, details, index_definition,
                                                               secret_columns, index_usage_summary, index_size_summary)
                                    select 21                                                                     as check_id,
                                           MAX(i.index_sanity_id)                                                 as index_sanity_id,
                                           150                                                                    as priority,
                                           N'Index Hoarder'                                                       as findings_group,
                                           N'More than 5 percent NC indexes are unused'                           as finding,
                                           [database_name]                                                        as [Database Name],
                                           N'http://BrentOzar.com/go/IndexHoarder'                                as url,
                                           CAST(@percent_nc_indexes_unused as nvarchar(30)) + N' percent NC indexes (' +
                                           CAST(COUNT(*) as nvarchar(10)) + N') unused. ' +
                                           N'These take up ' + CAST(@nc_indexes_unused_reserved_mb as nvarchar(30)) +
                                           N'MB of space.'                                                        as details,
                                           i.database_name + ' (' + CAST(COUNT(*) as nvarchar(30)) +
                                           N' indexes)'                                                           as index_definition,
                                           ''                                                                     as secret_columns,
                                           CAST(SUM(total_reads) as nvarchar(256)) + N' reads (ALL); '
                                               + CAST(SUM([user_updates]) as nvarchar(256)) +
                                           N' writes (ALL)'                                                       as index_usage_summary,

                                           REPLACE(CONVERT(nvarchar(30), CAST(MAX([total_rows]) as money), 1), '.00',
                                                   '') + N' rows (MAX)'
                                               + case
                                                     when SUM(total_reserved_mb) > 1024 then
                                                             N'; ' + CAST(
                                                                 CAST(SUM(total_reserved_mb) / 1024. as numeric(29, 1)) as nvarchar(30)) +
                                                             'GB (ALL)'
                                                     when SUM(total_reserved_mb) > 0 then
                                                             N'; ' + CAST(
                                                                 CAST(SUM(total_reserved_mb) as numeric(29, 1)) as nvarchar(30)) +
                                                             'MB (ALL)'
                                                     else ''
                                               end                                                                as index_size_summary
                                    from #indexsanity i
                                             join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                                    where index_id not in (0, 1)
                                      and i.is_unique = 0
                                      and total_reads = 0
                                      and not (@getalldatabases = 1 or @mode = 0)
                                        /*Skipping tables created in the last week, or modified in past 2 days*/
                                      and i.create_date >= DATEADD(dd, -7, GETDATE())
                                      and i.modify_date > DATEADD(dd, -2, GETDATE())
                                    group by i.database_name
                                    option ( recompile );

                                raiserror (N'check_id 22: NC indexes with 0 reads. (Borderline) and >= 10,000 writes', 0,1) with nowait;
                                insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                           [database_name], url, details, index_definition,
                                                           secret_columns, index_usage_summary, index_size_summary)
                                select 22                                      as check_id,
                                       i.index_sanity_id,
                                       100                                     as priority,
                                       N'Index Hoarder'                        as findings_group,
                                       N'Unused NC index with High Writes'     as finding,
                                       [database_name]                         as [Database Name],
                                       N'http://BrentOzar.com/go/IndexHoarder' as url,
                                       N'Reads: 0,'
                                           + N' Writes: '
                                           +
                                       REPLACE(CONVERT(nvarchar(30), CAST((i.user_updates) as money), 1), N'.00', N'')
                                           + N' on: '
                                           + i.db_schema_object_indexid
                                                                               as details,
                                       i.index_definition,
                                       i.secret_columns,
                                       i.index_usage_summary,
                                       sz.index_size_summary
                                from #indexsanity as i
                                         join #indexsanitysize as sz on i.index_sanity_id = sz.index_sanity_id
                                where i.total_reads = 0
                                  and i.user_updates >= 10000
                                  and i.index_id not in (0, 1) /*NCs only*/
                                  and i.is_unique = 0
                                  and sz.total_reserved_mb >= case
                                                                  when (@getalldatabases = 1 or @mode = 0)
                                                                      then @thresholdmb
                                                                  else sz.total_reserved_mb end
                                order by i.db_schema_object_indexid
                                option ( recompile );
                            end; /*end checks only run when @Filter <> 1*/

                        raiserror (N'check_id 23: Indexes with 7 or more columns. (Borderline)', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 23                                              as check_id,
                               i.index_sanity_id,
                               150                                             as priority,
                               N'Index Hoarder'                                as findings_group,
                               N'Borderline: Wide indexes (7 or more columns)' as finding,
                               [database_name]                                 as [Database Name],
                               N'http://BrentOzar.com/go/IndexHoarder'         as url,
                               CAST(count_key_columns + count_included_columns as nvarchar(10)) + ' columns on '
                                   + i.db_schema_object_indexid                as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize as sz on i.index_sanity_id = sz.index_sanity_id
                        where (count_key_columns + count_included_columns) >= 7
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 24: Wide clustered indexes (> 3 columns or > 16 bytes).', 0,1) with nowait;
                        with count_columns as (
                            select database_id,
                                   [object_id],
                                   SUM(case max_length when -1 then 0 else max_length end) as sum_max_length
                            from #indexcolumns ic
                            where index_id in (1, 0) /*Heap or clustered only*/
                              and key_ordinal > 0
                            group by database_id, object_id
                        )
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 24                                                  as check_id,
                               i.index_sanity_id,
                               150                                                 as priority,
                               N'Index Hoarder'                                    as findings_group,
                               N'Wide clustered index (> 3 columns OR > 16 bytes)' as finding,
                               [database_name]                                     as [Database Name],
                               N'http://BrentOzar.com/go/IndexHoarder'             as url,
                               CAST(i.count_key_columns as nvarchar(10)) + N' columns with potential size of '
                                   + CAST(cc.sum_max_length as nvarchar(10))
                                   + N' bytes in clustered index:' + i.db_schema_object_name
                                   + N'. ' +
                               (select CAST(COUNT(*) as nvarchar(23))
                                from #indexsanity i2
                                where i2.[object_id] = i.[object_id]
                                  and i2.database_id = i.database_id
                                  and i2.index_id <> 1
                                  and i2.is_disabled = 0
                                  and i2.is_hypothetical = 0)
                                   + N' NC indexes on the table.'
                                                                                   as details,
                               i.index_definition,
                               secret_columns,
                               i.index_usage_summary,
                               ip.index_size_summary
                        from #indexsanity i
                                 join #indexsanitysize ip on i.index_sanity_id = ip.index_sanity_id
                                 join count_columns as cc on i.[object_id] = cc.[object_id]
                            and i.database_id = cc.database_id
                        where index_id = 1 /* clustered only */
                          and not (@getalldatabases = 1 or @mode = 0)
                          and (count_key_columns > 3 /*More than three key columns.*/
                            or cc.sum_max_length > 16 /*More than 16 bytes in key */)
                          and i.is_cx_columnstore = 0
                        order by i.db_schema_object_name desc
                        option ( recompile );

                        raiserror (N'check_id 25: Addicted to nullable columns.', 0,1) with nowait;
                        with count_columns as (
                            select [object_id],
                                   [database_id],
                                   [schema_name],
                                   SUM(case is_nullable when 1 then 0 else 1 end) as non_nullable_columns,
                                   COUNT(*)                                       as total_columns
                            from #indexcolumns ic
                            where index_id in (1, 0) /*Heap or clustered only*/
                            group by [object_id],
                                     [database_id],
                                     [schema_name]
                        )
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 25                                      as check_id,
                               i.index_sanity_id,
                               200                                     as priority,
                               N'Index Hoarder'                        as findings_group,
                               N'Addicted to nulls'                    as finding,
                               [database_name]                         as [Database Name],
                               N'http://BrentOzar.com/go/IndexHoarder' as url,
                               i.db_schema_object_name
                                   + N' allows null in ' + CAST((total_columns - non_nullable_columns) as nvarchar(10))
                                   + N' of ' + CAST(total_columns as nvarchar(10))
                                   + N' columns.'                      as details,
                               i.index_definition,
                               secret_columns,
                               ISNULL(i.index_usage_summary, ''),
                               ISNULL(ip.index_size_summary, '')
                        from #indexsanity i
                                 join #indexsanitysize ip on i.index_sanity_id = ip.index_sanity_id
                                 join count_columns as cc on i.[object_id] = cc.[object_id]
                            and cc.database_id = ip.database_id
                            and cc.[schema_name] = ip.[schema_name]
                        where i.index_id in (1, 0)
                          and not (@getalldatabases = 1 or @mode = 0)
                          and cc.non_nullable_columns < 2
                          and cc.total_columns > 3
                        order by i.db_schema_object_name desc
                        option ( recompile );

                        raiserror (N'check_id 26: Wide tables (35+ cols or > 2000 non-LOB bytes).', 0,1) with nowait;
                        with count_columns as (
                            select [object_id],
                                   [database_id],
                                   [schema_name],
                                   SUM(case max_length when -1 then 1 else 0 end)          as count_lob_columns,
                                   SUM(case max_length when -1 then 0 else max_length end) as sum_max_length,
                                   COUNT(*)                                                as total_columns
                            from #indexcolumns ic
                            where index_id in (1, 0) /*Heap or clustered only*/
                            group by [object_id],
                                     [database_id],
                                     [schema_name]
                        )
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 26                                               as check_id,
                               i.index_sanity_id,
                               150                                              as priority,
                               N'Index Hoarder'                                 as findings_group,
                               N'Wide tables: 35+ cols or > 2000 non-LOB bytes' as finding,
                               [database_name]                                  as [Database Name],
                               N'http://BrentOzar.com/go/IndexHoarder'          as url,
                               i.db_schema_object_name
                                   + N' has ' + CAST((total_columns) as nvarchar(10))
                                   + N' total columns with a max possible width of ' +
                               CAST(sum_max_length as nvarchar(10))
                                   + N' bytes.' +
                               case
                                   when count_lob_columns > 0 then CAST((count_lob_columns) as nvarchar(10))
                                       + ' columns are LOB types.'
                                   else ''
                                   end
                                                                                as details,
                               i.index_definition,
                               secret_columns,
                               ISNULL(i.index_usage_summary, ''),
                               ISNULL(ip.index_size_summary, '')
                        from #indexsanity i
                                 join #indexsanitysize ip on i.index_sanity_id = ip.index_sanity_id
                                 join count_columns as cc on i.[object_id] = cc.[object_id]
                            and cc.database_id = i.database_id
                            and cc.[schema_name] = i.[schema_name]
                        where i.index_id in (1, 0)
                          and not (@getalldatabases = 1 or @mode = 0)
                          and (cc.total_columns >= 35 or
                               cc.sum_max_length >= 2000)
                        order by i.db_schema_object_name desc
                        option ( recompile );

                        raiserror (N'check_id 27: Addicted to strings.', 0,1) with nowait;
                        with count_columns as (
                            select [object_id],
                                   [database_id],
                                   [schema_name],
                                   SUM(case
                                           when system_type_name in ('varchar', 'nvarchar', 'char') or max_length = -1
                                               then 1
                                           else 0 end) as string_or_lob_columns,
                                   COUNT(*)            as total_columns
                            from #indexcolumns ic
                            where index_id in (1, 0) /*Heap or clustered only*/
                            group by [object_id],
                                     [database_id],
                                     [schema_name]
                        )
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 27                                                as check_id,
                               i.index_sanity_id,
                               200                                               as priority,
                               N'Index Hoarder'                                  as findings_group,
                               N'Addicted to strings'                            as finding,
                               [database_name]                                   as [Database Name],
                               N'http://BrentOzar.com/go/IndexHoarder'           as url,
                               i.db_schema_object_name
                                   + N' uses string or LOB types for ' + CAST((string_or_lob_columns) as nvarchar(10))
                                   + N' of ' + CAST(total_columns as nvarchar(10))
                                   + N' columns. Check if data types are valid.' as details,
                               i.index_definition,
                               secret_columns,
                               ISNULL(i.index_usage_summary, ''),
                               ISNULL(ip.index_size_summary, '')
                        from #indexsanity i
                                 join #indexsanitysize ip on i.index_sanity_id = ip.index_sanity_id
                                 join count_columns as cc on i.[object_id] = cc.[object_id]
                            and cc.database_id = i.database_id
                            and cc.[schema_name] = i.[schema_name]
                                 cross apply (select cc.total_columns - string_or_lob_columns as non_string_or_lob_columns) as calc1
                        where i.index_id in (1, 0)
                          and not (@getalldatabases = 1 or @mode = 0)
                          and calc1.non_string_or_lob_columns <= 1
                          and cc.total_columns > 3
                        order by i.db_schema_object_name desc
                        option ( recompile );

                        raiserror (N'check_id 28: Non-unique clustered index.', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 28                                      as check_id,
                               i.index_sanity_id,
                               100                                     as priority,
                               N'Index Hoarder'                        as findings_group,
                               N'Non-Unique clustered index'           as finding,
                               [database_name]                         as [Database Name],
                               N'http://BrentOzar.com/go/IndexHoarder' as url,
                               N'Uniquifiers will be required! Clustered index: ' + i.db_schema_object_name
                                   + N' and all NC indexes. ' +
                               (select CAST(COUNT(*) as nvarchar(23))
                                from #indexsanity i2
                                where i2.[object_id] = i.[object_id]
                                  and i2.database_id = i.database_id
                                  and i2.index_id <> 1
                                  and i2.is_disabled = 0
                                  and i2.is_hypothetical = 0)
                                   + N' NC indexes on the table.'
                                                                       as details,
                               i.index_definition,
                               secret_columns,
                               i.index_usage_summary,
                               ip.index_size_summary
                        from #indexsanity i
                                 join #indexsanitysize ip on i.index_sanity_id = ip.index_sanity_id
                        where index_id = 1 /* clustered only */
                          and not (@getalldatabases = 1 or @mode = 0)
                          and is_unique = 0 /* not unique */
                          and is_cx_columnstore = 0 /* not a clustered columnstore-- no unique option on those */
                        order by i.db_schema_object_name desc
                        option ( recompile );

                        raiserror (N'check_id 29: NC indexes with 0 reads. (Borderline) and < 10,000 writes', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 29                                        as check_id,
                               i.index_sanity_id,
                               150                                       as priority,
                               N'Index Hoarder'                          as findings_group,
                               N'Unused NC index with Low Writes'        as finding,
                               [database_name]                           as [Database Name],
                               N'http://BrentOzar.com/go/IndexHoarder'   as url,
                               N'0 reads: ' + i.db_schema_object_indexid as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize as sz on i.index_sanity_id = sz.index_sanity_id
                        where i.total_reads = 0
                          and i.user_updates < 10000
                          and i.index_id not in (0, 1) /*NCs only*/
                          and i.is_unique = 0
                          and sz.total_reserved_mb >= case
                                                          when (@getalldatabases = 1 or @mode = 0) then @thresholdmb
                                                          else sz.total_reserved_mb end
                            /*Skipping tables created in the last week, or modified in past 2 days*/
                          and i.create_date >= DATEADD(dd, -7, GETDATE())
                          and i.modify_date > DATEADD(dd, -2, GETDATE())
                          and not (@getalldatabases = 1 or @mode = 0)
                        order by i.db_schema_object_indexid
                        option ( recompile );

                    end;
                    ----------------------------------------
                    --Feature-Phobic Indexes: Check_id 30-39
                    ----------------------------------------
                    begin
                        raiserror (N'check_id 30: No indexes with includes', 0,1) with nowait;
                        /* This does not work the way you'd expect with @GetAllDatabases = 1. For details:
               https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/825
            */

                        select database_name,
                               SUM(case when count_included_columns > 0 then 1 else 0 end)                           as number_indexes_with_includes,
                               100. * SUM(case when count_included_columns > 0 then 1 else 0 end) /
                               (1.0 * COUNT(*))                                                                      as percent_indexes_with_includes
                        into #index_includes
                        from #indexsanity
                        where is_hypothetical = 0
                          and is_disabled = 0
                          and not (@getalldatabases = 1 or @mode = 0)
                        group by database_name;

                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 30                                      as check_id,
                               null                                    as index_sanity_id,
                               250                                     as priority,
                               N'Feature-Phobic Indexes'               as findings_group,
                               database_name                           as [Database Name],
                               N'No indexes use includes'              as finding,
                               'http://BrentOzar.com/go/IndexFeatures' as url,
                               N'No indexes use includes'              as details,
                               database_name + N' (Entire database)'   as index_definition,
                               N''                                     as secret_columns,
                               N'N/A'                                  as index_usage_summary,
                               N'N/A'                                  as index_size_summary
                        from #index_includes
                        where number_indexes_with_includes = 0
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 31: < 3 percent of indexes have includes', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 31                                                  as check_id,
                               null                                                as index_sanity_id,
                               150                                                 as priority,
                               N'Feature-Phobic Indexes'                           as findings_group,
                               N'Borderline: Includes are used in < 3% of indexes' as findings,
                               database_name                                       as [Database Name],
                               N'http://BrentOzar.com/go/IndexFeatures'            as url,
                               N'Only ' + CAST(percent_indexes_with_includes as nvarchar(20)) +
                               '% of indexes have includes'                        as details,
                               N'Entire database'                                  as index_definition,
                               N''                                                 as secret_columns,
                               N'N/A'                                              as index_usage_summary,
                               N'N/A'                                              as index_size_summary
                        from #index_includes
                        where number_indexes_with_includes > 0
                          and percent_indexes_with_includes <= 3
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 32: filtered indexes and indexed views', 0,1) with nowait;

                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select distinct 32                                                                        as check_id,
                                        null                                                                      as index_sanity_id,
                                        250                                                                       as priority,
                                        N'Feature-Phobic Indexes'                                                 as findings_group,
                                        N'Borderline: No filtered indexes or indexed views exist'                 as finding,
                                        i.database_name                                                           as [Database Name],
                                        N'http://BrentOzar.com/go/IndexFeatures'                                  as url,
                                        N'These are NOT always needed-- but do you know when you would use them?' as details,
                                        i.database_name + N' (Entire database)'                                   as index_definition,
                                        N''                                                                       as secret_columns,
                                        N'N/A'                                                                    as index_usage_summary,
                                        N'N/A'                                                                    as index_size_summary
                        from #indexsanity i
                        where i.database_name not in (
                            select database_name
                            from #indexsanity
                            where filter_definition <> '')
                          and i.database_name not in (
                            select database_name
                            from #indexsanity
                            where is_indexed_view = 1)
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );
                    end;

                    raiserror (N'check_id 33: Potential filtered indexes based on column names.', 0,1) with nowait;

                    insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                               [database_name], url, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary)
                    select 33                                                                                                               as check_id,
                           i.index_sanity_id                                                                                                as index_sanity_id,
                           250                                                                                                              as priority,
                           N'Feature-Phobic Indexes'                                                                                        as findings_group,
                           N'Potential filtered index (based on column name)'                                                               as finding,
                           [database_name]                                                                                                  as [Database Name],
                           N'http://BrentOzar.com/go/IndexFeatures'                                                                         as url,
                           N'A column name in this index suggests it might be a candidate for filtering (is%, %archive%, %active%, %flag%)' as details,
                           i.index_definition,
                           i.secret_columns,
                           i.index_usage_summary,
                           sz.index_size_summary
                    from #indexcolumns ic
                             join #indexsanity i on ic.[object_id] = i.[object_id]
                        and ic.database_id = i.database_id
                        and ic.schema_name = i.schema_name
                        and ic.[index_id] = i.[index_id]
                        and i.[index_id] > 1 /* non-clustered index */
                             join #indexsanitysize as sz on i.index_sanity_id = sz.index_sanity_id
                    where (column_name like 'is%'
                        or column_name like '%archive%'
                        or column_name like '%active%'
                        or column_name like '%flag%')
                      and not (@getalldatabases = 1 or @mode = 0)
                    option ( recompile );

                    raiserror (N'check_id 34: Filtered index definition columns not in index definition', 0,1) with nowait;

                    insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                               [database_name], url, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary)
                    select 34                                        as check_id,
                           i.index_sanity_id,
                           80                                        as priority,
                           N'Forgetful Indexes'                      as findings_group,
                           N'Filter Columns Not In Index Definition' as finding,
                           [database_name]                           as [Database Name],
                           N'http://BrentOzar.com/go/IndexFeatures'  as url,
                           N'The index '
                               + QUOTENAME(i.index_name)
                               + N' on ['
                               + i.db_schema_object_name
                               + N'] has a filter on ['
                               + i.filter_definition
                               + N'] but is missing ['
                               + LTRIM(i.filter_columns_not_in_index)
                               + N'] from the index definition.'
                                                                     as details,
                           i.index_definition,
                           i.secret_columns,
                           i.index_usage_summary,
                           sz.index_size_summary
                    from #indexsanity i
                             join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                    where i.filter_columns_not_in_index is not null
                    order by i.db_schema_object_indexid
                    option ( recompile );

                    ----------------------------------------
                    --Self Loathing Indexes : Check_id 40-49
                    ----------------------------------------
                    begin

                        raiserror (N'check_id 40: Fillfactor in nonclustered 80 percent or less', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 40                                      as check_id,
                               i.index_sanity_id,
                               100                                     as priority,
                               N'Self Loathing Indexes'                as findings_group,
                               N'Low Fill Factor: nonclustered index'  as finding,
                               [database_name]                         as [Database Name],
                               N'http://BrentOzar.com/go/SelfLoathing' as url,
                               CAST(fill_factor as nvarchar(10)) + N'% fill factor on ' + db_schema_object_indexid +
                               N'. ' +
                               case
                                   when (last_user_update is null or user_updates < 1)
                                       then N'No writes have been made.'
                                   else
                                           N'Last write was ' + CONVERT(nvarchar(16), last_user_update, 121) +
                                           N' and ' +
                                           CAST(user_updates as nvarchar(25)) + N' updates have been made.'
                                   end
                                                                       as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize as sz on i.index_sanity_id = sz.index_sanity_id
                        where index_id > 1
                          and not (@getalldatabases = 1 or @mode = 0)
                          and fill_factor between 1 and 80
                        option ( recompile );

                        raiserror (N'check_id 40: Fillfactor in clustered 80 percent or less', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 40                                      as check_id,
                               i.index_sanity_id,
                               100                                     as priority,
                               N'Self Loathing Indexes'                as findings_group,
                               N'Low Fill Factor: clustered index'     as finding,
                               [database_name]                         as [Database Name],
                               N'http://BrentOzar.com/go/SelfLoathing' as url,
                               N'Fill factor on ' + db_schema_object_indexid + N' is ' +
                               CAST(fill_factor as nvarchar(10)) + N'%. ' +
                               case
                                   when (last_user_update is null or user_updates < 1)
                                       then N'No writes have been made.'
                                   else
                                           N'Last write was ' + CONVERT(nvarchar(16), last_user_update, 121) +
                                           N' and ' +
                                           CAST(user_updates as nvarchar(25)) + N' updates have been made.'
                                   end
                                                                       as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize as sz on i.index_sanity_id = sz.index_sanity_id
                        where index_id = 1
                          and not (@getalldatabases = 1 or @mode = 0)
                          and fill_factor between 1 and 80
                        option ( recompile );


                        raiserror (N'check_id 41: Hypothetical indexes ', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 41                                                 as check_id,
                               i.index_sanity_id,
                               150                                                as priority,
                               N'Self Loathing Indexes'                           as findings_group,
                               N'Hypothetical Index'                              as finding,
                               [database_name]                                    as [Database Name],
                               N'http://BrentOzar.com/go/SelfLoathing'            as url,
                               N'Hypothetical Index: ' + db_schema_object_indexid as details,
                               i.index_definition,
                               i.secret_columns,
                               N''                                                as index_usage_summary,
                               N''                                                as index_size_summary
                        from #indexsanity as i
                        where is_hypothetical = 1
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );


                        raiserror (N'check_id 42: Disabled indexes', 0,1) with nowait;
                        --Note: disabled NC indexes will have O rows in #IndexSanitySize!
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 42                                            as check_id,
                               index_sanity_id,
                               150                                           as priority,
                               N'Self Loathing Indexes'                      as findings_group,
                               N'Disabled Index'                             as finding,
                               [database_name]                               as [Database Name],
                               N'http://BrentOzar.com/go/SelfLoathing'       as url,
                               N'Disabled Index:' + db_schema_object_indexid as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               'DISABLED'                                    as index_size_summary
                        from #indexsanity as i
                        where is_disabled = 1
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 43: Heaps with forwarded records', 0,1) with nowait;
                        with heaps_cte
                                 as (select [object_id],
                                            [database_id],
                                            [schema_name],
                                            SUM(forwarded_fetch_count) as forwarded_fetch_count,
                                            SUM(leaf_delete_count)     as leaf_delete_count
                                     from #indexpartitionsanity
                                     group by [object_id],
                                              [database_id],
                                              [schema_name]
                                     having SUM(forwarded_fetch_count) > 0)
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 43                                      as check_id,
                               i.index_sanity_id,
                               100                                     as priority,
                               N'Self Loathing Indexes'                as findings_group,
                               N'Heaps with forwarded records'         as finding,
                               [database_name]                         as [Database Name],
                               N'http://BrentOzar.com/go/SelfLoathing' as url,
                               case
                                   when h.forwarded_fetch_count >= 922337203685477 then '>= 922,337,203,685,477'
                                   when @daysuptime < 1 then CAST(h.forwarded_fetch_count as nvarchar(256)) +
                                                             N' forwarded fetches against heap: ' +
                                                             db_schema_object_indexid
                                   else REPLACE(CONVERT(nvarchar(256), CAST(CAST(
                                           (h.forwarded_fetch_count /*/@DaysUptime */)
                                       as bigint) as money), 1), '.00', '')
                                   end + N' forwarded fetches per day against heap: '
                                   + db_schema_object_indexid          as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity i
                                 join heaps_cte h on i.[object_id] = h.[object_id]
                            and i.[database_id] = h.[database_id]
                            and i.[schema_name] = h.[schema_name]
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.index_id = 0
                          and h.forwarded_fetch_count / @daysuptime > 1000
                          and sz.total_reserved_mb >= case
                                                          when not (@getalldatabases = 1 or @mode = 4) then @thresholdmb
                                                          else sz.total_reserved_mb end
                        option ( recompile );

                        raiserror (N'check_id 49: Heaps with deletes', 0,1) with nowait;
                        with heaps_cte
                                 as (select [object_id],
                                            [database_id],
                                            [schema_name],
                                            SUM(leaf_delete_count) as leaf_delete_count
                                     from #indexpartitionsanity
                                     group by [object_id],
                                              [database_id],
                                              [schema_name]
                                     having SUM(forwarded_fetch_count) < 1000 * @daysuptime /* Only alert about indexes with no forwarded fetches - we already alerted about those in check_id 43 */
                                        and SUM(leaf_delete_count) > 0)
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 49                                      as check_id,
                               i.index_sanity_id,
                               200                                     as priority,
                               N'Self Loathing Indexes'                as findings_group,
                               N'Heaps with deletes'                   as finding,
                               [database_name]                         as [Database Name],
                               N'http://BrentOzar.com/go/SelfLoathing' as url,
                               CAST(h.leaf_delete_count as nvarchar(256)) + N' deletes against heap:'
                                   + db_schema_object_indexid          as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity i
                                 join heaps_cte h on i.[object_id] = h.[object_id]
                            and i.[database_id] = h.[database_id]
                            and i.[schema_name] = h.[schema_name]
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.index_id = 0
                          and sz.total_reserved_mb >= case
                                                          when not (@getalldatabases = 1 or @mode = 4) then @thresholdmb
                                                          else sz.total_reserved_mb end
                        option ( recompile );

                        raiserror (N'check_id 44: Large Heaps with reads or writes.', 0,1) with nowait;
                        with heaps_cte
                                 as (select [object_id],
                                            [database_id],
                                            [schema_name],
                                            SUM(forwarded_fetch_count) as forwarded_fetch_count,
                                            SUM(leaf_delete_count)     as leaf_delete_count
                                     from #indexpartitionsanity
                                     group by [object_id],
                                              [database_id],
                                              [schema_name]
                                     having SUM(forwarded_fetch_count) > 0
                                         or SUM(leaf_delete_count) > 0)
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 44                                                          as check_id,
                               i.index_sanity_id,
                               100                                                         as priority,
                               N'Self Loathing Indexes'                                    as findings_group,
                               N'Large Active heap'                                        as finding,
                               [database_name]                                             as [Database Name],
                               N'http://BrentOzar.com/go/SelfLoathing'                     as url,
                               N'Should this table be a heap? ' + db_schema_object_indexid as details,
                               i.index_definition,
                               'N/A'                                                       as secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity i
                                 left join heaps_cte h on i.[object_id] = h.[object_id]
                            and i.[database_id] = h.[database_id]
                            and i.[schema_name] = h.[schema_name]
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.index_id = 0
                          and (i.total_reads > 0 or i.user_updates > 0)
                          and sz.total_rows >= 100000
                          and h.[object_id] is null /*don't duplicate the prior check.*/
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 45: Medium Heaps with reads or writes.', 0,1) with nowait;
                        with heaps_cte
                                 as (select [object_id],
                                            [database_id],
                                            [schema_name],
                                            SUM(forwarded_fetch_count) as forwarded_fetch_count,
                                            SUM(leaf_delete_count)     as leaf_delete_count
                                     from #indexpartitionsanity
                                     group by [object_id],
                                              [database_id],
                                              [schema_name]
                                     having SUM(forwarded_fetch_count) > 0
                                         or SUM(leaf_delete_count) > 0)
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 45                                                          as check_id,
                               i.index_sanity_id,
                               100                                                         as priority,
                               N'Self Loathing Indexes'                                    as findings_group,
                               N'Medium Active heap'                                       as finding,
                               [database_name]                                             as [Database Name],
                               N'http://BrentOzar.com/go/SelfLoathing'                     as url,
                               N'Should this table be a heap? ' + db_schema_object_indexid as details,
                               i.index_definition,
                               'N/A'                                                       as secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity i
                                 left join heaps_cte h on i.[object_id] = h.[object_id]
                            and i.[database_id] = h.[database_id]
                            and i.[schema_name] = h.[schema_name]
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.index_id = 0
                          and (i.total_reads > 0 or i.user_updates > 0)
                          and sz.total_rows >= 10000
                          and sz.total_rows < 100000
                          and h.[object_id] is null /*don't duplicate the prior check.*/
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 46: Small Heaps with reads or writes.', 0,1) with nowait;
                        with heaps_cte
                                 as (select [object_id],
                                            [database_id],
                                            [schema_name],
                                            SUM(forwarded_fetch_count) as forwarded_fetch_count,
                                            SUM(leaf_delete_count)     as leaf_delete_count
                                     from #indexpartitionsanity
                                     group by [object_id],
                                              [database_id],
                                              [schema_name]
                                     having SUM(forwarded_fetch_count) > 0
                                         or SUM(leaf_delete_count) > 0)
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 46                                                          as check_id,
                               i.index_sanity_id,
                               100                                                         as priority,
                               N'Self Loathing Indexes'                                    as findings_group,
                               N'Small Active heap'                                        as finding,
                               [database_name]                                             as [Database Name],
                               N'http://BrentOzar.com/go/SelfLoathing'                     as url,
                               N'Should this table be a heap? ' + db_schema_object_indexid as details,
                               i.index_definition,
                               'N/A'                                                       as secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity i
                                 left join heaps_cte h on i.[object_id] = h.[object_id]
                            and i.[database_id] = h.[database_id]
                            and i.[schema_name] = h.[schema_name]
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.index_id = 0
                          and (i.total_reads > 0 or i.user_updates > 0)
                          and sz.total_rows < 10000
                          and h.[object_id] is null /*don't duplicate the prior check.*/
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 47: Heap with a Nonclustered Primary Key', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 47                                                                       as check_id,
                               i.index_sanity_id,
                               100                                                                      as priority,
                               N'Self Loathing Indexes'                                                 as findings_group,
                               N'Heap with a Nonclustered Primary Key'                                  as finding,
                               [database_name]                                                          as [Database Name],
                               N'http://BrentOzar.com/go/SelfLoathing'                                  as url,
                               db_schema_object_indexid + N' is a HEAP with a Nonclustered Primary Key' as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity i
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.index_type = 2
                          and i.is_primary_key = 1
                          and EXISTS
                            (
                                select 1 / 0
                                from #indexsanity as isa
                                where i.database_id = isa.database_id
                                  and i.object_id = isa.object_id
                                  and isa.index_id = 0
                            )
                        option ( recompile );

                        raiserror (N'check_id 48: Nonclustered indexes with a bad read to write ratio', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 48                                      as check_id,
                               i.index_sanity_id,
                               100                                     as priority,
                               N'Index Hoarder'                        as findings_group,
                               N'NC index with High Writes:Reads'      as finding,
                               [database_name]                         as [Database Name],
                               N'http://BrentOzar.com/go/IndexHoarder' as url,
                               N'Reads: '
                                   + REPLACE(CONVERT(nvarchar(30), CAST((i.total_reads) as money), 1), N'.00', N'')
                                   + N' Writes: '
                                   + REPLACE(CONVERT(nvarchar(30), CAST((i.user_updates) as money), 1), N'.00', N'')
                                   + N' on: '
                                   + i.db_schema_object_indexid        as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               sz.index_size_summary
                        from #indexsanity i
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.total_reads > 0 /*Not totally unused*/
                          and i.user_updates >= 10000 /*Decent write activity*/
                          and i.total_reads < 10000
                          and ((i.total_reads * 10) < i.user_updates) /*10x more writes than reads*/
                          and i.index_id not in (0, 1) /*NCs only*/
                          and i.is_unique = 0
                          and sz.total_reserved_mb >= case
                                                          when (@getalldatabases = 1 or @mode = 0) then @thresholdmb
                                                          else sz.total_reserved_mb end
                        order by i.db_schema_object_indexid
                        option ( recompile );

                    end;
                    ----------------------------------------
                    --Indexaphobia
                    --Missing indexes with value >= 5 million: : Check_id 50-59
                    ----------------------------------------
                    begin
                        raiserror (N'check_id 50: Indexaphobia.', 0,1) with nowait;
                        with index_size_cte
                                 as (select i.database_id,
                                            i.schema_name,
                                            i.[object_id],
                                            MAX(i.index_sanity_id)                                                 as index_sanity_id,
                                            ISNULL(NULLIF(MAX(DATEDIFF(day, i.create_date, SYSDATETIME())), 0),
                                                   1)                                                              as create_days,
                                            ISNULL(
                                                        CAST(SUM(case when index_id not in (0, 1) then 1 else 0 end)
                                                            as nvarchar(30)) + N' NC indexes exist (' +
                                                        case
                                                            when SUM(
                                                                         case when index_id not in (0, 1) then sz.total_reserved_mb else 0 end) >
                                                                 1024
                                                                then CAST(CAST(SUM(
                                                                                       case when index_id not in (0, 1) then sz.total_reserved_mb else 0 end) /
                                                                               1024.
                                                                as numeric(29, 1)) as nvarchar(30)) + N'GB); '
                                                            else CAST(SUM(
                                                                    case when index_id not in (0, 1) then sz.total_reserved_mb else 0 end)
                                                                     as nvarchar(30)) + N'MB); '
                                                            end +
                                                        case
                                                            when MAX(sz.[total_rows]) >= 922337203685477
                                                                then '>= 922,337,203,685,477'
                                                            else REPLACE(
                                                                    CONVERT(nvarchar(30), CAST(MAX(sz.[total_rows]) as money), 1),
                                                                    '.00', '')
                                                            end +
                                                        + N' Estimated Rows;'
                                                ,
                                                        N'')                                                       as index_size_summary
                                     from #indexsanity as i
                                              left join #indexsanitysize as sz
                                                        on i.index_sanity_id = sz.index_sanity_id and
                                                           i.database_id = sz.database_id
                                     where i.is_hypothetical = 0
                                       and i.is_disabled = 0
                                     group by i.database_id, i.schema_name, i.[object_id])
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        ,
                        create_tsql
                        ,
                        more_info
                        )

                        select check_id,
                               t.index_sanity_id,
                               t.check_id,
                               t.findings_group,
                               t.finding,
                               t.[Database Name],
                               t.url,
                               t.details,
                               t.[definition],
                               index_estimated_impact,
                               t.index_size_summary,
                               create_tsql,
                               more_info
                        from (
                                 select ROW_NUMBER() over (order by magic_benefit_number desc) as rownum,
                                        50                                                     as check_id,
                                        sz.index_sanity_id,
                                        10                                                     as priority,
                                        N'Indexaphobia'                                        as findings_group,
                                        N'High value missing index'                            as finding,
                                        [database_name]                                        as [Database Name],
                                        N'http://BrentOzar.com/go/Indexaphobia'                as url,
                                        mi.[statement] +
                                        N' Est. benefit per day: ' +
                                        case
                                            when magic_benefit_number >= 922337203685477 then '>= 922,337,203,685,477'
                                            else REPLACE(CONVERT(nvarchar(256), CAST(CAST(
                                                    (magic_benefit_number / @daysuptime)
                                                as bigint) as money), 1), '.00', '')
                                            end                                                as details,
                                        missing_index_details                                  as [definition],
                                        index_estimated_impact,
                                        sz.index_size_summary,
                                        mi.create_tsql,
                                        mi.more_info,
                                        magic_benefit_number,
                                        mi.is_low
                                 from #missingindexes mi
                                          left join index_size_cte sz on mi.[object_id] = sz.object_id
                                     and mi.database_id = sz.database_id
                                     and mi.schema_name = sz.schema_name
                                     /* Minimum benefit threshold = 100k/day of uptime OR since table creation date, whichever is lower*/
                                 where (@mode = 4 and (magic_benefit_number / case
                                                                                  when sz.create_days < @daysuptime
                                                                                      then sz.create_days
                                                                                  else @daysuptime end) >= 100000)
                                    or (magic_benefit_number / case
                                                                   when sz.create_days < @daysuptime then sz.create_days
                                                                   else @daysuptime end) >= 100000
                             ) as t
                        where t.rownum <= case when (@mode <> 4) then 20 else t.rownum end
                        order by magic_benefit_number desc
                        option ( recompile );


                    end;
                    ----------------------------------------
                    --Abnormal Psychology : Check_id 60-79
                    ----------------------------------------
                    begin
                        raiserror (N'check_id 60: XML indexes', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 60                                            as check_id,
                               i.index_sanity_id,
                               150                                           as priority,
                               N'Abnormal Psychology'                        as findings_group,
                               N'XML Indexes'                                as finding,
                               [database_name]                               as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology' as url,
                               i.db_schema_object_indexid                    as details,
                               i.index_definition,
                               i.secret_columns,
                               N''                                           as index_usage_summary,
                               ISNULL(sz.index_size_summary, '')             as index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.is_xml = 1
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 61: Columnstore indexes', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 61                                            as check_id,
                               i.index_sanity_id,
                               150                                           as priority,
                               N'Abnormal Psychology'                        as findings_group,
                               case
                                   when i.is_nc_columnstore = 1
                                       then N'NC Columnstore Index'
                                   else N'Clustered Columnstore Index'
                                   end                                       as finding,
                               [database_name]                               as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology' as url,
                               i.db_schema_object_indexid                    as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               ISNULL(sz.index_size_summary, '')             as index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.is_nc_columnstore = 1
                           or i.is_cx_columnstore = 1
                            and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );


                        raiserror (N'check_id 62: Spatial indexes', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 62                                            as check_id,
                               i.index_sanity_id,
                               150                                           as priority,
                               N'Abnormal Psychology'                        as findings_group,
                               N'Spatial indexes'                            as finding,
                               [database_name]                               as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology' as url,
                               i.db_schema_object_indexid                    as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               ISNULL(sz.index_size_summary, '')             as index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.is_spatial = 1
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 63: Compressed indexes', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 63                                                                         as check_id,
                               i.index_sanity_id,
                               150                                                                        as priority,
                               N'Abnormal Psychology'                                                     as findings_group,
                               N'Compressed indexes'                                                      as finding,
                               [database_name]                                                            as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology'                              as url,
                               i.db_schema_object_indexid + N'. COMPRESSION: ' + sz.data_compression_desc as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               ISNULL(sz.index_size_summary, '')                                          as index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where sz.data_compression_desc like '%PAGE%'
                           or sz.data_compression_desc like '%ROW%'
                            and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 64: Partitioned', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 64                                            as check_id,
                               i.index_sanity_id,
                               150                                           as priority,
                               N'Abnormal Psychology'                        as findings_group,
                               N'Partitioned indexes'                        as finding,
                               [database_name]                               as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology' as url,
                               i.db_schema_object_indexid                    as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               ISNULL(sz.index_size_summary, '')             as index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.partition_key_column_name is not null
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 65: Non-Aligned Partitioned', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 65                                            as check_id,
                               i.index_sanity_id,
                               150                                           as priority,
                               N'Abnormal Psychology'                        as findings_group,
                               N'Non-Aligned index on a partitioned table'   as finding,
                               i.[database_name]                             as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology' as url,
                               i.db_schema_object_indexid                    as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               ISNULL(sz.index_size_summary, '')             as index_size_summary
                        from #indexsanity as i
                                 join #indexsanity as iparent on
                                i.[object_id] = iparent.[object_id]
                                and i.database_id = iparent.database_id
                                and i.schema_name = iparent.schema_name
                                and iparent.index_id in (0, 1) /* could be a partitioned heap or clustered table */
                                and iparent.partition_key_column_name is not null /* parent is partitioned*/
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.partition_key_column_name is null
                        option ( recompile );

                        raiserror (N'check_id 66: Recently created tables/indexes (1 week)', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 66                                            as check_id,
                               i.index_sanity_id,
                               200                                           as priority,
                               N'Abnormal Psychology'                        as findings_group,
                               N'Recently created tables/indexes (1 week)'   as finding,
                               [database_name]                               as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology' as url,
                               i.db_schema_object_indexid + N' was created on ' +
                               CONVERT(nvarchar(16), i.create_date, 121) +
                               N'. Tables/indexes which are dropped/created regularly require special methods for index tuning.'
                                                                             as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               ISNULL(sz.index_size_summary, '')             as index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.create_date >= DATEADD(dd, -7, GETDATE())
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 67: Recently modified tables/indexes (2 days)', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 67                                            as check_id,
                               i.index_sanity_id,
                               200                                           as priority,
                               N'Abnormal Psychology'                        as findings_group,
                               N'Recently modified tables/indexes (2 days)'  as finding,
                               [database_name]                               as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology' as url,
                               i.db_schema_object_indexid + N' was modified on ' +
                               CONVERT(nvarchar(16), i.modify_date, 121) +
                               N'. A large amount of recently modified indexes may mean a lot of rebuilds are occurring each night.'
                                                                             as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               ISNULL(sz.index_size_summary, '')             as index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.modify_date > DATEADD(dd, -2, GETDATE())
                          and not (@getalldatabases = 1 or @mode = 0)
                          and /*Exclude recently created tables.*/
                            i.create_date < DATEADD(dd, -7, GETDATE())
                        option ( recompile );

                        raiserror (N'check_id 68: Identity columns within 30 percent of the end of range', 0,1) with nowait;
                        -- Allowed Ranges:
                        --int -2,147,483,648 to 2,147,483,647
                        --smallint -32,768 to 32,768
                        --tinyint 0 to 255

                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 68                                            as check_id,
                               i.index_sanity_id,
                               200                                           as priority,
                               N'Abnormal Psychology'                        as findings_group,
                               N'Identity column within ' +
                               CAST(calc1.percent_remaining as nvarchar(256))
                                   + N' percent  end of range'               as finding,
                               [database_name]                               as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology' as url,
                               i.db_schema_object_name + N'.' + QUOTENAME(ic.column_name)
                                   + N' is an identity with type ' + ic.system_type_name
                                   + N', last value of '
                                   + ISNULL((CONVERT(nvarchar(256), CAST(ic.last_value as decimal(38, 0)), 1)), N'NULL')
                                   + N', seed of '
                                   + ISNULL((CONVERT(nvarchar(256), CAST(ic.seed_value as decimal(38, 0)), 1)), N'NULL')
                                   + N', increment of ' + CAST(ic.increment_value as nvarchar(256))
                                   + N', and range of ' +
                               case ic.system_type_name
                                   when 'int' then N'+/- 2,147,483,647'
                                   when 'smallint' then N'+/- 32,768'
                                   when 'tinyint' then N'0 to 255'
                                   else 'unknown'
                                   end
                                                                             as details,
                               i.index_definition,
                               secret_columns,
                               ISNULL(i.index_usage_summary, ''),
                               ISNULL(ip.index_size_summary, '')
                        from #indexsanity i
                                 join #indexcolumns ic on
                                i.object_id = ic.object_id
                                and i.database_id = ic.database_id
                                and i.schema_name = ic.schema_name
                                and i.index_id in (0, 1) /* heaps and cx only */
                                and ic.is_identity = 1
                                and ic.system_type_name in ('tinyint', 'smallint', 'int')
                                 join #indexsanitysize ip on i.index_sanity_id = ip.index_sanity_id
                                 cross apply (
                            select CAST(case
                                            when ic.increment_value >= 0
                                                then
                                                case ic.system_type_name
                                                    when 'int' then (2147483647 -
                                                                     (ISNULL(ic.last_value, ic.seed_value) + ic.increment_value)) /
                                                                    2147483647. * 100
                                                    when 'smallint' then
                                                                (32768 - (ISNULL(ic.last_value, ic.seed_value) + ic.increment_value)) /
                                                                32768. * 100
                                                    when 'tinyint' then
                                                                (255 - (ISNULL(ic.last_value, ic.seed_value) + ic.increment_value)) /
                                                                255. * 100
                                                    else 999
                                                    end
                                            else --ic.increment_value is negative
                                                case ic.system_type_name
                                                    when 'int' then ABS(-2147483647 -
                                                                        (ISNULL(ic.last_value, ic.seed_value) + ic.increment_value)) /
                                                                    2147483647. * 100
                                                    when 'smallint' then ABS(-32768 -
                                                                             (ISNULL(ic.last_value, ic.seed_value) + ic.increment_value)) /
                                                                         32768. * 100
                                                    when 'tinyint' then ABS(
                                                                                0 - (ISNULL(ic.last_value, ic.seed_value) + ic.increment_value)) /
                                                                        255. * 100
                                                    else -1
                                                    end
                                end as numeric(5, 1)) as percent_remaining
                        ) as calc1
                        where i.index_id in (1, 0)
                          and calc1.percent_remaining <= 30
                        union all
                        select 68                                                                 as check_id,
                               i.index_sanity_id,
                               200                                                                as priority,
                               N'Abnormal Psychology'                                             as findings_group,
                               N'Identity column using a negative seed or increment other than 1' as finding,
                               [database_name]                                                    as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology'                      as url,
                               i.db_schema_object_name + N'.' + QUOTENAME(ic.column_name)
                                   + N' is an identity with type ' + ic.system_type_name
                                   + N', last value of '
                                   + ISNULL((CONVERT(nvarchar(256), CAST(ic.last_value as decimal(38, 0)), 1)), N'NULL')
                                   + N', seed of '
                                   + ISNULL((CONVERT(nvarchar(256), CAST(ic.seed_value as decimal(38, 0)), 1)), N'NULL')
                                   + N', increment of ' + CAST(ic.increment_value as nvarchar(256))
                                   + N', and range of ' +
                               case ic.system_type_name
                                   when 'int' then N'+/- 2,147,483,647'
                                   when 'smallint' then N'+/- 32,768'
                                   when 'tinyint' then N'0 to 255'
                                   else 'unknown'
                                   end
                                                                                                  as details,
                               i.index_definition,
                               secret_columns,
                               ISNULL(i.index_usage_summary, ''),
                               ISNULL(ip.index_size_summary, '')
                        from #indexsanity i
                                 join #indexcolumns ic on
                                i.object_id = ic.object_id
                                and i.database_id = ic.database_id
                                and i.schema_name = ic.schema_name
                                and i.index_id in (0, 1) /* heaps and cx only */
                                and ic.is_identity = 1
                                and ic.system_type_name in ('tinyint', 'smallint', 'int')
                                 join #indexsanitysize ip on i.index_sanity_id = ip.index_sanity_id
                        where i.index_id in (1, 0)
                          and (ic.seed_value < 0 or ic.increment_value <> 1)
                        order by finding, details desc
                        option ( recompile );

                        raiserror (N'check_id 69: Column collation does not match database collation', 0,1) with nowait;
                        with count_columns as (
                            select [object_id],
                                   database_id,
                                   schema_name,
                                   COUNT(*) as column_count
                            from #indexcolumns ic
                            where index_id in (1, 0) /*Heap or clustered only*/
                              and collation_name <> @collation
                            group by [object_id],
                                     database_id,
                                     schema_name
                        )
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 69                                                    as check_id,
                               i.index_sanity_id,
                               150                                                   as priority,
                               N'Abnormal Psychology'                                as findings_group,
                               N'Column collation does not match database collation' as finding,
                               [database_name]                                       as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology'         as url,
                               i.db_schema_object_name
                                   + N' has ' + CAST(column_count as nvarchar(20))
                                   + N' column' + case when column_count > 1 then 's' else '' end
                                   + N' with a different collation than the db collation of '
                                   + @collation                                      as details,
                               i.index_definition,
                               secret_columns,
                               ISNULL(i.index_usage_summary, ''),
                               ISNULL(ip.index_size_summary, '')
                        from #indexsanity i
                                 join #indexsanitysize ip on i.index_sanity_id = ip.index_sanity_id
                                 join count_columns as cc on i.[object_id] = cc.[object_id]
                            and cc.database_id = i.database_id
                            and cc.schema_name = i.schema_name
                        where i.index_id in (1, 0)
                          and not (@getalldatabases = 1 or @mode = 0)
                        order by i.db_schema_object_name desc
                        option ( recompile );

                        raiserror (N'check_id 70: Replicated columns', 0,1) with nowait;
                        with count_columns as (
                            select [object_id],
                                   database_id,
                                   schema_name,
                                   COUNT(*)                                         as column_count,
                                   SUM(case is_replicated when 1 then 1 else 0 end) as replicated_column_count
                            from #indexcolumns ic
                            where index_id in (1, 0) /*Heap or clustered only*/
                            group by object_id,
                                     database_id,
                                     schema_name
                        )
                        insert
                        #blitzindexresults
                        (
                        check_id
                        ,
                        index_sanity_id
                        ,
                        priority
                        ,
                        findings_group
                        ,
                        finding
                        ,
                        [database_name]
                        ,
                        url
                        ,
                        details
                        ,
                        index_definition
                        ,
                        secret_columns
                        ,
                        index_usage_summary
                        ,
                        index_size_summary
                        )
                        select 70                                            as check_id,
                               i.index_sanity_id,
                               200                                           as priority,
                               N'Abnormal Psychology'                        as findings_group,
                               N'Replicated columns'                         as finding,
                               [database_name]                               as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology' as url,
                               i.db_schema_object_name
                                   + N' has ' + CAST(replicated_column_count as nvarchar(20))
                                   + N' out of ' + CAST(column_count as nvarchar(20))
                                   + N' column' + case when column_count > 1 then 's' else '' end
                                   + N' in one or more publications.'
                                                                             as details,
                               i.index_definition,
                               secret_columns,
                               ISNULL(i.index_usage_summary, ''),
                               ISNULL(ip.index_size_summary, '')
                        from #indexsanity i
                                 join #indexsanitysize ip on i.index_sanity_id = ip.index_sanity_id
                                 join count_columns as cc on i.[object_id] = cc.[object_id]
                            and i.database_id = cc.database_id
                            and i.schema_name = cc.schema_name
                        where i.index_id in (1, 0)
                          and replicated_column_count > 0
                          and not (@getalldatabases = 1 or @mode = 0)
                        order by i.db_schema_object_name desc
                        option ( recompile );

                        raiserror (N'check_id 71: Cascading updates or cascading deletes.', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary, more_info)
                        select 71                                            as check_id,
                               null                                          as index_sanity_id,
                               150                                           as priority,
                               N'Abnormal Psychology'                        as findings_group,
                               N'Cascading Updates or Deletes'               as finding,
                               [database_name]                               as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology' as url,
                               N'Foreign Key ' + foreign_key_name +
                               N' on ' + QUOTENAME(parent_object_name) + N'(' + LTRIM(parent_fk_columns) + N')'
                                   + N' referencing ' + QUOTENAME(referenced_object_name) + N'(' +
                               LTRIM(referenced_fk_columns) + N')'
                                   + N' has settings:'
                                   + case [delete_referential_action_desc]
                                         when N'NO_ACTION' then N''
                                         else N' ON DELETE ' + [delete_referential_action_desc] end
                                   + case [update_referential_action_desc]
                                         when N'NO_ACTION' then N''
                                         else N' ON UPDATE ' + [update_referential_action_desc] end
                                                                             as details,
                               [fk].[database_name]
                                                                             as index_definition,
                               N'N/A'                                        as secret_columns,
                               N'N/A'                                        as index_usage_summary,
                               N'N/A'                                        as index_size_summary,
                               (select top 1 more_info
                                from #indexsanity i
                                where i.object_id = fk.parent_object_id
                                  and i.database_id = fk.database_id
                                  and i.schema_name = fk.schema_name)
                                                                             as more_info
                        from #foreignkeys fk
                        where ([delete_referential_action_desc] <> N'NO_ACTION'
                            or [update_referential_action_desc] <> N'NO_ACTION')
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 72: Columnstore indexes with Trace Flag 834', 0,1) with nowait;
                        if EXISTS(select * from #indexsanity where index_type in (5, 6))
                            and EXISTS(select * from #tracestatus where traceflag = 834 and status = 1)
                            begin
                                insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                           [database_name], url, details, index_definition,
                                                           secret_columns, index_usage_summary, index_size_summary)
                                select 72                                                                                                                        as check_id,
                                       i.index_sanity_id,
                                       150                                                                                                                       as priority,
                                       N'Abnormal Psychology'                                                                                                    as findings_group,
                                       'Columnstore Indexes are being used in conjunction with trace flag 834. Visit the link to see why this can be a bad idea' as finding,
                                       [database_name]                                                                                                           as [Database Name],
                                       N'https://support.microsoft.com/en-us/kb/3210239'                                                                         as url,
                                       i.db_schema_object_indexid                                                                                                as details,
                                       i.index_definition,
                                       i.secret_columns,
                                       i.index_usage_summary,
                                       ISNULL(sz.index_size_summary, '')                                                                                         as index_size_summary
                                from #indexsanity as i
                                         join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                                where i.index_type in (5, 6)
                                option ( recompile );
                            end;

                        raiserror (N'check_id 73: In-Memory OLTP', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 73                                            as check_id,
                               i.index_sanity_id,
                               150                                           as priority,
                               N'Abnormal Psychology'                        as findings_group,
                               N'In-Memory OLTP'                             as finding,
                               [database_name]                               as [Database Name],
                               N'http://BrentOzar.com/go/AbnormalPsychology' as url,
                               i.db_schema_object_indexid                    as details,
                               i.index_definition,
                               i.secret_columns,
                               i.index_usage_summary,
                               ISNULL(sz.index_size_summary, '')             as index_size_summary
                        from #indexsanity as i
                                 join #indexsanitysize sz on i.index_sanity_id = sz.index_sanity_id
                        where i.is_in_memory_oltp = 1
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                    end;

                    ----------------------------------------
                    --Workaholics: Check_id 80-89
                    ----------------------------------------
                    begin

                        raiserror (N'check_id 80: Most scanned indexes (index_usage_stats)', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                            --Workaholics according to index_usage_stats
                            --This isn't perfect: it mentions the number of scans present in a plan
                            --A "scan" isn't necessarily a full scan, but hey, we gotta do the best with what we've got.
                            --in the case of things like indexed views, the operator might be in the plan but never executed
                        select top 5 80 as                                                                            check_id,
                                     i.index_sanity_id as                                                             index_sanity_id,
                                     200 as                                                                           priority,
                                     N'Workaholics' as                                                                findings_group,
                                     N'Scan-a-lots (index_usage_stats)' as                                            finding,
                                     [database_name] as                                                               [Database Name],
                                     N'http://BrentOzar.com/go/Workaholics' as                                        url,
                                     REPLACE(CONVERT(nvarchar(50), CAST(i.user_scans as money), 1), '.00', '')
                                         + N' scans against ' + i.db_schema_object_indexid
                                         + N'. Latest scan: ' + ISNULL(CAST(i.last_user_scan as nvarchar(128)), '?') +
                                     N'. '
                                         + N'ScanFactor=' + CAST(
                                             ((i.user_scans * iss.total_reserved_mb) / 1000000.) as nvarchar(256)) as details,
                                     ISNULL(i.key_column_names_with_sort_order, 'N/A') as                             index_definition,
                                     ISNULL(i.secret_columns, '') as                                                  secret_columns,
                                     i.index_usage_summary as                                                         index_usage_summary,
                                     iss.index_size_summary as                                                        index_size_summary
                        from #indexsanity i
                                 join #indexsanitysize iss on i.index_sanity_id = iss.index_sanity_id
                        where ISNULL(i.user_scans, 0) > 0
                          and not (@getalldatabases = 1 or @mode = 0)
                        order by i.user_scans * iss.total_reserved_mb desc
                        option ( recompile );

                        raiserror (N'check_id 81: Top recent accesses (op stats)', 0,1) with nowait;
                        insert #blitzindexresults (check_id, index_sanity_id, priority, findings_group, finding,
                                                   [database_name], url, details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                            --Workaholics according to index_operational_stats
                            --This isn't perfect either: range_scan_count contains full scans, partial scans, even seeks in nested loop ops
                            --But this can help bubble up some most-accessed tables
                        select top 5 81                                                                          as check_id,
                                     i.index_sanity_id                                                           as index_sanity_id,
                                     200                                                                         as priority,
                                     N'Workaholics'                                                              as findings_group,
                                     N'Top recent accesses (index_op_stats)'                                     as finding,
                                     [database_name]                                                             as [Database Name],
                                     N'http://BrentOzar.com/go/Workaholics'                                      as url,
                                     ISNULL(REPLACE(
                                                    CONVERT(nvarchar(50), CAST(
                                                                                  (iss.total_range_scan_count + iss.total_singleton_lookup_count) as money),
                                                                          1),
                                                    N'.00', N'')
                                                + N' uses of ' + i.db_schema_object_indexid + N'. '
                                                + REPLACE(
                                                    CONVERT(nvarchar(50), CAST(iss.total_range_scan_count as money), 1),
                                                    N'.00', N'') + N' scans or seeks. '
                                                + REPLACE(CONVERT(nvarchar(50),
                                                                  CAST(iss.total_singleton_lookup_count as money), 1),
                                                          N'.00', N'') + N' singleton lookups. '
                                                + N'OpStatsFactor=' + CAST(
                                                    ((((iss.total_range_scan_count + iss.total_singleton_lookup_count) *
                                                       iss.total_reserved_mb)) / 1000000.) as varchar(256)),
                                            '')                                                                  as details,
                                     ISNULL(i.key_column_names_with_sort_order, 'N/A')                           as index_definition,
                                     ISNULL(i.secret_columns, '')                                                as secret_columns,
                                     i.index_usage_summary                                                       as index_usage_summary,
                                     iss.index_size_summary                                                      as index_size_summary
                        from #indexsanity i
                                 join #indexsanitysize iss on i.index_sanity_id = iss.index_sanity_id
                        where (ISNULL(iss.total_range_scan_count, 0) > 0 or
                               ISNULL(iss.total_singleton_lookup_count, 0) > 0)
                          and not (@getalldatabases = 1 or @mode = 0)
                        order by ((iss.total_range_scan_count + iss.total_singleton_lookup_count) *
                                  iss.total_reserved_mb) desc
                        option ( recompile );


                    end;

                    ----------------------------------------
                    --Statistics Info: Check_id 90-99
                    ----------------------------------------
                    begin

                        raiserror (N'check_id 90: Outdated statistics', 0,1) with nowait;
                        insert #blitzindexresults (check_id, priority, findings_group, finding, [database_name], url,
                                                   details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 90                                                             as check_id,
                               200                                                            as priority,
                               'Functioning Statistaholics'                                   as findings_group,
                               'Statistic Abandonment Issues',
                               s.database_name,
                               ''                                                             as url,
                               'Statistics on this table were last updated ' +
                               case s.last_statistics_update
                                   when null then N' NEVER '
                                   else CONVERT(nvarchar(20), s.last_statistics_update) +
                                        ' have had ' + CONVERT(nvarchar(100), s.modification_counter) +
                                        ' modifications in that time, which is ' +
                                        CONVERT(nvarchar(100), s.percent_modifications) +
                                        '% of the table.'
                                   end                                                        as details,
                               QUOTENAME(database_name) + '.' + QUOTENAME(s.schema_name) + '.' +
                               QUOTENAME(s.table_name) + '.' + QUOTENAME(s.index_name) + '.' +
                               QUOTENAME(s.statistics_name) + '.' + QUOTENAME(s.column_names) as index_definition,
                               'N/A'                                                          as secret_columns,
                               'N/A'                                                          as index_usage_summary,
                               'N/A'                                                          as index_size_summary
                        from #statistics as s
                        where s.last_statistics_update <= CONVERT(datetime, GETDATE() - 7)
                          and s.percent_modifications >= 10.
                          and s.rows >= 10000
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 91: Statistics with a low sample rate', 0,1) with nowait;
                        insert #blitzindexresults (check_id, priority, findings_group, finding, [database_name], url,
                                                   details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 91                                                                                                           as check_id,
                               200                                                                                                          as priority,
                               'Functioning Statistaholics'                                                                                 as findings_group,
                               'Antisocial Samples',
                               s.database_name,
                               ''                                                                                                           as url,
                               'Only ' + CONVERT(nvarchar(100), s.percent_sampled) +
                               '% of the rows were sampled during the last statistics update. This may lead to poor cardinality estimates.' as details,
                               QUOTENAME(database_name) + '.' + QUOTENAME(s.schema_name) + '.' +
                               QUOTENAME(s.table_name) + '.' + QUOTENAME(s.index_name) + '.' +
                               QUOTENAME(s.statistics_name) + '.' +
                               QUOTENAME(s.column_names)                                                                                    as index_definition,
                               'N/A'                                                                                                        as secret_columns,
                               'N/A'                                                                                                        as index_usage_summary,
                               'N/A'                                                                                                        as index_size_summary
                        from #statistics as s
                        where s.rows_sampled < 1.
                          and s.rows >= 10000
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 92: Statistics with NO RECOMPUTE', 0,1) with nowait;
                        insert #blitzindexresults (check_id, priority, findings_group, finding, [database_name], url,
                                                   details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 92                                                                                                                                as check_id,
                               200                                                                                                                               as priority,
                               'Functioning Statistaholics'                                                                                                      as findings_group,
                               'Cyberphobic Samples',
                               s.database_name,
                               ''                                                                                                                                as url,
                               'The statistic ' + QUOTENAME(s.statistics_name) +
                               ' is set to not recompute. This can be helpful if data is really skewed, but harmful if you expect automatic statistics updates.' as details,
                               QUOTENAME(database_name) + '.' + QUOTENAME(s.schema_name) + '.' +
                               QUOTENAME(s.table_name) + '.' + QUOTENAME(s.index_name) + '.' +
                               QUOTENAME(s.statistics_name) + '.' +
                               QUOTENAME(s.column_names)                                                                                                         as index_definition,
                               'N/A'                                                                                                                             as secret_columns,
                               'N/A'                                                                                                                             as index_usage_summary,
                               'N/A'                                                                                                                             as index_size_summary
                        from #statistics as s
                        where s.no_recompute = 1
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        raiserror (N'check_id 93: Statistics with filters', 0,1) with nowait;
                        insert #blitzindexresults (check_id, priority, findings_group, finding, [database_name], url,
                                                   details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 93                                                                                                     as check_id,
                               200                                                                                                    as priority,
                               'Functioning Statistaholics'                                                                           as findings_group,
                               'Filter Fixation',
                               s.database_name,
                               ''                                                                                                     as url,
                               'The statistic ' + QUOTENAME(s.statistics_name) + ' is filtered on [' +
                               s.filter_definition +
                               ']. It could be part of a filtered index, or just a filtered statistic. This is purely informational.' as details,
                               QUOTENAME(database_name) + '.' + QUOTENAME(s.schema_name) + '.' +
                               QUOTENAME(s.table_name) + '.' + QUOTENAME(s.index_name) + '.' +
                               QUOTENAME(s.statistics_name) + '.' +
                               QUOTENAME(s.column_names)                                                                              as index_definition,
                               'N/A'                                                                                                  as secret_columns,
                               'N/A'                                                                                                  as index_usage_summary,
                               'N/A'                                                                                                  as index_size_summary
                        from #statistics as s
                        where s.has_filter = 1
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                    end;

                    ----------------------------------------
                    --Computed Column Info: Check_id 99-109
                    ----------------------------------------
                    begin

                        raiserror (N'check_id 99: Computed Columns That Reference Functions', 0,1) with nowait;
                        insert #blitzindexresults (check_id, priority, findings_group, finding, [database_name], url,
                                                   details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 99                                                                                                                                                      as check_id,
                               50                                                                                                                                                      as priority,
                               'Cold Calculators'                                                                                                                                      as findings_group,
                               'Serial Forcer'                                                                                                                                         as finding,
                               cc.database_name,
                               ''                                                                                                                                                      as url,
                               'The computed column ' + QUOTENAME(cc.column_name) + ' on ' + QUOTENAME(cc.schema_name) +
                               '.' + QUOTENAME(cc.table_name) + ' is based on ' + cc.definition
                                   +
                               '. That indicates it may reference a scalar function, or a CLR function with data access, which can cause all queries and maintenance to run serially.' as details,
                               cc.column_definition,
                               'N/A'                                                                                                                                                   as secret_columns,
                               'N/A'                                                                                                                                                   as index_usage_summary,
                               'N/A'                                                                                                                                                   as index_size_summary
                        from #computedcolumns as cc
                        where cc.is_function = 1
                        option ( recompile );

                        raiserror (N'check_id 100: Computed Columns that are not Persisted.', 0,1) with nowait;
                        insert #blitzindexresults (check_id, priority, findings_group, finding, [database_name], url,
                                                   details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 100                     as check_id,
                               200                     as priority,
                               'Cold Calculators'      as findings_group,
                               'Definition Defeatists' as finding,
                               cc.database_name,
                               ''                      as url,
                               'The computed column ' + QUOTENAME(cc.column_name) + ' on ' + QUOTENAME(cc.schema_name) +
                               '.' + QUOTENAME(cc.table_name) +
                               ' is not persisted, which means it will be calculated when a query runs.' +
                               'You can change this with the following command, if the definition is deterministic: ALTER TABLE ' +
                               QUOTENAME(cc.schema_name) + '.' + QUOTENAME(cc.table_name) + ' ALTER COLUMN ' +
                               cc.column_name +
                               ' ADD PERSISTED'        as details,
                               cc.column_definition,
                               'N/A'                   as secret_columns,
                               'N/A'                   as index_usage_summary,
                               'N/A'                   as index_size_summary
                        from #computedcolumns as cc
                        where cc.is_persisted = 0
                          and not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        ----------------------------------------
                        --Temporal Table Info: Check_id 110-119
                        ----------------------------------------
                        raiserror (N'check_id 110: Temporal Tables.', 0,1) with nowait;
                        insert #blitzindexresults (check_id, priority, findings_group, finding, [database_name], url,
                                                   details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)

                        select 110               as check_id,
                               200               as priority,
                               'Temporal Tables' as findings_group,
                               'Obsessive Compulsive Tables',
                               t.database_name,
                               ''                as url,
                               'The table ' + QUOTENAME(t.schema_name) + '.' + QUOTENAME(t.table_name) +
                               ' is a temporal table, with rows versioned in '
                                   + QUOTENAME(t.history_schema_name) + '.' + QUOTENAME(t.history_table_name) +
                               ' on History columns ' + QUOTENAME(t.start_column_name) + ' and ' +
                               QUOTENAME(t.end_column_name) + '.'
                                                 as details,
                               ''                as index_definition,
                               'N/A'             as secret_columns,
                               'N/A'             as index_usage_summary,
                               'N/A'             as index_size_summary
                        from #temporaltables as t
                        where not (@getalldatabases = 1 or @mode = 0)
                        option ( recompile );

                        ----------------------------------------
                        --Check Constraint Info: Check_id 120-129
                        ----------------------------------------

                        raiserror (N'check_id 120: Check Constraints That Reference Functions', 0,1) with nowait;
                        insert #blitzindexresults (check_id, priority, findings_group, finding, [database_name], url,
                                                   details, index_definition,
                                                   secret_columns, index_usage_summary, index_size_summary)
                        select 99                                                                                                                                                      as check_id,
                               50                                                                                                                                                      as priority,
                               'Obsessive Constraintive'                                                                                                                               as findings_group,
                               'Serial Forcer'                                                                                                                                         as finding,
                               cc.database_name,
                               'https://www.brentozar.com/archive/2016/01/another-reason-why-scalar-functions-in-computed-columns-is-a-bad-idea/'                                      as url,
                               'The check constraint ' + QUOTENAME(cc.constraint_name) + ' on ' +
                               QUOTENAME(cc.schema_name) + '.' + QUOTENAME(cc.table_name) + ' is based on ' +
                               cc.definition
                                   +
                               '. That indicates it may reference a scalar function, or a CLR function with data access, which can cause all queries and maintenance to run serially.' as details,
                               cc.column_definition,
                               'N/A'                                                                                                                                                   as secret_columns,
                               'N/A'                                                                                                                                                   as index_usage_summary,
                               'N/A'                                                                                                                                                   as index_size_summary
                        from #checkconstraints as cc
                        where cc.is_function = 1
                        option ( recompile );

                    end;

                    raiserror (N'Insert a row to help people find help', 0,1) with nowait;
                    if DATEDIFF(mm, @versiondate, GETDATE()) > 6
                        begin
                            insert #blitzindexresults (priority, check_id, findings_group, finding, url, details,
                                                       index_definition,
                                                       index_usage_summary, index_size_summary)
                            values (-1, 0,
                                    'Outdated sp_BlitzIndex', 'sp_BlitzIndex is Over 6 Months Old',
                                    'http://FirstResponderKit.org/',
                                    'Fine wine gets better with age, but this ' + @scriptversionname +
                                    ' is more like bad cheese. Time to get a new one.',
                                    @daysuptimeinsertvalue, N'', N'');
                        end;

                    if EXISTS(select * from #blitzindexresults)
                        begin
                            insert #blitzindexresults (priority, check_id, findings_group, finding, url, details,
                                                       index_definition,
                                                       index_usage_summary, index_size_summary)
                            values (-1, 0,
                                    @scriptversionname,
                                    case
                                        when @getalldatabases = 1 then N'All Databases'
                                        else N'Database ' + QUOTENAME(@databasename) + N' as of ' +
                                             CONVERT(nvarchar(16), GETDATE(), 121) end,
                                    N'From Your Community Volunteers', N'http://FirstResponderKit.org',
                                    @daysuptimeinsertvalue, N'', N'');
                        end;
                    else
                        if @mode = 0 or (@getalldatabases = 1 and @mode <> 4)
                            begin
                                insert #blitzindexresults (priority, check_id, findings_group, finding, url, details,
                                                           index_definition,
                                                           index_usage_summary, index_size_summary)
                                values (-1, 0,
                                        @scriptversionname,
                                        case
                                            when @getalldatabases = 1 then N'All Databases'
                                            else N'Database ' + QUOTENAME(@databasename) + N' as of ' +
                                                 CONVERT(nvarchar(16), GETDATE(), 121) end,
                                        N'From Your Community Volunteers', N'http://FirstResponderKit.org',
                                        @daysuptimeinsertvalue, N'', N'');
                                insert #blitzindexresults (priority, check_id, findings_group, finding, url, details,
                                                           index_definition,
                                                           index_usage_summary, index_size_summary)
                                values (1, 0,
                                        N'No Major Problems Found',
                                        N'Nice Work!',
                                        N'http://FirstResponderKit.org',
                                        N'Consider running with @Mode = 4 in individual databases (not all) for more detailed diagnostics.',
                                        N'The new default Mode 0 only looks for very serious index issues.',
                                        @daysuptimeinsertvalue, N'');

                            end;
                        else
                            begin
                                insert #blitzindexresults (priority, check_id, findings_group, finding, url, details,
                                                           index_definition,
                                                           index_usage_summary, index_size_summary)
                                values (-1, 0,
                                        @scriptversionname,
                                        case
                                            when @getalldatabases = 1 then N'All Databases'
                                            else N'Database ' + QUOTENAME(@databasename) + N' as of ' +
                                                 CONVERT(nvarchar(16), GETDATE(), 121) end,
                                        N'From Your Community Volunteers', N'http://FirstResponderKit.org',
                                        @daysuptimeinsertvalue, N'', N'');
                                insert #blitzindexresults (priority, check_id, findings_group, finding, url, details,
                                                           index_definition,
                                                           index_usage_summary, index_size_summary)
                                values (1, 0,
                                        N'No Problems Found',
                                        N'Nice job! Or more likely, you have a nearly empty database.',
                                        N'http://FirstResponderKit.org', 'Time to go read some blog posts.',
                                        @daysuptimeinsertvalue, N'', N'');

                            end;

                    raiserror (N'Returning results.', 0,1) with nowait;

                    /*Return results.*/
                    if (@mode = 0)
                        begin
                            if (@outputtype <> 'NONE')
                                begin
                                    select priority,
                                           ISNULL(br.findings_group, N'') +
                                           case when ISNULL(br.finding, N'') <> N'' then N': ' else N'' end
                                               + br.finding                             as [Finding],
                                           br.[database_name]                           as [Database Name],
                                           br.details                                   as [Details: schema.table.index(indexid)],
                                           br.index_definition                          as [Definition: [Property]] ColumnName {datatype maxbytes}],
                                           ISNULL(br.secret_columns, '')                as [Secret Columns],
                                           br.index_usage_summary                       as [Usage],
                                           br.index_size_summary                        as [Size],
                                           COALESCE(br.more_info, sn.more_info, '')     as [More Info],
                                           br.url,
                                           COALESCE(br.create_tsql, ts.create_tsql, '') as [Create TSQL]
                                    from #blitzindexresults br
                                             left join #indexsanity sn on
                                        br.index_sanity_id = sn.index_sanity_id
                                             left join #indexcreatetsql ts on
                                        br.index_sanity_id = ts.index_sanity_id
                                    where br.check_id in (0, 1, 2, 11, 12, 13,
                                                          22, 34, 43, 47, 48,
                                                          50, 65, 68, 73, 99)
                                    order by br.priority asc, br.check_id asc, br.blitz_result_id asc,
                                             br.findings_group asc
                                    option (recompile);
                                end;

                        end;
                    else
                        if (@mode = 4)
                            if (@outputtype <> 'NONE')
                                begin
                                    select priority,
                                           ISNULL(br.findings_group, N'') +
                                           case when ISNULL(br.finding, N'') <> N'' then N': ' else N'' end
                                               + br.finding                             as [Finding],
                                           br.[database_name]                           as [Database Name],
                                           br.details                                   as [Details: schema.table.index(indexid)],
                                           br.index_definition                          as [Definition: [Property]] ColumnName {datatype maxbytes}],
                                           ISNULL(br.secret_columns, '')                as [Secret Columns],
                                           br.index_usage_summary                       as [Usage],
                                           br.index_size_summary                        as [Size],
                                           COALESCE(br.more_info, sn.more_info, '')     as [More Info],
                                           br.url,
                                           COALESCE(br.create_tsql, ts.create_tsql, '') as [Create TSQL]
                                    from #blitzindexresults br
                                             left join #indexsanity sn on
                                        br.index_sanity_id = sn.index_sanity_id
                                             left join #indexcreatetsql ts on
                                        br.index_sanity_id = ts.index_sanity_id
                                    order by br.priority asc, br.check_id asc, br.blitz_result_id asc,
                                             br.findings_group asc
                                    option (recompile);
                                end;

                end; /* End @Mode=0 or 4 (diagnose)*/
            else
                if (@mode = 1) /*Summarize*/
                    begin
                        --This mode is to give some overall stats on the database.
                        if (@outputtype <> 'NONE')
                            begin
                                raiserror (N'@Mode=1, we are summarizing.', 0,1) with nowait;

                                select DB_NAME(i.database_id)                                              as [Database Name],
                                       CAST((COUNT(*)) as nvarchar(256))                                   as [Number Objects],
                                       CAST(CAST(SUM(sz.total_reserved_mb) /
                                                 1024. as numeric(29, 1)) as nvarchar(500))                as [All GB],
                                       CAST(CAST(SUM(sz.total_reserved_lob_mb) /
                                                 1024. as numeric(29, 1)) as nvarchar(500))                as [LOB GB],
                                       CAST(CAST(SUM(sz.total_reserved_row_overflow_mb) /
                                                 1024. as numeric(29, 1)) as nvarchar(500))                as [Row Overflow GB],
                                       CAST(SUM(case when index_id = 1 then 1 else 0 end) as nvarchar(50)) as [Clustered Tables],
                                       CAST(SUM(case when index_id = 1 then sz.total_reserved_mb else 0 end)
                                           /
                                            1024. as numeric(29, 1))                                       as [Clustered Tables GB],
                                       SUM(case when index_id not in (0, 1) then 1 else 0 end)             as [NC Indexes],
                                       CAST(SUM(case when index_id not in (0, 1) then sz.total_reserved_mb else 0 end)
                                           /
                                            1024. as numeric(29, 1))                                       as [NC Indexes GB],
                                       case
                                           when SUM(
                                                        case when index_id not in (0, 1) then sz.total_reserved_mb else 0 end) >
                                                0 then
                                               CAST(
                                                           SUM(case when index_id in (0, 1) then sz.total_reserved_mb else 0 end)
                                                           / SUM(
                                                                   case when index_id not in (0, 1) then sz.total_reserved_mb else 0 end) as numeric(29, 1))
                                           else 0 end                                                      as [ratio table: NC Indexes],
                                       SUM(case when index_id = 0 then 1 else 0 end)                       as [Heaps],
                                       CAST(SUM(case when index_id = 0 then sz.total_reserved_mb else 0 end)
                                           /
                                            1024. as numeric(29, 1))                                       as [Heaps GB],
                                       SUM(case
                                               when index_id in (0, 1) and partition_key_column_name is not null then 1
                                               else 0 end)                                                 as [Partitioned Tables],
                                       SUM(case
                                               when index_id not in (0, 1) and partition_key_column_name is not null
                                                   then 1
                                               else 0 end)                                                 as [Partitioned NCs],
                                       CAST(SUM(case
                                                    when partition_key_column_name is not null then sz.total_reserved_mb
                                                    else 0 end) /
                                            1024. as numeric(29, 1))                                       as [Partitioned GB],
                                       SUM(case when filter_definition <> '' then 1 else 0 end)            as [Filtered Indexes],
                                       SUM(case when is_indexed_view = 1 then 1 else 0 end)                as [Indexed Views],
                                       MAX(total_rows)                                                     as [Max Row Count],
                                       CAST(MAX(case when index_id in (0, 1) then sz.total_reserved_mb else 0 end)
                                           /
                                            1024. as numeric(29, 1))                                       as [Max Table GB],
                                       CAST(MAX(case when index_id not in (0, 1) then sz.total_reserved_mb else 0 end)
                                           /
                                            1024. as numeric(29, 1))                                       as [Max NC Index GB],
                                       SUM(case
                                               when index_id in (0, 1) and sz.total_reserved_mb > 1024 then 1
                                               else 0 end)                                                 as [Count Tables > 1GB],
                                       SUM(case
                                               when index_id in (0, 1) and sz.total_reserved_mb > 10240 then 1
                                               else 0 end)                                                 as [Count Tables > 10GB],
                                       SUM(case
                                               when index_id in (0, 1) and sz.total_reserved_mb > 102400 then 1
                                               else 0 end)                                                 as [Count Tables > 100GB],
                                       SUM(case
                                               when index_id not in (0, 1) and sz.total_reserved_mb > 1024 then 1
                                               else 0 end)                                                 as [Count NCs > 1GB],
                                       SUM(case
                                               when index_id not in (0, 1) and sz.total_reserved_mb > 10240 then 1
                                               else 0 end)                                                 as [Count NCs > 10GB],
                                       SUM(case
                                               when index_id not in (0, 1) and sz.total_reserved_mb > 102400 then 1
                                               else 0 end)                                                 as [Count NCs > 100GB],
                                       MIN(create_date)                                                    as [Oldest Create Date],
                                       MAX(create_date)                                                    as [Most Recent Create Date],
                                       MAX(modify_date)                                                    as [Most Recent Modify Date],
                                       1                                                                   as [Display Order]
                                from #indexsanity as i
                                         --left join here so we don't lose disabled nc indexes
                                         left join #indexsanitysize as sz
                                                   on i.index_sanity_id = sz.index_sanity_id
                                group by DB_NAME(i.database_id)
                                union all
                                select case
                                           when @getalldatabases = 1 then N'All Databases'
                                           else N'Database ' + N' as of ' + CONVERT(nvarchar(16), GETDATE(), 121) end,
                                       @scriptversionname,
                                       N'From Your Community Volunteers',
                                       N'http://FirstResponderKit.org',
                                       @daysuptimeinsertvalue,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       null,
                                       0 as display_order
                                order by [Display Order] asc
                                option (recompile);
                            end;

                    end; /* End @Mode=1 (summarize)*/
                else
                    if (@mode = 2) /*Index Detail*/
                        begin
                            --This mode just spits out all the detail without filters.
                            --This supports slicing AND dicing in Excel
                            raiserror (N'@Mode=2, here''s the details on existing indexes.', 0,1) with nowait;


                            /* Checks if @OutputServerName is populated with a valid linked server, and that the database name specified is valid */
                            declare @validoutputserver bit;
                            declare @validoutputlocation bit;
                            declare @linkedserverdbcheck nvarchar(2000);
                            declare @validlinkedserverdb int;
                            declare @tmpdbchk table
                                              (
                                                  cnt int
                                              );
                            declare @stringtoexecute nvarchar(max);

                            if @outputservername is not null
                                begin
                                    if (SUBSTRING(@outputtablename, 2, 1) = '#')
                                        begin
                                            raiserror ('Due to the nature of temporary tables, outputting to a linked server requires a permanent table.', 16, 0);
                                        end;
                                    else
                                        if EXISTS(select server_id
                                                  from sys.servers
                                                  where QUOTENAME([name]) = @outputservername)
                                            begin
                                                set @linkedserverdbcheck = 'SELECT 1 WHERE EXISTS (SELECT * FROM ' +
                                                                           @outputservername +
                                                                           '.master.sys.databases WHERE QUOTENAME([name]) = ''' +
                                                                           @outputdatabasename + ''')';
                                                insert into @tmpdbchk exec sys.sp_executesql @linkedserverdbcheck;
                                                set @validlinkedserverdb = (select COUNT(*) from @tmpdbchk);
                                                if (@validlinkedserverdb > 0)
                                                    begin
                                                        set @validoutputserver = 1;
                                                        set @validoutputlocation = 1;
                                                    end;
                                                else
                                                    raiserror ('The specified database was not found on the output server', 16, 0);
                                            end;
                                        else
                                            begin
                                                raiserror ('The specified output server was not found', 16, 0);
                                            end;
                                end;
                            else
                                begin
                                    if (SUBSTRING(@outputtablename, 2, 2) = '##')
                                        begin
                                            set @stringtoexecute =
                                                    N' IF (OBJECT_ID(''[tempdb].[dbo].@@@OutputTableName@@@'') IS NOT NULL) DROP TABLE @@@OutputTableName@@@';
                                            set @stringtoexecute =
                                                    REPLACE(@stringtoexecute, '@@@OutputTableName@@@', @outputtablename);
                                            exec (@stringtoexecute);

                                            set @outputservername =
                                                    QUOTENAME(CAST(SERVERPROPERTY('ServerName') as nvarchar(128)));
                                            set @outputdatabasename = '[tempdb]';
                                            set @outputschemaname = '[dbo]';
                                            set @validoutputlocation = 1;
                                        end;
                                    else
                                        if (SUBSTRING(@outputtablename, 2, 1) = '#')
                                            begin
                                                raiserror ('Due to the nature of Dymamic SQL, only global (i.e. double pound (##)) temp tables are supported for @OutputTableName', 16, 0);
                                            end;
                                        else
                                            if @outputdatabasename is not null
                                                and @outputschemaname is not null
                                                and @outputtablename is not null
                                                and EXISTS(select *
                                                           from sys.databases
                                                           where QUOTENAME([name]) = @outputdatabasename)
                                                begin
                                                    set @validoutputlocation = 1;
                                                    set @outputservername =
                                                            QUOTENAME(CAST(SERVERPROPERTY('ServerName') as nvarchar(128)));
                                                end;
                                            else
                                                if @outputdatabasename is not null
                                                    and @outputschemaname is not null
                                                    and @outputtablename is not null
                                                    and not EXISTS(select *
                                                                   from sys.databases
                                                                   where QUOTENAME([name]) = @outputdatabasename)
                                                    begin
                                                        raiserror ('The specified output database was not found on this server', 16, 0);
                                                    end;
                                                else
                                                    begin
                                                        set @validoutputlocation = 0;
                                                    end;
                                end;

                            if (@validoutputlocation = 0 and @outputtype = 'NONE')
                                begin
                                    raiserror ('Invalid output location and no output asked',12,1);
                                    return;
                                end;

                            /* @OutputTableName lets us export the results to a permanent table */
                            declare @runid uniqueidentifier;
                            set @runid = NEWID();

                            if (@validoutputlocation = 1 and
                                COALESCE(@outputservername, @outputdatabasename, @outputschemaname,
                                         @outputtablename) is not null)
                                begin
                                    declare @tableexists bit;
                                    declare @schemaexists bit;
                                    set @stringtoexecute =
                                            N'SET @SchemaExists = 0;
					SET @TableExists = 0;
					IF EXISTS(SELECT * FROM @@@OutputServerName@@@.@@@OutputDatabaseName@@@.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = ''@@@OutputSchemaName@@@'')
						SET @SchemaExists = 1
					IF EXISTS (SELECT * FROM @@@OutputServerName@@@.@@@OutputDatabaseName@@@.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = ''@@@OutputSchemaName@@@'' AND QUOTENAME(TABLE_NAME) = ''@@@OutputTableName@@@'')
						SET @TableExists = 1';

                                    set @stringtoexecute =
                                            REPLACE(@stringtoexecute, '@@@OutputServerName@@@', @outputservername);
                                    set @stringtoexecute =
                                            REPLACE(@stringtoexecute, '@@@OutputDatabaseName@@@', @outputdatabasename);
                                    set @stringtoexecute =
                                            REPLACE(@stringtoexecute, '@@@OutputSchemaName@@@', @outputschemaname);
                                    set @stringtoexecute =
                                            REPLACE(@stringtoexecute, '@@@OutputTableName@@@', @outputtablename);

                                    exec sp_executesql @stringtoexecute,
                                         N'@TableExists BIT OUTPUT, @SchemaExists BIT OUTPUT', @tableexists output,
                                         @schemaexists output;

                                    if @schemaexists = 1
                                        begin
                                            if @tableexists = 0
                                                begin
                                                    set @stringtoexecute =
                                                            N'CREATE TABLE @@@OutputDatabaseName@@@.@@@OutputSchemaName@@@.@@@OutputTableName@@@
										(
											[id] INT IDENTITY(1,1) NOT NULL,
											[run_id] UNIQUEIDENTIFIER,
											[run_datetime] DATETIME,
											[server_name] NVARCHAR(128),
											[database_name] NVARCHAR(128),
											[schema_name] NVARCHAR(128),
											[table_name] NVARCHAR(128),
											[index_name] NVARCHAR(128),
                                            [Drop_Tsql] NVARCHAR(MAX),
                                            [Create_Tsql] NVARCHAR(MAX),
											[index_id] INT,
											[db_schema_object_indexid] NVARCHAR(500),
											[object_type] NVARCHAR(15),
											[index_definition] NVARCHAR(MAX),
											[key_column_names_with_sort_order] NVARCHAR(MAX),
											[count_key_columns] INT,
											[include_column_names] NVARCHAR(MAX),
											[count_included_columns] INT,
											[secret_columns] NVARCHAR(MAX),
											[count_secret_columns] INT,
											[partition_key_column_name] NVARCHAR(MAX),
											[filter_definition] NVARCHAR(MAX),
											[is_indexed_view] BIT,
											[is_primary_key] BIT,
											[is_XML] BIT,
											[is_spatial] BIT,
											[is_NC_columnstore] BIT,
											[is_CX_columnstore] BIT,
											[is_in_memory_oltp] BIT,
											[is_disabled] BIT,
											[is_hypothetical] BIT,
											[is_padded] BIT,
											[fill_factor] INT,
											[is_referenced_by_foreign_key] BIT,
											[last_user_seek] DATETIME,
											[last_user_scan] DATETIME,
											[last_user_lookup] DATETIME,
											[last_user_update] DATETIME,
											[total_reads] BIGINT,
											[user_updates] BIGINT,
											[reads_per_write] MONEY,
											[index_usage_summary] NVARCHAR(200),
											[total_singleton_lookup_count] BIGINT,
											[total_range_scan_count] BIGINT,
											[total_leaf_delete_count] BIGINT,
											[total_leaf_update_count] BIGINT,
											[index_op_stats] NVARCHAR(200),
											[partition_count] INT,
											[total_rows] BIGINT,
											[total_reserved_MB] NUMERIC(29,2),
											[total_reserved_LOB_MB] NUMERIC(29,2),
											[total_reserved_row_overflow_MB] NUMERIC(29,2),
											[index_size_summary] NVARCHAR(300),
											[total_row_lock_count] BIGINT,
											[total_row_lock_wait_count] BIGINT,
											[total_row_lock_wait_in_ms] BIGINT,
											[avg_row_lock_wait_in_ms] BIGINT,
											[total_page_lock_count] BIGINT,
											[total_page_lock_wait_count] BIGINT,
											[total_page_lock_wait_in_ms] BIGINT,
											[avg_page_lock_wait_in_ms] BIGINT,
											[total_index_lock_promotion_attempt_count] BIGINT,
											[total_index_lock_promotion_count] BIGINT,
											[data_compression_desc] NVARCHAR(4000),
						                    [page_latch_wait_count] BIGINT,
								            [page_latch_wait_in_ms] BIGINT,
								            [page_io_latch_wait_count] BIGINT,
								            [page_io_latch_wait_in_ms] BIGINT,
											[create_date] DATETIME,
											[modify_date] DATETIME,
											[more_info] NVARCHAR(500),
											[display_order] INT,
											CONSTRAINT [PK_ID_@@@RunID@@@] PRIMARY KEY CLUSTERED ([id] ASC)
										);';

                                                    set @stringtoexecute = REPLACE(@stringtoexecute,
                                                                                   '@@@OutputDatabaseName@@@',
                                                                                   @outputdatabasename);
                                                    set @stringtoexecute =
                                                            REPLACE(@stringtoexecute, '@@@OutputSchemaName@@@', @outputschemaname);
                                                    set @stringtoexecute =
                                                            REPLACE(@stringtoexecute, '@@@OutputTableName@@@', @outputtablename);
                                                    set @stringtoexecute = REPLACE(@stringtoexecute, '@@@RunID@@@', @runid);

                                                    if @validoutputserver = 1
                                                        begin
                                                            set @stringtoexecute = REPLACE(@stringtoexecute, '''', '''''');
                                                            exec ('EXEC('''+@stringtoexecute+''') AT ' + @outputservername);
                                                        end;
                                                    else
                                                        begin
                                                            exec (@stringtoexecute);
                                                        end;
                                                end; /* @TableExists = 0 */

                                            set @stringtoexecute =
                                                    N'IF EXISTS(SELECT * FROM @@@OutputServerName@@@.@@@OutputDatabaseName@@@.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = ''@@@OutputSchemaName@@@'')
								AND NOT EXISTS (SELECT * FROM @@@OutputServerName@@@.@@@OutputDatabaseName@@@.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = ''@@@OutputSchemaName@@@'' AND QUOTENAME(TABLE_NAME) = ''@@@OutputTableName@@@'')
								SET @TableExists = 0
							ELSE
								SET @TableExists = 1';

                                            set @tableexists = null;
                                            set @stringtoexecute =
                                                    REPLACE(@stringtoexecute, '@@@OutputServerName@@@', @outputservername);
                                            set @stringtoexecute = REPLACE(@stringtoexecute, '@@@OutputDatabaseName@@@',
                                                                           @outputdatabasename);
                                            set @stringtoexecute =
                                                    REPLACE(@stringtoexecute, '@@@OutputSchemaName@@@', @outputschemaname);
                                            set @stringtoexecute =
                                                    REPLACE(@stringtoexecute, '@@@OutputTableName@@@', @outputtablename);

                                            exec sp_executesql @stringtoexecute, N'@TableExists BIT OUTPUT',
                                                 @tableexists output;

                                            if @tableexists = 1
                                                begin
                                                    set @stringtoexecute =
                                                            N'INSERT @@@OutputServerName@@@.@@@OutputDatabaseName@@@.@@@OutputSchemaName@@@.@@@OutputTableName@@@
										(
											[run_id],
											[run_datetime],
											[server_name],
											[database_name],
											[schema_name],
											[table_name],
											[index_name],
                                            [Drop_Tsql],
                                            [Create_Tsql],
											[index_id],
											[db_schema_object_indexid],
											[object_type],
											[index_definition],
											[key_column_names_with_sort_order],
											[count_key_columns],
											[include_column_names],
											[count_included_columns],
											[secret_columns],
											[count_secret_columns],
											[partition_key_column_name],
											[filter_definition],
											[is_indexed_view],
											[is_primary_key],
											[is_XML],
											[is_spatial],
											[is_NC_columnstore],
											[is_CX_columnstore],
                                            [is_in_memory_oltp],
											[is_disabled],
											[is_hypothetical],
											[is_padded],
											[fill_factor],
											[is_referenced_by_foreign_key],
											[last_user_seek],
											[last_user_scan],
											[last_user_lookup],
											[last_user_update],
											[total_reads],
											[user_updates],
											[reads_per_write],
											[index_usage_summary],
											[total_singleton_lookup_count],
											[total_range_scan_count],
											[total_leaf_delete_count],
											[total_leaf_update_count],
											[index_op_stats],
											[partition_count],
											[total_rows],
											[total_reserved_MB],
											[total_reserved_LOB_MB],
											[total_reserved_row_overflow_MB],
											[index_size_summary],
											[total_row_lock_count],
											[total_row_lock_wait_count],
											[total_row_lock_wait_in_ms],
											[avg_row_lock_wait_in_ms],
											[total_page_lock_count],
											[total_page_lock_wait_count],
											[total_page_lock_wait_in_ms],
											[avg_page_lock_wait_in_ms],
											[total_index_lock_promotion_attempt_count],
											[total_index_lock_promotion_count],
											[data_compression_desc],
						                    [page_latch_wait_count],
								            [page_latch_wait_in_ms],
								            [page_io_latch_wait_count],
								            [page_io_latch_wait_in_ms],
											[create_date],
											[modify_date],
											[more_info],
											[display_order]
										)
									SELECT ''@@@RunID@@@'',
										''@@@GETDATE@@@'',
										''@@@LocalServerName@@@'',
										-- Below should be a copy/paste of the real query
										-- Make sure all quotes are escaped
										i.[database_name] AS [Database Name],
										i.[schema_name] AS [Schema Name],
										i.[object_name] AS [Object Name],
										ISNULL(i.index_name, '''') AS [Index Name],
                                        CASE
						                    WHEN i.is_primary_key = 1 AND i.index_definition <> ''[HEAP]''
							                    THEN N''-ALTER TABLE '' + QUOTENAME(i.[database_name]) + N''.'' + QUOTENAME(i.[schema_name]) + N''.'' + QUOTENAME(i.[object_name]) +
							                         N'' DROP CONSTRAINT '' + QUOTENAME(i.index_name) + N'';''
						                    WHEN i.is_primary_key = 0 AND i.index_definition <> ''[HEAP]''
						                        THEN N''--DROP INDEX ''+ QUOTENAME(i.index_name) + N'' ON '' + QUOTENAME(i.[database_name]) + N''.'' +
							                         QUOTENAME(i.[schema_name]) + N''.'' + QUOTENAME(i.[object_name]) + N'';''
						                ELSE N''''
						                END AS [Drop TSQL],
					                    CASE
						                    WHEN i.index_definition = ''[HEAP]'' THEN N''''
					                            ELSE N''--'' + ict.create_tsql END AS [Create TSQL],
										CAST(i.index_id AS NVARCHAR(10))AS [Index ID],
										db_schema_object_indexid AS [Details: schema.table.index(indexid)],
										CASE    WHEN index_id IN ( 1, 0 ) THEN ''TABLE''
											ELSE ''NonClustered''
											END AS [Object Type],
										LEFT(index_definition,4000) AS [Definition: [Property]] ColumnName {datatype maxbytes}],
										ISNULL(LTRIM(key_column_names_with_sort_order), '''') AS [Key Column Names With Sort],
										ISNULL(count_key_columns, 0) AS [Count Key Columns],
										ISNULL(include_column_names, '''') AS [Include Column Names],
										ISNULL(count_included_columns,0) AS [Count Included Columns],
										ISNULL(secret_columns,'''') AS [Secret Column Names],
										ISNULL(count_secret_columns,0) AS [Count Secret Columns],
										ISNULL(partition_key_column_name, '''') AS [Partition Key Column Name],
										ISNULL(filter_definition, '''') AS [Filter Definition],
										is_indexed_view AS [Is Indexed View],
										is_primary_key AS [Is Primary Key],
										is_XML AS [Is XML],
										is_spatial AS [Is Spatial],
										is_NC_columnstore AS [Is NC Columnstore],
										is_CX_columnstore AS [Is CX Columnstore],
										is_in_memory_oltp AS [Is In-Memory OLTP],
										is_disabled AS [Is Disabled],
										is_hypothetical AS [Is Hypothetical],
										is_padded AS [Is Padded],
										fill_factor AS [Fill Factor],
										is_referenced_by_foreign_key AS [Is Reference by Foreign Key],
										last_user_seek AS [Last User Seek],
										last_user_scan AS [Last User Scan],
										last_user_lookup AS [Last User Lookup],
										last_user_update AS [Last User Update],
										total_reads AS [Total Reads],
										user_updates AS [User Updates],
										reads_per_write AS [Reads Per Write],
										index_usage_summary AS [Index Usage],
										sz.total_singleton_lookup_count AS [Singleton Lookups],
										sz.total_range_scan_count AS [Range Scans],
										sz.total_leaf_delete_count AS [Leaf Deletes],
										sz.total_leaf_update_count AS [Leaf Updates],
										sz.index_op_stats AS [Index Op Stats],
										sz.partition_count AS [Partition Count],
										sz.total_rows AS [Rows],
										sz.total_reserved_MB AS [Reserved MB],
										sz.total_reserved_LOB_MB AS [Reserved LOB MB],
										sz.total_reserved_row_overflow_MB AS [Reserved Row Overflow MB],
										sz.index_size_summary AS [Index Size],
										sz.total_row_lock_count AS [Row Lock Count],
										sz.total_row_lock_wait_count AS [Row Lock Wait Count],
										sz.total_row_lock_wait_in_ms AS [Row Lock Wait ms],
										sz.avg_row_lock_wait_in_ms AS [Avg Row Lock Wait ms],
										sz.total_page_lock_count AS [Page Lock Count],
										sz.total_page_lock_wait_count AS [Page Lock Wait Count],
										sz.total_page_lock_wait_in_ms AS [Page Lock Wait ms],
										sz.avg_page_lock_wait_in_ms AS [Avg Page Lock Wait ms],
										sz.total_index_lock_promotion_attempt_count AS [Lock Escalation Attempts],
										sz.total_index_lock_promotion_count AS [Lock Escalations],
										sz.data_compression_desc AS [Data Compression],
						                sz.page_latch_wait_count,
								        sz.page_latch_wait_in_ms,
								        sz.page_io_latch_wait_count,
								        sz.page_io_latch_wait_in_ms,
										i.create_date AS [Create Date],
										i.modify_date AS [Modify Date],
										more_info AS [More Info],
										1 AS [Display Order]
									FROM #IndexSanity AS i
									LEFT JOIN #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
                                    LEFT JOIN #IndexCreateTsql AS ict  ON i.index_sanity_id = ict.index_sanity_id
									ORDER BY [Database Name], [Schema Name], [Object Name], [Index ID]
									OPTION (RECOMPILE);';

                                                    set @stringtoexecute =
                                                            REPLACE(@stringtoexecute, '@@@OutputServerName@@@', @outputservername);
                                                    set @stringtoexecute =
                                                            REPLACE(@stringtoexecute, '@@@OutputDatabaseName@@@',
                                                                    @outputdatabasename);
                                                    set @stringtoexecute =
                                                            REPLACE(@stringtoexecute, '@@@OutputSchemaName@@@', @outputschemaname);
                                                    set @stringtoexecute =
                                                            REPLACE(@stringtoexecute, '@@@OutputTableName@@@', @outputtablename);
                                                    set @stringtoexecute = REPLACE(@stringtoexecute, '@@@RunID@@@', @runid);
                                                    set @stringtoexecute =
                                                            REPLACE(@stringtoexecute, '@@@GETDATE@@@', GETDATE());
                                                    set @stringtoexecute =
                                                            REPLACE(@stringtoexecute, '@@@LocalServerName@@@',
                                                                    CAST(SERVERPROPERTY('ServerName') as nvarchar(128)));
                                                    exec (@stringtoexecute);
                                                end; /* @TableExists = 1 */
                                            else
                                                raiserror ('Creation of the output table failed.', 16, 0);
                                        end; /* @TableExists = 0 */
                                    else
                                        raiserror (N'Invalid schema name, data could not be saved.', 16, 0);
                                end; /* @ValidOutputLocation = 1 */
                            else

                                if (@outputtype <> 'NONE')
                                    begin
                                        select i.[database_name]                                   as [Database Name],
                                               i.[schema_name]                                     as [Schema Name],
                                               i.[object_name]                                     as [Object Name],
                                               ISNULL(i.index_name, '')                            as [Index Name],
                                               CAST(i.index_id as nvarchar(10))                    as [Index ID],
                                               db_schema_object_indexid                            as [Details: schema.table.index(indexid)],
                                               case
                                                   when index_id in (1, 0) then 'TABLE'
                                                   else 'NonClustered'
                                                   end                                             as [Object Type],
                                               index_definition                                    as [Definition: [Property]] ColumnName {datatype maxbytes}],
                                               ISNULL(LTRIM(key_column_names_with_sort_order), '') as [Key Column Names With Sort],
                                               ISNULL(count_key_columns, 0)                        as [Count Key Columns],
                                               ISNULL(include_column_names, '')                    as [Include Column Names],
                                               ISNULL(count_included_columns, 0)                   as [Count Included Columns],
                                               ISNULL(secret_columns, '')                          as [Secret Column Names],
                                               ISNULL(count_secret_columns, 0)                     as [Count Secret Columns],
                                               ISNULL(partition_key_column_name, '')               as [Partition Key Column Name],
                                               ISNULL(filter_definition, '')                       as [Filter Definition],
                                               is_indexed_view                                     as [Is Indexed View],
                                               is_primary_key                                      as [Is Primary Key],
                                               is_xml                                              as [Is XML],
                                               is_spatial                                          as [Is Spatial],
                                               is_nc_columnstore                                   as [Is NC Columnstore],
                                               is_cx_columnstore                                   as [Is CX Columnstore],
                                               is_in_memory_oltp                                   as [Is In-Memory OLTP],
                                               is_disabled                                         as [Is Disabled],
                                               is_hypothetical                                     as [Is Hypothetical],
                                               is_padded                                           as [Is Padded],
                                               fill_factor                                         as [Fill Factor],
                                               is_referenced_by_foreign_key                        as [Is Reference by Foreign Key],
                                               last_user_seek                                      as [Last User Seek],
                                               last_user_scan                                      as [Last User Scan],
                                               last_user_lookup                                    as [Last User Lookup],
                                               last_user_update                                    as [Last User Update],
                                               total_reads                                         as [Total Reads],
                                               user_updates                                        as [User Updates],
                                               reads_per_write                                     as [Reads Per Write],
                                               index_usage_summary                                 as [Index Usage],
                                               sz.total_singleton_lookup_count                     as [Singleton Lookups],
                                               sz.total_range_scan_count                           as [Range Scans],
                                               sz.total_leaf_delete_count                          as [Leaf Deletes],
                                               sz.total_leaf_update_count                          as [Leaf Updates],
                                               sz.index_op_stats                                   as [Index Op Stats],
                                               sz.partition_count                                  as [Partition Count],
                                               sz.total_rows                                       as [Rows],
                                               sz.total_reserved_mb                                as [Reserved MB],
                                               sz.total_reserved_lob_mb                            as [Reserved LOB MB],
                                               sz.total_reserved_row_overflow_mb                   as [Reserved Row Overflow MB],
                                               sz.index_size_summary                               as [Index Size],
                                               sz.total_row_lock_count                             as [Row Lock Count],
                                               sz.total_row_lock_wait_count                        as [Row Lock Wait Count],
                                               sz.total_row_lock_wait_in_ms                        as [Row Lock Wait ms],
                                               sz.avg_row_lock_wait_in_ms                          as [Avg Row Lock Wait ms],
                                               sz.total_page_lock_count                            as [Page Lock Count],
                                               sz.total_page_lock_wait_count                       as [Page Lock Wait Count],
                                               sz.total_page_lock_wait_in_ms                       as [Page Lock Wait ms],
                                               sz.avg_page_lock_wait_in_ms                         as [Avg Page Lock Wait ms],
                                               sz.total_index_lock_promotion_attempt_count         as [Lock Escalation Attempts],
                                               sz.total_index_lock_promotion_count                 as [Lock Escalations],
                                               sz.page_latch_wait_count                            as [Page Latch Wait Count],
                                               sz.page_latch_wait_in_ms                            as [Page Latch Wait ms],
                                               sz.page_io_latch_wait_count                         as [Page IO Latch Wait Count],
                                               sz.page_io_latch_wait_in_ms                         as [Page IO Latch Wait ms],
                                               sz.total_forwarded_fetch_count                      as [Forwarded Fetches],
                                               sz.data_compression_desc                            as [Data Compression],
                                               i.create_date                                       as [Create Date],
                                               i.modify_date                                       as [Modify Date],
                                               more_info                                           as [More Info],
                                               case
                                                   when i.is_primary_key = 1 and i.index_definition <> '[HEAP]'
                                                       then N'--ALTER TABLE ' + QUOTENAME(i.[database_name]) + N'.' +
                                                            QUOTENAME(i.[schema_name]) + N'.' +
                                                            QUOTENAME(i.[object_name])
                                                       + N' DROP CONSTRAINT ' + QUOTENAME(i.index_name) + N';'
                                                   when i.is_primary_key = 0 and i.index_definition <> '[HEAP]'
                                                       then N'--DROP INDEX ' + QUOTENAME(i.index_name) + N' ON ' +
                                                            QUOTENAME(i.[database_name]) + N'.' +
                                                            QUOTENAME(i.[schema_name]) + N'.' +
                                                            QUOTENAME(i.[object_name]) + N';'
                                                   else N''
                                                   end                                             as [Drop TSQL],
                                               case
                                                   when i.index_definition = '[HEAP]' then N''
                                                   else N'--' + ict.create_tsql end                as [Create TSQL],
                                               1                                                   as [Display Order]
                                        from #indexsanity as i --left join here so we don't lose disabled nc indexes
                                                 left join #indexsanitysize as sz on i.index_sanity_id = sz.index_sanity_id
                                                 left join #indexcreatetsql as ict on i.index_sanity_id = ict.index_sanity_id
                                        order by [Database Name], [Schema Name], [Object Name], [Index ID]
                                        option (recompile);
                                    end;


                        end; /* End @Mode=2 (index detail)*/
                    else
                        if (@mode = 3) /*Missing index Detail*/
                            begin
                                if (@outputtype <> 'NONE')
                                    begin
                                        ;
                                        with create_date as (
                                            select i.database_id,
                                                   i.schema_name,
                                                   i.[object_id],
                                                   ISNULL(NULLIF(MAX(DATEDIFF(day, i.create_date, SYSDATETIME())), 0),
                                                          1) as create_days
                                            from #indexsanity as i
                                            group by i.database_id, i.schema_name, i.object_id
                                        )
                                        select mi.database_name          as [Database Name],
                                               mi.[schema_name]          as [Schema],
                                               mi.table_name             as [Table],
                                               CAST((mi.magic_benefit_number / case
                                                                                   when cd.create_days < @daysuptime
                                                                                       then cd.create_days
                                                                                   else @daysuptime end) as bigint)
                                                                         as [Magic Benefit Number],
                                               mi.missing_index_details  as [Missing Index Details],
                                               mi.avg_total_user_cost    as [Avg Query Cost],
                                               mi.avg_user_impact        as [Est Index Improvement],
                                               mi.user_seeks             as [Seeks],
                                               mi.user_scans             as [Scans],
                                               mi.unique_compiles        as [Compiles],
                                               mi.equality_columns       as [Equality Columns],
                                               mi.inequality_columns     as [Inequality Columns],
                                               mi.included_columns       as [Included Columns],
                                               mi.index_estimated_impact as [Estimated Impact],
                                               mi.create_tsql            as [Create TSQL],
                                               mi.more_info              as [More Info],
                                               1                         as [Display Order],
                                               mi.is_low
                                        from #missingindexes as mi
                                                 left join create_date as cd
                                                           on mi.[object_id] = cd.object_id
                                                               and mi.database_id = cd.database_id
                                                               and mi.schema_name = cd.schema_name
                                            /* Minimum benefit threshold = 100k/day of uptime OR since table creation date, whichever is lower*/
                                        where (mi.magic_benefit_number / case
                                                                             when cd.create_days < @daysuptime
                                                                                 then cd.create_days
                                                                             else @daysuptime end) >= 100000
                                        union all
                                        select @scriptversionname,
                                               N'From Your Community Volunteers',
                                               N'http://FirstResponderKit.org',
                                               100000000000,
                                               @daysuptimeinsertvalue,
                                               null,
                                               null,
                                               null,
                                               null,
                                               null,
                                               null,
                                               null,
                                               null,
                                               null,
                                               null,
                                               null,
                                               0    as [Display Order],
                                               null as is_low
                                        order by [Display Order] asc, [Magic Benefit Number] desc
                                        option (recompile);
                                    end;

                                if (@bringthepain = 1
                                    and @databasename is not null
                                    and @getalldatabases = 0)
                                    begin

                                        exec sp_BlitzCache @sortorder = 'sp_BlitzIndex', @databasename = @databasename,
                                             @bringthepain = 1, @queryfilter = 'statement', @hidesummary = 1;

                                    end;


                            end; /* End @Mode=3 (index detail)*/
        end;
end try
begin catch
    raiserror (N'Failure analyzing temp tables.', 0,1) with nowait;

    select @msg = ERROR_MESSAGE(), @errorseverity = ERROR_SEVERITY(), @errorstate = ERROR_STATE();

    raiserror (@msg,
        @errorseverity,
        @errorstate
        );

    while @@trancount > 0
        rollback;

    return;
end catch;
go
if OBJECT_ID('dbo.sp_BlitzLock') is null
    exec ('CREATE PROCEDURE dbo.sp_BlitzLock AS RETURN 0;');
go

alter procedure dbo.sp_blitzlock(@top int = 2147483647,
                                 @databasename nvarchar(256) = null,
                                 @startdate datetime = '19000101',
                                 @enddate datetime = '99991231',
                                 @objectname nvarchar(1000) = null,
                                 @storedprocname nvarchar(1000) = null,
                                 @appname nvarchar(256) = null,
                                 @hostname nvarchar(256) = null,
                                 @loginname nvarchar(256) = null,
                                 @eventsessionpath varchar(256) = 'system_health*.xel',
                                 @victimsonly bit = 0,
                                 @debug bit = 0,
                                 @help bit = 0,
                                 @version varchar(30) = null output,
                                 @versiondate datetime = null output,
                                 @versioncheckmode bit = 0,
                                 @outputdatabasename nvarchar(256) = null,
                                 @outputschemaname nvarchar(256) = 'dbo', --ditto as below
                                 @outputtablename nvarchar(256) = 'BlitzLock' --put a standard here no need to check later in the script
)
    with recompile
as
begin

    set nocount on;
    set transaction isolation level read uncommitted;

    select @version = '2.97', @versiondate = '20200712';


    if (@versioncheckmode = 1)
        begin
            return;
        end;
    if @help = 1
        print '
	/*
	sp_BlitzLock from http://FirstResponderKit.org

	This script checks for and analyzes deadlocks from the system health session or a custom extended event path

	Variables you can use:
		@Top: Use if you want to limit the number of deadlocks to return.
			  This is ordered by event date ascending

		@DatabaseName: If you want to filter to a specific database

		@StartDate: The date you want to start searching on.

		@EndDate: The date you want to stop searching on.

		@ObjectName: If you want to filter to a specific able.
					 The object name has to be fully qualified ''Database.Schema.Table''

		@StoredProcName: If you want to search for a single stored proc
					 The proc name has to be fully qualified ''Database.Schema.Sproc''

		@AppName: If you want to filter to a specific application

		@HostName: If you want to filter to a specific host

		@LoginName: If you want to filter to a specific login

		@EventSessionPath: If you want to point this at an XE session rather than the system health session.

		@OutputDatabaseName: If you want to output information to a specific database
		@OutputSchemaName: Specify a schema name to output information to a specific Schema
		@OutputTableName: Specify table name to to output information to a specific table

	To learn more, visit http://FirstResponderKit.org where you can download new
	versions for free, watch training videos on how it works, get more info on
	the findings, contribute your own code, and more.

	Known limitations of this version:
	 - Only SQL Server 2012 and newer is supported
	 - If your tables have weird characters in them (https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references) you may get errors trying to parse the XML.
	   I took a long look at this one, and:
		1) Trying to account for all the weird places these could crop up is a losing effort.
		2) Replace is slow af on lots of XML.
	- Your mom.




	Unknown limitations of this version:
	 - None.  (If we knew them, they would be known. Duh.)


    MIT License

	Copyright (c) 2020 Brent Ozar Unlimited

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

	*/';


    declare @productversion nvarchar(128);
    declare @productversionmajor float;
    declare @productversionminor int;

    set @productversion = CAST(SERVERPROPERTY('ProductVersion') as nvarchar(128));

    select @productversionmajor = SUBSTRING(@productversion, 1, CHARINDEX('.', @productversion) + 1),
           @productversionminor = PARSENAME(CONVERT(varchar(32), @productversion), 2);


    if @productversionmajor < 11.0
        begin
            raiserror (
                'sp_BlitzLock will throw a bunch of angry errors on versions of SQL Server earlier than 2012.',
                0,
                1) with nowait;
            return;
        end;

    if ((select SERVERPROPERTY('EDITION')) = 'SQL Azure'
        and
        LOWER(@eventsessionpath) not like 'http%')
        begin
            raiserror (
                'The default storage path doesn''t work in Azure SQLDB/Managed instances.
You need to use an Azure storage account, and the path has to look like this: https://StorageAccount.blob.core.windows.net/Container/FileName.xel',
                0,
                1) with nowait;
            return;
        end;


    if @top is null
        set @top = 2147483647;

    if @startdate is null
        set @startdate = '19000101';

    if @enddate is null
        set @enddate = '99991231';


    if OBJECT_ID('tempdb..#deadlock_data') is not null
        drop table #deadlock_data;

    if OBJECT_ID('tempdb..#deadlock_process') is not null
        drop table #deadlock_process;

    if OBJECT_ID('tempdb..#deadlock_stack') is not null
        drop table #deadlock_stack;

    if OBJECT_ID('tempdb..#deadlock_resource') is not null
        drop table #deadlock_resource;

    if OBJECT_ID('tempdb..#deadlock_owner_waiter') is not null
        drop table #deadlock_owner_waiter;

    if OBJECT_ID('tempdb..#deadlock_findings') is not null
        drop table #deadlock_findings;

    create table #deadlock_findings
    (
        id int identity (1, 1) primary key clustered,
        check_id int not null,
        database_name nvarchar(256),
        object_name nvarchar(1000),
        finding_group nvarchar(100),
        finding nvarchar(4000)
    );

    declare @d varchar(40), @stringtoexecute nvarchar(4000),@stringtoexecuteparams nvarchar(500),@r nvarchar(200),@outputtablefindings nvarchar(100);
    declare @servername nvarchar(256)
    declare @outputdatabasecheck bit;
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    set @outputtablefindings = '[BlitzLockFindings]'
    set @servername = (select @@ServerName)
    if (@outputdatabasename is not null)
        begin
            --if databaseName is set do some sanity checks and put [] around def.
            if ((select name from sys.databases where name = @outputdatabasename) is null) --if database is invalid raiserror and set bitcheck
                begin
                    raiserror ('Database Name for output of table is invalid please correct, Output to Table will not be preformed', 0, 1, @d) with nowait;
                    set @outputdatabasecheck = -1 -- -1 invalid/false, 0 = good/true
                end
            else
                begin
                    set @outputdatabasecheck = 0
                    select @stringtoexecute = N'select @r = name from ' + '' + @outputdatabasename +
                                              '' + '.sys.objects where type_desc=''USER_TABLE'' and name=' + '''' +
                                              @outputtablename + '''',
                           @stringtoexecuteparams =
                           N'@OutputDatabaseName NVARCHAR(200),@OutputTableName NVARCHAR(200),@r NVARCHAR(200) OUTPUT'
                    exec sp_executesql @stringtoexecute, @stringtoexecuteparams, @outputdatabasename, @outputtablename,
                         @r output
                    --put covers around all before.
                    select @outputdatabasename = QUOTENAME(@outputdatabasename),
                           @outputtablename = QUOTENAME(@outputtablename),
                           @outputschemaname = QUOTENAME(@outputschemaname)
                    if (@r is null) --if it is null there is no table, create it from above execution
                        begin
                            select @stringtoexecute =
                                   N'use ' + @outputdatabasename + ';create table ' + @outputschemaname + '.' +
                                   @outputtablename + ' (
							ServerName NVARCHAR(256),
							deadlock_type NVARCHAR(256),
							event_date datetime,
							database_name NVARCHAR(256),
							deadlock_group NVARCHAR(256),
							query XML,
							object_names XML,
							isolation_level NVARCHAR(256),
							owner_mode NVARCHAR(256),
							waiter_mode NVARCHAR(256),
							transaction_count bigint,
							login_name NVARCHAR(256),
							host_name NVARCHAR(256),
							client_app NVARCHAR(256),
							wait_time BIGINT,
							priority smallint,
							log_used BIGINT,
							last_tran_started datetime,
							last_batch_started datetime,
							last_batch_completed datetime,
							transaction_name NVARCHAR(256),
							owner_waiter_type NVARCHAR(256),
							owner_activity NVARCHAR(256),
							owner_waiter_activity NVARCHAR(256),
							owner_merging NVARCHAR(256),
							owner_spilling NVARCHAR(256),
							owner_waiting_to_close NVARCHAR(256),
							waiter_waiter_type NVARCHAR(256),
							waiter_owner_activity NVARCHAR(256),
							waiter_waiter_activity NVARCHAR(256),
							waiter_merging NVARCHAR(256),
							waiter_spilling NVARCHAR(256),
							waiter_waiting_to_close NVARCHAR(256),
							deadlock_graph XML)',
                                   @stringtoexecuteparams =
                                   N'@OutputDatabaseName NVARCHAR(200),@OutputSchemaName NVARCHAR(100),@OutputTableName NVARCHAR(200)'
                            exec sp_executesql @stringtoexecute, @stringtoexecuteparams, @outputdatabasename,
                                 @outputschemaname, @outputtablename
                            --table created.
                            select @stringtoexecute = N'select @r = name from ' + '' + @outputdatabasename +
                                                      '' +
                                                      '.sys.objects where type_desc=''USER_TABLE'' and name=''BlitzLockFindings''',
                                   @stringtoexecuteparams = N'@OutputDatabaseName NVARCHAR(200),@r NVARCHAR(200) OUTPUT'
                            exec sp_executesql @stringtoexecute, @stringtoexecuteparams, @outputdatabasename, @r output
                            if (@r is null) --if table does not excist
                                begin
                                    select @outputtablefindings = N'[BlitzLockFindings]',
                                           @stringtoexecute =
                                           N'use ' + @outputdatabasename + ';create table ' + @outputschemaname + '.' +
                                           @outputtablefindings + ' (
								ServerName NVARCHAR(256),
								check_id INT,
								database_name NVARCHAR(256),
								object_name NVARCHAR(1000),
								finding_group NVARCHAR(100),
								finding NVARCHAR(4000))',
                                           @stringtoexecuteparams =
                                           N'@OutputDatabaseName NVARCHAR(200),@OutputSchemaName NVARCHAR(100),@OutputTableFindings NVARCHAR(200)'
                                    exec sp_executesql @stringtoexecute, @stringtoexecuteparams, @outputdatabasename,
                                         @outputschemaname, @outputtablefindings

                                end

                        end
                    --create synonym for deadlockfindings.
                    if ((select name
                         from sys.objects
                         where name = 'DeadlockFindings' and type_desc = 'SYNONYM') is not null)
                        begin
                            raiserror ('found synonym', 0, 1) with nowait;
                            drop synonym deadlockfindings;
                        end
                    set @stringtoexecute =
                                'CREATE SYNONYM DeadlockFindings FOR ' + @outputdatabasename + '.' + @outputschemaname +
                                '.' + @outputtablefindings;
                    exec sp_executesql @stringtoexecute

                    --create synonym for deadlock table.
                    if ((select name from sys.objects where name = 'DeadLockTbl' and type_desc = 'SYNONYM') is not null)
                        begin
                            drop synonym deadlocktbl;
                        end
                    set @stringtoexecute =
                                'CREATE SYNONYM DeadLockTbl FOR ' + @outputdatabasename + '.' + @outputschemaname +
                                '.' + @outputtablename;
                    exec sp_executesql @stringtoexecute

                end
        end


    create table #t
    (
        id int not null
    );

    /* WITH ROWCOUNT doesn't work on Amazon RDS - see: https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/2037 */
    if LEFT(CAST(SERVERPROPERTY('ComputerNamePhysicalNetBIOS') as varchar(8000)), 8) <> 'EC2AMAZ-'
        and LEFT(CAST(SERVERPROPERTY('MachineName') as varchar(8000)), 8) <> 'EC2AMAZ-'
        and LEFT(CAST(SERVERPROPERTY('ServerName') as varchar(8000)), 8) <> 'EC2AMAZ-'
        and db_id('rdsadmin') is null
        begin
            update statistics #t with rowcount = 100000000, pagecount = 100000000;
        end

    /*Grab the initial set of XML to parse*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Grab the initial set of XML to parse at %s', 0, 1, @d) with nowait;
    with xml
             as (select CONVERT(xml, event_data) as deadlock_xml
                 from sys.fn_xe_file_target_read_file(@eventsessionpath, null, null, null))
    select top (@top) ISNULL(xml.deadlock_xml, '') as deadlock_xml
    into #deadlock_data
    from xml
             left join #t as t
                       on 1 = 1
    where xml.deadlock_xml.value('(/event/@name)[1]', 'VARCHAR(256)') = 'xml_deadlock_report'
      and CONVERT(datetime,
                  SWITCHOFFSET(CONVERT(datetimeoffset, xml.deadlock_xml.value('(/event/@timestamp)[1]', 'datetime')),
                               DATENAME(tzoffset, SYSDATETIMEOFFSET()))) > @startdate
      and CONVERT(datetime,
                  SWITCHOFFSET(CONVERT(datetimeoffset, xml.deadlock_xml.value('(/event/@timestamp)[1]', 'datetime')),
                               DATENAME(tzoffset, SYSDATETIMEOFFSET()))) < @enddate
    order by xml.deadlock_xml.value('(/event/@timestamp)[1]', 'datetime') desc
    option ( recompile );


    /*Parse process and input buffer XML*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Parse process and input buffer XML %s', 0, 1, @d) with nowait;
    select q.event_date,
           q.victim_id,
           q.deadlock_graph,
           q.id,
           q.database_id,
           q.priority,
           q.log_used,
           q.wait_resource,
           q.wait_time,
           q.transaction_name,
           q.last_tran_started,
           q.last_batch_started,
           q.last_batch_completed,
           q.lock_mode,
           q.transaction_count,
           q.client_app,
           q.host_name,
           q.login_name,
           q.isolation_level,
           q.process_xml,
           ISNULL(ca2.ib.query('.'), '') as input_buffer
    into #deadlock_process
    from (select dd.deadlock_xml,
                 CONVERT(datetime2(7), SWITCHOFFSET(CONVERT(datetimeoffset, dd.event_date),
                                                    DATENAME(tzoffset, SYSDATETIMEOFFSET()))) as event_date,
                 dd.victim_id,
                 dd.deadlock_graph,
                 ca.dp.value('@id', 'NVARCHAR(256)')                                          as id,
                 ca.dp.value('@currentdb', 'BIGINT')                                          as database_id,
                 ca.dp.value('@priority', 'SMALLINT')                                         as priority,
                 ca.dp.value('@logused', 'BIGINT')                                            as log_used,
                 ca.dp.value('@waitresource', 'NVARCHAR(256)')                                as wait_resource,
                 ca.dp.value('@waittime', 'BIGINT')                                           as wait_time,
                 ca.dp.value('@transactionname', 'NVARCHAR(256)')                             as transaction_name,
                 ca.dp.value('@lasttranstarted', 'DATETIME2(7)')                              as last_tran_started,
                 ca.dp.value('@lastbatchstarted', 'DATETIME2(7)')                             as last_batch_started,
                 ca.dp.value('@lastbatchcompleted', 'DATETIME2(7)')                           as last_batch_completed,
                 ca.dp.value('@lockMode', 'NVARCHAR(256)')                                    as lock_mode,
                 ca.dp.value('@trancount', 'BIGINT')                                          as transaction_count,
                 ca.dp.value('@clientapp', 'NVARCHAR(256)')                                   as client_app,
                 ca.dp.value('@hostname', 'NVARCHAR(256)')                                    as host_name,
                 ca.dp.value('@loginname', 'NVARCHAR(256)')                                   as login_name,
                 ca.dp.value('@isolationlevel', 'NVARCHAR(256)')                              as isolation_level,
                 ISNULL(ca.dp.query('.'), '')                                                 as process_xml
          from (select d1.deadlock_xml,
                       d1.deadlock_xml.value('(event/@timestamp)[1]', 'DATETIME2')                             as event_date,
                       d1.deadlock_xml.value('(//deadlock/victim-list/victimProcess/@id)[1]',
                                             'NVARCHAR(256)')                                                  as victim_id,
                       d1.deadlock_xml.query('/event/data/value/deadlock')                                     as deadlock_graph
                from #deadlock_data as d1) as dd
                   cross apply dd.deadlock_xml.nodes('//deadlock/process-list/process') as ca(dp)
          where (ca.dp.value('@currentdb', 'BIGINT') = DB_ID(@databasename) or @databasename is null)
            and (ca.dp.value('@clientapp', 'NVARCHAR(256)') = @appname or @appname is null)
            and (ca.dp.value('@hostname', 'NVARCHAR(256)') = @hostname or @hostname is null)
            and (ca.dp.value('@loginname', 'NVARCHAR(256)') = @loginname or @loginname is null)
         ) as q
             cross apply q.deadlock_xml.nodes('//deadlock/process-list/process/inputbuf') as ca2(ib)
    option ( recompile );


    /*Parse execution stack XML*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Parse execution stack XML %s', 0, 1, @d) with nowait;
    select distinct dp.id,
                    dp.event_date,
                    ca.dp.value('@procname', 'NVARCHAR(1000)') as proc_name,
                    ca.dp.value('@sqlhandle', 'NVARCHAR(128)') as sql_handle
    into #deadlock_stack
    from #deadlock_process as dp
             cross apply dp.process_xml.nodes('//executionStack/frame') as ca(dp)
    where (ca.dp.value('@procname', 'NVARCHAR(256)') = @storedprocname or @storedprocname is null)
    option ( recompile );


    /*Grab the full resource list*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Grab the full resource list %s', 0, 1, @d) with nowait;
    select dd.deadlock_xml.value('(event/@timestamp)[1]', 'DATETIME2')                             as event_date,
           dd.deadlock_xml.value('(//deadlock/victim-list/victimProcess/@id)[1]', 'NVARCHAR(256)') as victim_id,
           ISNULL(ca.dp.query('.'), '')                                                            as resource_xml
    into #deadlock_resource
    from #deadlock_data as dd
             cross apply dd.deadlock_xml.nodes('//deadlock/resource-list') as ca(dp)
    option ( recompile );


    /*Parse object locks*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Parse object locks %s', 0, 1, @d) with nowait;
    select distinct ca.event_date,
                    ca.database_id,
                    ca.object_name,
                    ca.lock_mode,
                    ca.index_name,
                    w.l.value('@id', 'NVARCHAR(256)')   as waiter_id,
                    w.l.value('@mode', 'NVARCHAR(256)') as waiter_mode,
                    o.l.value('@id', 'NVARCHAR(256)')   as owner_id,
                    o.l.value('@mode', 'NVARCHAR(256)') as owner_mode,
                    N'OBJECT'                           as lock_type
    into #deadlock_owner_waiter
    from (
             select dr.event_date,
                    ca.dr.value('@dbid', 'BIGINT')              as database_id,
                    ca.dr.value('@objectname', 'NVARCHAR(256)') as object_name,
                    ca.dr.value('@mode', 'NVARCHAR(256)')       as lock_mode,
                    ca.dr.value('@indexname', 'NVARCHAR(256)')  as index_name,
                    ca.dr.query('.')                            as dr
             from #deadlock_resource as dr
                      cross apply dr.resource_xml.nodes('//resource-list/objectlock') as ca(dr)
         ) as ca
             cross apply ca.dr.nodes('//waiter-list/waiter') as w(l)
             cross apply ca.dr.nodes('//owner-list/owner') as o(l)
    where (ca.object_name = @objectname or @objectname is null)
    option ( recompile );


    /*Parse page locks*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Parse page locks %s', 0, 1, @d) with nowait;
    insert #deadlock_owner_waiter with (tablockx)
    select distinct ca.event_date,
                    ca.database_id,
                    ca.object_name,
                    ca.lock_mode,
                    ca.index_name,
                    w.l.value('@id', 'NVARCHAR(256)')   as waiter_id,
                    w.l.value('@mode', 'NVARCHAR(256)') as waiter_mode,
                    o.l.value('@id', 'NVARCHAR(256)')   as owner_id,
                    o.l.value('@mode', 'NVARCHAR(256)') as owner_mode,
                    N'PAGE'                             as lock_type
    from (
             select dr.event_date,
                    ca.dr.value('@dbid', 'BIGINT')              as database_id,
                    ca.dr.value('@objectname', 'NVARCHAR(256)') as object_name,
                    ca.dr.value('@mode', 'NVARCHAR(256)')       as lock_mode,
                    ca.dr.value('@indexname', 'NVARCHAR(256)')  as index_name,
                    ca.dr.query('.')                            as dr
             from #deadlock_resource as dr
                      cross apply dr.resource_xml.nodes('//resource-list/pagelock') as ca(dr)
         ) as ca
             cross apply ca.dr.nodes('//waiter-list/waiter') as w(l)
             cross apply ca.dr.nodes('//owner-list/owner') as o(l)
    option ( recompile );


    /*Parse key locks*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Parse key locks %s', 0, 1, @d) with nowait;
    insert #deadlock_owner_waiter with (tablockx)
    select distinct ca.event_date,
                    ca.database_id,
                    ca.object_name,
                    ca.lock_mode,
                    ca.index_name,
                    w.l.value('@id', 'NVARCHAR(256)')   as waiter_id,
                    w.l.value('@mode', 'NVARCHAR(256)') as waiter_mode,
                    o.l.value('@id', 'NVARCHAR(256)')   as owner_id,
                    o.l.value('@mode', 'NVARCHAR(256)') as owner_mode,
                    N'KEY'                              as lock_type
    from (
             select dr.event_date,
                    ca.dr.value('@dbid', 'BIGINT')              as database_id,
                    ca.dr.value('@objectname', 'NVARCHAR(256)') as object_name,
                    ca.dr.value('@mode', 'NVARCHAR(256)')       as lock_mode,
                    ca.dr.value('@indexname', 'NVARCHAR(256)')  as index_name,
                    ca.dr.query('.')                            as dr
             from #deadlock_resource as dr
                      cross apply dr.resource_xml.nodes('//resource-list/keylock') as ca(dr)
         ) as ca
             cross apply ca.dr.nodes('//waiter-list/waiter') as w(l)
             cross apply ca.dr.nodes('//owner-list/owner') as o(l)
    option ( recompile );


    /*Parse RID locks*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Parse RID locks %s', 0, 1, @d) with nowait;
    insert #deadlock_owner_waiter with (tablockx)
    select distinct ca.event_date,
                    ca.database_id,
                    ca.object_name,
                    ca.lock_mode,
                    ca.index_name,
                    w.l.value('@id', 'NVARCHAR(256)')   as waiter_id,
                    w.l.value('@mode', 'NVARCHAR(256)') as waiter_mode,
                    o.l.value('@id', 'NVARCHAR(256)')   as owner_id,
                    o.l.value('@mode', 'NVARCHAR(256)') as owner_mode,
                    N'RID'                              as lock_type
    from (
             select dr.event_date,
                    ca.dr.value('@dbid', 'BIGINT')              as database_id,
                    ca.dr.value('@objectname', 'NVARCHAR(256)') as object_name,
                    ca.dr.value('@mode', 'NVARCHAR(256)')       as lock_mode,
                    ca.dr.value('@indexname', 'NVARCHAR(256)')  as index_name,
                    ca.dr.query('.')                            as dr
             from #deadlock_resource as dr
                      cross apply dr.resource_xml.nodes('//resource-list/ridlock') as ca(dr)
         ) as ca
             cross apply ca.dr.nodes('//waiter-list/waiter') as w(l)
             cross apply ca.dr.nodes('//owner-list/owner') as o(l)
    option ( recompile );


    /*Parse row group locks*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Parse row group locks %s', 0, 1, @d) with nowait;
    insert #deadlock_owner_waiter with (tablockx)
    select distinct ca.event_date,
                    ca.database_id,
                    ca.object_name,
                    ca.lock_mode,
                    ca.index_name,
                    w.l.value('@id', 'NVARCHAR(256)')   as waiter_id,
                    w.l.value('@mode', 'NVARCHAR(256)') as waiter_mode,
                    o.l.value('@id', 'NVARCHAR(256)')   as owner_id,
                    o.l.value('@mode', 'NVARCHAR(256)') as owner_mode,
                    N'ROWGROUP'                         as lock_type
    from (
             select dr.event_date,
                    ca.dr.value('@dbid', 'BIGINT')              as database_id,
                    ca.dr.value('@objectname', 'NVARCHAR(256)') as object_name,
                    ca.dr.value('@mode', 'NVARCHAR(256)')       as lock_mode,
                    ca.dr.value('@indexname', 'NVARCHAR(256)')  as index_name,
                    ca.dr.query('.')                            as dr
             from #deadlock_resource as dr
                      cross apply dr.resource_xml.nodes('//resource-list/rowgrouplock') as ca(dr)
         ) as ca
             cross apply ca.dr.nodes('//waiter-list/waiter') as w(l)
             cross apply ca.dr.nodes('//owner-list/owner') as o(l)
    option ( recompile );

    update d
    set d.index_name = d.object_name
        + '.HEAP'
    from #deadlock_owner_waiter as d
    where lock_type in (N'HEAP', N'RID')
    option (recompile);

    /*Parse parallel deadlocks*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Parse parallel deadlocks %s', 0, 1, @d) with nowait;
    select distinct ca.id,
                    ca.event_date,
                    ca.wait_type,
                    ca.node_id,
                    ca.waiter_type,
                    ca.owner_activity,
                    ca.waiter_activity,
                    ca.merging,
                    ca.spilling,
                    ca.waiting_to_close,
                    w.l.value('@id', 'NVARCHAR(256)') as waiter_id,
                    o.l.value('@id', 'NVARCHAR(256)') as owner_id
    into #deadlock_resource_parallel
    from (
             select dr.event_date,
                    ca.dr.value('@id', 'NVARCHAR(256)')             as id,
                    ca.dr.value('@WaitType', 'NVARCHAR(256)')       as wait_type,
                    ca.dr.value('@nodeId', 'BIGINT')                as node_id,
                 /* These columns are in 2017 CU5 ONLY */
                    ca.dr.value('@waiterType', 'NVARCHAR(256)')     as waiter_type,
                    ca.dr.value('@ownerActivity', 'NVARCHAR(256)')  as owner_activity,
                    ca.dr.value('@waiterActivity', 'NVARCHAR(256)') as waiter_activity,
                    ca.dr.value('@merging', 'NVARCHAR(256)')        as merging,
                    ca.dr.value('@spilling', 'NVARCHAR(256)')       as spilling,
                    ca.dr.value('@waitingToClose', 'NVARCHAR(256)') as waiting_to_close,
                 /*                                    */
                    ca.dr.query('.')                                as dr
             from #deadlock_resource as dr
                      cross apply dr.resource_xml.nodes('//resource-list/exchangeEvent') as ca(dr)
         ) as ca
             cross apply ca.dr.nodes('//waiter-list/waiter') as w(l)
             cross apply ca.dr.nodes('//owner-list/owner') as o(l)
    option ( recompile );


    /*Get rid of parallel noise*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Get rid of parallel noise %s', 0, 1, @d) with nowait;
    with c
             as
             (
                 select *, ROW_NUMBER() over ( partition by drp.owner_id, drp.waiter_id order by drp.event_date ) as rn
                 from #deadlock_resource_parallel as drp
             )
    delete
    from c
    where c.rn > 1
    option ( recompile );


    /*Get rid of nonsense*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Get rid of nonsense %s', 0, 1, @d) with nowait;
    delete dow
    from #deadlock_owner_waiter as dow
    where dow.owner_id = dow.waiter_id
    option ( recompile );

    /*Add some nonsense*/
    alter table #deadlock_process
        add waiter_mode nvarchar(256),
            owner_mode nvarchar(256),
            is_victim as CONVERT(bit, case when id = victim_id then 1 else 0 end);

    /*Update some nonsense*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Update some nonsense part 1 %s', 0, 1, @d) with nowait;
    update dp
    set dp.owner_mode = dow.owner_mode
    from #deadlock_process as dp
             join #deadlock_owner_waiter as dow
                  on dp.id = dow.owner_id
                      and dp.event_date = dow.event_date
    where dp.is_victim = 0
    option ( recompile );

    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Update some nonsense part 2 %s', 0, 1, @d) with nowait;
    update dp
    set dp.waiter_mode = dow.waiter_mode
    from #deadlock_process as dp
             join #deadlock_owner_waiter as dow
                  on dp.victim_id = dow.waiter_id
                      and dp.event_date = dow.event_date
    where dp.is_victim = 1
    option ( recompile );

    /*Get Agent Job and Step names*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Get Agent Job and Step names %s', 0, 1, @d) with nowait;
    select *,
           CONVERT(uniqueidentifier,
                   CONVERT(xml, '').value('xs:hexBinary(substring(sql:column("x.job_id"), 0) )', 'BINARY(16)')
               ) as job_id_guid
    into #agent_job
    from (
             select dp.event_date,
                    dp.victim_id,
                    dp.id,
                    dp.database_id,
                    dp.client_app,
                    SUBSTRING(dp.client_app,
                              CHARINDEX('0x', dp.client_app) + LEN('0x'),
                              32
                        ) as job_id,
                    SUBSTRING(dp.client_app,
                              CHARINDEX(': Step ', dp.client_app) + LEN(': Step '),
                              CHARINDEX(')', dp.client_app, CHARINDEX(': Step ', dp.client_app))
                                  - (CHARINDEX(': Step ', dp.client_app)
                                  + LEN(': Step '))
                        ) as step_id
             from #deadlock_process as dp
             where dp.client_app like 'SQLAgent - %'
         ) as x
    option ( recompile );


    alter table #agent_job
        add job_name nvarchar(256),
            step_name nvarchar(256);

    if SERVERPROPERTY('EngineEdition') not in (5, 6) /* Azure SQL DB doesn't support querying jobs */
        and not (LEFT(CAST(SERVERPROPERTY('ComputerNamePhysicalNetBIOS') as varchar(8000)), 8) =
                 'EC2AMAZ-' /* Neither does Amazon RDS Express Edition */
            and LEFT(CAST(SERVERPROPERTY('MachineName') as varchar(8000)), 8) = 'EC2AMAZ-'
            and LEFT(CAST(SERVERPROPERTY('ServerName') as varchar(8000)), 8) = 'EC2AMAZ-'
            and db_id('rdsadmin') is not null
            and EXISTS(select *
                       from master.sys.all_objects
                       where name in
                             ('rds_startup_tasks', 'rds_help_revlogin', 'rds_hexadecimal', 'rds_failover_tracking',
                              'rds_database_tracking', 'rds_track_change'))
            )
        begin
            set @stringtoexecute = N'UPDATE aj
                    SET  aj.job_name = j.name,
                         aj.step_name = s.step_name
		            FROM msdb.dbo.sysjobs AS j
		            JOIN msdb.dbo.sysjobsteps AS s
                        ON j.job_id = s.job_id
                    JOIN #agent_job AS aj
                        ON  aj.job_id_guid = j.job_id
                        AND aj.step_id = s.step_id
						OPTION ( RECOMPILE );';
            exec (@stringtoexecute);
        end

    update dp
    set dp.client_app =
            case
                when dp.client_app like N'SQLAgent - %'
                    then N'SQLAgent - Job: '
                    + aj.job_name
                    + N' Step: '
                    + aj.step_name
                else dp.client_app
                end
    from #deadlock_process as dp
             join #agent_job as aj
                  on dp.event_date = aj.event_date
                      and dp.victim_id = aj.victim_id
                      and dp.id = aj.id
    option ( recompile );

    /*Begin checks based on parsed values*/

    /*Check 1 is deadlocks by database*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 1 %s', 0, 1, @d) with nowait;
    insert #deadlock_findings with (tablockx)
        (check_id, database_name, object_name, finding_group, finding)
    select 1                       as check_id,
           DB_NAME(dp.database_id) as database_name,
           '-'                     as object_name,
           'Total database locks'  as finding_group,
           'This database had '
               + CONVERT(nvarchar(20), COUNT_BIG(distinct dp.event_date))
               + ' deadlocks.'
    from #deadlock_process as dp
    where 1 = 1
      and (DB_NAME(dp.database_id) = @databasename or @databasename is null)
      and (dp.event_date >= @startdate or @startdate is null)
      and (dp.event_date < @enddate or @enddate is null)
      and (dp.client_app = @appname or @appname is null)
      and (dp.host_name = @hostname or @hostname is null)
      and (dp.login_name = @loginname or @loginname is null)
    group by DB_NAME(dp.database_id)
    option ( recompile );

    /*Check 2 is deadlocks by object*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 2 objects %s', 0, 1, @d) with nowait;
    insert #deadlock_findings with (tablockx)
        (check_id, database_name, object_name, finding_group, finding)
    select 2                                           as check_id,
           ISNULL(DB_NAME(dow.database_id), 'UNKNOWN') as database_name,
           ISNULL(dow.object_name, 'UNKNOWN')          as object_name,
           'Total object deadlocks'                    as finding_group,
           'This object was involved in '
               + CONVERT(nvarchar(20), COUNT_BIG(distinct dow.event_date))
               + ' deadlock(s).'
    from #deadlock_owner_waiter as dow
    where 1 = 1
      and (DB_NAME(dow.database_id) = @databasename or @databasename is null)
      and (dow.event_date >= @startdate or @startdate is null)
      and (dow.event_date < @enddate or @enddate is null)
      and (dow.object_name = @objectname or @objectname is null)
    group by DB_NAME(dow.database_id), dow.object_name
    option ( recompile );

    /*Check 2 continuation, number of locks per index*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 2 indexes %s', 0, 1, @d) with nowait;
    insert #deadlock_findings with (tablockx)
        (check_id, database_name, object_name, finding_group, finding)
    select 2                                           as check_id,
           ISNULL(DB_NAME(dow.database_id), 'UNKNOWN') as database_name,
           dow.index_name                              as index_name,
           'Total index deadlocks'                     as finding_group,
           'This index was involved in '
               + CONVERT(nvarchar(20), COUNT_BIG(distinct dow.event_date))
               + ' deadlock(s).'
    from #deadlock_owner_waiter as dow
    where 1 = 1
      and (DB_NAME(dow.database_id) = @databasename or @databasename is null)
      and (dow.event_date >= @startdate or @startdate is null)
      and (dow.event_date < @enddate or @enddate is null)
      and (dow.object_name = @objectname or @objectname is null)
      and dow.lock_type not in (N'HEAP', N'RID')
    group by DB_NAME(dow.database_id), dow.index_name
    option ( recompile );


    /*Check 2 continuation, number of locks per heap*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 2 heaps %s', 0, 1, @d) with nowait;
    insert #deadlock_findings with (tablockx)
        (check_id, database_name, object_name, finding_group, finding)
    select 2                                           as check_id,
           ISNULL(DB_NAME(dow.database_id), 'UNKNOWN') as database_name,
           dow.index_name                              as index_name,
           'Total heap deadlocks'                      as finding_group,
           'This heap was involved in '
               + CONVERT(nvarchar(20), COUNT_BIG(distinct dow.event_date))
               + ' deadlock(s).'
    from #deadlock_owner_waiter as dow
    where 1 = 1
      and (DB_NAME(dow.database_id) = @databasename or @databasename is null)
      and (dow.event_date >= @startdate or @startdate is null)
      and (dow.event_date < @enddate or @enddate is null)
      and (dow.object_name = @objectname or @objectname is null)
      and dow.lock_type in (N'HEAP', N'RID')
    group by DB_NAME(dow.database_id), dow.index_name
    option ( recompile );


    /*Check 3 looks for Serializable locking*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 3 %s', 0, 1, @d) with nowait;
    insert #deadlock_findings with (tablockx)
        (check_id, database_name, object_name, finding_group, finding)
    select 3                       as check_id,
           DB_NAME(dp.database_id) as database_name,
           '-'                     as object_name,
           'Serializable locking'  as finding_group,
           'This database has had ' +
           CONVERT(nvarchar(20), COUNT_BIG(*)) +
           ' instances of serializable deadlocks.'
                                   as finding
    from #deadlock_process as dp
    where dp.isolation_level like 'serializable%'
      and (DB_NAME(dp.database_id) = @databasename or @databasename is null)
      and (dp.event_date >= @startdate or @startdate is null)
      and (dp.event_date < @enddate or @enddate is null)
      and (dp.client_app = @appname or @appname is null)
      and (dp.host_name = @hostname or @hostname is null)
      and (dp.login_name = @loginname or @loginname is null)
    group by DB_NAME(dp.database_id)
    option ( recompile );


    /*Check 4 looks for Repeatable Read locking*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 4 %s', 0, 1, @d) with nowait;
    insert #deadlock_findings with (tablockx)
        (check_id, database_name, object_name, finding_group, finding)
    select 4                         as check_id,
           DB_NAME(dp.database_id)   as database_name,
           '-'                       as object_name,
           'Repeatable Read locking' as finding_group,
           'This database has had ' +
           CONVERT(nvarchar(20), COUNT_BIG(*)) +
           ' instances of repeatable read deadlocks.'
                                     as finding
    from #deadlock_process as dp
    where dp.isolation_level like 'repeatable read%'
      and (DB_NAME(dp.database_id) = @databasename or @databasename is null)
      and (dp.event_date >= @startdate or @startdate is null)
      and (dp.event_date < @enddate or @enddate is null)
      and (dp.client_app = @appname or @appname is null)
      and (dp.host_name = @hostname or @hostname is null)
      and (dp.login_name = @loginname or @loginname is null)
    group by DB_NAME(dp.database_id)
    option ( recompile );


    /*Check 5 breaks down app, host, and login information*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 5 %s', 0, 1, @d) with nowait;
    insert #deadlock_findings with (tablockx)
        (check_id, database_name, object_name, finding_group, finding)
    select 5                              as check_id,
           DB_NAME(dp.database_id)        as database_name,
           '-'                            as object_name,
           'Login, App, and Host locking' as finding_group,
           'This database has had ' +
           CONVERT(nvarchar(20), COUNT_BIG(distinct dp.event_date)) +
           ' instances of deadlocks involving the login ' +
           ISNULL(dp.login_name, 'UNKNOWN') +
           ' from the application ' +
           ISNULL(dp.client_app, 'UNKNOWN') +
           ' on host ' +
           ISNULL(dp.host_name, 'UNKNOWN')
                                          as finding
    from #deadlock_process as dp
    where 1 = 1
      and (DB_NAME(dp.database_id) = @databasename or @databasename is null)
      and (dp.event_date >= @startdate or @startdate is null)
      and (dp.event_date < @enddate or @enddate is null)
      and (dp.client_app = @appname or @appname is null)
      and (dp.host_name = @hostname or @hostname is null)
      and (dp.login_name = @loginname or @loginname is null)
    group by DB_NAME(dp.database_id), dp.login_name, dp.client_app, dp.host_name
    option ( recompile );


    /*Check 6 breaks down the types of locks (object, page, key, etc.)*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 6 %s', 0, 1, @d) with nowait;
    with lock_types as (
        select DB_NAME(dp.database_id)                                              as database_name,
               dow.object_name,
               SUBSTRING(dp.wait_resource, 1, CHARINDEX(':', dp.wait_resource) - 1) as lock,
               CONVERT(nvarchar(20), COUNT_BIG(distinct dp.id))                     as lock_count
        from #deadlock_process as dp
                 join #deadlock_owner_waiter as dow
                      on dp.id = dow.owner_id
                          and dp.event_date = dow.event_date
        where 1 = 1
          and (DB_NAME(dp.database_id) = @databasename or @databasename is null)
          and (dp.event_date >= @startdate or @startdate is null)
          and (dp.event_date < @enddate or @enddate is null)
          and (dp.client_app = @appname or @appname is null)
          and (dp.host_name = @hostname or @hostname is null)
          and (dp.login_name = @loginname or @loginname is null)
          and (dow.object_name = @objectname or @objectname is null)
          and dow.object_name is not null
        group by DB_NAME(dp.database_id), SUBSTRING(dp.wait_resource, 1, CHARINDEX(':', dp.wait_resource) - 1),
                 dow.object_name
    )
    insert
    #deadlock_findings
    with (tablockx)
    (
    check_id
    ,
    database_name
    ,
    object_name
    ,
    finding_group
    ,
    finding
    )
    select distinct 6                          as check_id,
                    lt.database_name,
                    lt.object_name,
                    'Types of locks by object' as finding_group,
                    'This object has had ' +
                    STUFF((select distinct N', ' + lt2.lock_count + ' ' + lt2.lock
                           from lock_types as lt2
                           where lt2.database_name = lt.database_name
                             and lt2.object_name = lt.object_name
                           for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 1, N'')
                        + ' locks'
    from lock_types as lt
    option ( recompile );


    /*Check 7 gives you more info queries for sp_BlitzCache & BlitzQueryStore*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 7 part 1 %s', 0, 1, @d) with nowait;
    with deadlock_stack as (
        select distinct ds.id,
                        ds.proc_name,
                        ds.event_date,
                        PARSENAME(ds.proc_name, 3)                                                                 as database_name,
                        PARSENAME(ds.proc_name, 2)                                                                 as schema_name,
                        PARSENAME(ds.proc_name, 1)                                                                 as proc_only_name,
                        '''' + STUFF((select distinct N',' + ds2.sql_handle
                                      from #deadlock_stack as ds2
                                      where ds2.id = ds.id
                                        and ds2.event_date = ds.event_date
                                      for xml path(N''), type).value(N'.[1]', N'NVARCHAR(MAX)'), 1, 1, N'') +
                        ''''                                                                                       as sql_handle_csv
        from #deadlock_stack as ds
        group by PARSENAME(ds.proc_name, 3),
                 PARSENAME(ds.proc_name, 2),
                 PARSENAME(ds.proc_name, 1),
                 ds.id,
                 ds.proc_name,
                 ds.event_date
    )
    insert
    #deadlock_findings
    with (tablockx)
    (
    check_id
    ,
    database_name
    ,
    object_name
    ,
    finding_group
    ,
    finding
    )
    select distinct 7                                           as check_id,
                    ISNULL(DB_NAME(dow.database_id), 'UNKNOWN') as database_name,
                    ds.proc_name                                as object_name,
                    'More Info - Query'                         as finding_group,
                    'EXEC sp_BlitzCache ' +
                    case
                        when ds.proc_name = 'adhoc'
                            then ' @OnlySqlHandles = ' + ds.sql_handle_csv
                        else '@StoredProcName = ' +
                             QUOTENAME(ds.proc_only_name, '''')
                        end +
                    ';'                                         as finding
    from deadlock_stack as ds
             join #deadlock_owner_waiter as dow
                  on dow.owner_id = ds.id
                      and dow.event_date = ds.event_date
    where 1 = 1
      and (DB_NAME(dow.database_id) = @databasename or @databasename is null)
      and (dow.event_date >= @startdate or @startdate is null)
      and (dow.event_date < @enddate or @enddate is null)
      and (dow.object_name = @storedprocname or @storedprocname is null)
    option ( recompile );

    if @productversionmajor >= 13
        begin
            set @d = CONVERT(varchar(40), GETDATE(), 109);
            raiserror ('Check 7 part 2 %s', 0, 1, @d) with nowait;
            with deadlock_stack as (
                select distinct ds.id,
                                ds.sql_handle,
                                ds.proc_name,
                                ds.event_date,
                                PARSENAME(ds.proc_name, 3) as database_name,
                                PARSENAME(ds.proc_name, 2) as schema_name,
                                PARSENAME(ds.proc_name, 1) as proc_only_name
                from #deadlock_stack as ds
            )
            insert
            #deadlock_findings
            with (tablockx)
            (
            check_id
            ,
            database_name
            ,
            object_name
            ,
            finding_group
            ,
            finding
            )
            select distinct 7                        as check_id,
                            DB_NAME(dow.database_id) as database_name,
                            ds.proc_name             as object_name,
                            'More Info - Query'      as finding_group,
                            'EXEC sp_BlitzQueryStore '
                                + '@DatabaseName = '
                                + QUOTENAME(ds.database_name, '''')
                                + ', '
                                + '@StoredProcName = '
                                + QUOTENAME(ds.proc_only_name, '''')
                                + ';'                as finding
            from deadlock_stack as ds
                     join #deadlock_owner_waiter as dow
                          on dow.owner_id = ds.id
                              and dow.event_date = ds.event_date
            where ds.proc_name <> 'adhoc'
              and (DB_NAME(dow.database_id) = @databasename or @databasename is null)
              and (dow.event_date >= @startdate or @startdate is null)
              and (dow.event_date < @enddate or @enddate is null)
              and (dow.object_name = @storedprocname or @storedprocname is null)
            option ( recompile );
        end;


    /*Check 8 gives you stored proc deadlock counts*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 8 %s', 0, 1, @d) with nowait;
    insert #deadlock_findings with (tablockx)
        (check_id, database_name, object_name, finding_group, finding)
    select 8                       as check_id,
           DB_NAME(dp.database_id) as database_name,
           ds.proc_name,
           'Stored Procedure Deadlocks',
           'The stored procedure '
               + PARSENAME(ds.proc_name, 2)
               + '.'
               + PARSENAME(ds.proc_name, 1)
               + ' has been involved in '
               + CONVERT(nvarchar(10), COUNT_BIG(distinct ds.id))
               + ' deadlocks.'
    from #deadlock_stack as ds
             join #deadlock_process as dp
                  on dp.id = ds.id
                      and ds.event_date = dp.event_date
    where ds.proc_name <> 'adhoc'
      and (ds.proc_name = @storedprocname or @storedprocname is null)
      and (DB_NAME(dp.database_id) = @databasename or @databasename is null)
      and (dp.event_date >= @startdate or @startdate is null)
      and (dp.event_date < @enddate or @enddate is null)
      and (dp.client_app = @appname or @appname is null)
      and (dp.host_name = @hostname or @hostname is null)
      and (dp.login_name = @loginname or @loginname is null)
    group by DB_NAME(dp.database_id), ds.proc_name
    option (recompile);


    /*Check 9 gives you more info queries for sp_BlitzIndex */
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 9 %s', 0, 1, @d) with nowait;
    with bi as (
        select distinct dow.object_name,
                        PARSENAME(dow.object_name, 3) as database_name,
                        PARSENAME(dow.object_name, 2) as schema_name,
                        PARSENAME(dow.object_name, 1) as table_name
        from #deadlock_owner_waiter as dow
        where 1 = 1
          and (DB_NAME(dow.database_id) = @databasename or @databasename is null)
          and (dow.event_date >= @startdate or @startdate is null)
          and (dow.event_date < @enddate or @enddate is null)
          and (dow.object_name = @objectname or @objectname is null)
          and dow.object_name is not null
    )
    insert
    #deadlock_findings
    with (tablockx)
    (
    check_id
    ,
    database_name
    ,
    object_name
    ,
    finding_group
    ,
    finding
    )
    select 9                   as check_id,
           bi.database_name,
           bi.schema_name + '.' + bi.table_name,
           'More Info - Table' as finding_group,
           'EXEC sp_BlitzIndex ' +
           '@DatabaseName = ' + QUOTENAME(bi.database_name, '''') +
           ', @SchemaName = ' + QUOTENAME(bi.schema_name, '''') +
           ', @TableName = ' + QUOTENAME(bi.table_name, '''') +
           ';'                 as finding
    from bi
    option ( recompile );

    /*Check 10 gets total deadlock wait time per object*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 10 %s', 0, 1, @d) with nowait;
    with chopsuey as (
        select distinct PARSENAME(dow.object_name, 3)                                                      as database_name,
                        dow.object_name,
                        CONVERT(varchar(10), (SUM(distinct dp.wait_time) / 1000) / 86400)                  as wait_days,
                        CONVERT(varchar(20), DATEADD(second, (SUM(distinct dp.wait_time) / 1000), 0),
                                             108)                                                          as wait_time_hms
        from #deadlock_owner_waiter as dow
                 join #deadlock_process as dp
                      on (dp.id = dow.owner_id or dp.victim_id = dow.waiter_id)
                          and dp.event_date = dow.event_date
        where 1 = 1
          and (DB_NAME(dow.database_id) = @databasename or @databasename is null)
          and (dow.event_date >= @startdate or @startdate is null)
          and (dow.event_date < @enddate or @enddate is null)
          and (dow.object_name = @objectname or @objectname is null)
          and (dp.client_app = @appname or @appname is null)
          and (dp.host_name = @hostname or @hostname is null)
          and (dp.login_name = @loginname or @loginname is null)
        group by PARSENAME(dow.object_name, 3), dow.object_name
    )
    insert
    #deadlock_findings
    with (tablockx)
    (
    check_id
    ,
    database_name
    ,
    object_name
    ,
    finding_group
    ,
    finding
    )
    select 10                                        as check_id,
           cs.database_name,
           cs.object_name,
           'Total object deadlock wait time'         as finding_group,
           'This object has had '
               + CONVERT(varchar(10), cs.wait_days)
               + ':' + CONVERT(varchar(20), cs.wait_time_hms, 108)
               + ' [d/h/m/s] of deadlock wait time.' as finding
    from chopsuey as cs
    where cs.object_name is not null
    option ( recompile );

    /*Check 11 gets total deadlock wait time per database*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 11 %s', 0, 1, @d) with nowait;
    with wait_time as (
        select DB_NAME(dp.database_id)            as database_name,
               SUM(CONVERT(bigint, dp.wait_time)) as total_wait_time_ms
        from #deadlock_process as dp
        where 1 = 1
          and (DB_NAME(dp.database_id) = @databasename or @databasename is null)
          and (dp.event_date >= @startdate or @startdate is null)
          and (dp.event_date < @enddate or @enddate is null)
          and (dp.client_app = @appname or @appname is null)
          and (dp.host_name = @hostname or @hostname is null)
          and (dp.login_name = @loginname or @loginname is null)
        group by DB_NAME(dp.database_id)
    )
    insert
    #deadlock_findings
    with (tablockx)
    (
    check_id
    ,
    database_name
    ,
    object_name
    ,
    finding_group
    ,
    finding
    )
    select 11                                  as check_id,
           wt.database_name,
           '-'                                 as object_name,
           'Total database deadlock wait time' as finding_group,
           'This database has had '
               + CONVERT(varchar(10), (SUM(distinct wt.total_wait_time_ms) / 1000) / 86400)
               + ':' + CONVERT(varchar(20), DATEADD(second, (SUM(distinct wt.total_wait_time_ms) / 1000), 0), 108)
               + ' [d/h/m/s] of deadlock wait time.'
    from wait_time as wt
    group by wt.database_name
    option ( recompile );

    /*Check 12 gets total deadlock wait time for SQL Agent*/
    set @d = CONVERT(varchar(40), GETDATE(), 109);
    raiserror ('Check 12 %s', 0, 1, @d) with nowait;
    insert #deadlock_findings with (tablockx)
        (check_id, database_name, object_name, finding_group, finding)
    select 12,
           DB_NAME(aj.database_id),
           'SQLAgent - Job: '
               + aj.job_name
               + ' Step: '
               + aj.step_name,
           'Agent Job Deadlocks',
           RTRIM(COUNT(*)) + ' deadlocks from this Agent Job and Step'
    from #agent_job as aj
    group by DB_NAME(aj.database_id), aj.job_name, aj.step_name
    option ( recompile );

    /*Thank you goodnight*/
    insert #deadlock_findings with (tablockx)
        (check_id, database_name, object_name, finding_group, finding)
    values (-1,
            N'sp_BlitzLock ' + CAST(CONVERT(datetime, @versiondate, 102) as varchar(100)),
            N'SQL Server First Responder Kit',
            N'http://FirstResponderKit.org/',
            N'To get help or add your own contributions, join us at http://FirstResponderKit.org.');


    /*Results*/
    /*Break in case of emergency*/
    --CREATE CLUSTERED INDEX cx_whatever ON #deadlock_process (event_date, id);
    --CREATE CLUSTERED INDEX cx_whatever ON #deadlock_resource_parallel (event_date, owner_id);
    --CREATE CLUSTERED INDEX cx_whatever ON #deadlock_owner_waiter (event_date, owner_id, waiter_id);
    if (@outputdatabasecheck = 0)
        begin

            set @d = CONVERT(varchar(40), GETDATE(), 109);
            raiserror ('Results 1 %s', 0, 1, @d) with nowait;
            with deadlocks
                     as (select N'Regular Deadlock'                                                            as deadlock_type,
                                dp.event_date,
                                dp.id,
                                dp.victim_id,
                                dp.database_id,
                                dp.priority,
                                dp.log_used,
                                dp.wait_resource collate database_default                                      as wait_resource,
                                CONVERT(
                                    xml,
                                        STUFF((select distinct NCHAR(10)
                                                                   + N' <object>'
                                                                   + ISNULL(c.object_name, N'')
                                                                   +
                                                               N'</object> ' collate database_default as object_name
                                               from #deadlock_owner_waiter as c
                                               where (dp.id = c.owner_id
                                                   or dp.victim_id = c.waiter_id)
                                                 and CONVERT(date, dp.event_date) = CONVERT(date, c.event_date)
                                               for xml path(N''), type).value(N'.[1]', N'NVARCHAR(4000)'),
                                              1, 1,
                                              N''))                                                            as object_names,
                                dp.wait_time,
                                dp.transaction_name,
                                dp.last_tran_started,
                                dp.last_batch_started,
                                dp.last_batch_completed,
                                dp.lock_mode,
                                dp.transaction_count,
                                dp.client_app,
                                dp.host_name,
                                dp.login_name,
                                dp.isolation_level,
                                dp.process_xml.value('(//process/inputbuf/text())[1]',
                                                     'NVARCHAR(MAX)')                                          as inputbuf,
                                ROW_NUMBER() over ( partition by dp.event_date, dp.id order by dp.event_date ) as dn,
                                DENSE_RANK() over ( order by dp.event_date )                                   as en,
                                ROW_NUMBER() over ( partition by dp.event_date order by dp.event_date ) - 1    as qn,
                                dp.is_victim,
                                ISNULL(dp.owner_mode, '-')                                                     as owner_mode,
                                null                                                                           as owner_waiter_type,
                                null                                                                           as owner_activity,
                                null                                                                           as owner_waiter_activity,
                                null                                                                           as owner_merging,
                                null                                                                           as owner_spilling,
                                null                                                                           as owner_waiting_to_close,
                                ISNULL(dp.waiter_mode, '-')                                                    as waiter_mode,
                                null                                                                           as waiter_waiter_type,
                                null                                                                           as waiter_owner_activity,
                                null                                                                           as waiter_waiter_activity,
                                null                                                                           as waiter_merging,
                                null                                                                           as waiter_spilling,
                                null                                                                           as waiter_waiting_to_close,
                                dp.deadlock_graph
                         from #deadlock_process as dp
                         where dp.victim_id is not null

                         union all

                         select N'Parallel Deadlock'                                                           as deadlock_type,
                                dp.event_date,
                                dp.id,
                                dp.victim_id,
                                dp.database_id,
                                dp.priority,
                                dp.log_used,
                                dp.wait_resource collate database_default,
                                CONVERT(xml, N'parallel_deadlock' collate database_default)                    as object_names,
                                dp.wait_time,
                                dp.transaction_name,
                                dp.last_tran_started,
                                dp.last_batch_started,
                                dp.last_batch_completed,
                                dp.lock_mode,
                                dp.transaction_count,
                                dp.client_app,
                                dp.host_name,
                                dp.login_name,
                                dp.isolation_level,
                                dp.process_xml.value('(//process/inputbuf/text())[1]',
                                                     'NVARCHAR(MAX)')                                          as inputbuf,
                                ROW_NUMBER() over ( partition by dp.event_date, dp.id order by dp.event_date ) as dn,
                                DENSE_RANK() over ( order by dp.event_date )                                   as en,
                                ROW_NUMBER() over ( partition by dp.event_date order by dp.event_date ) - 1    as qn,
                                1                                                                              as is_victim,
                                cao.wait_type collate database_default                                         as owner_mode,
                                cao.waiter_type                                                                as owner_waiter_type,
                                cao.owner_activity                                                             as owner_activity,
                                cao.waiter_activity                                                            as owner_waiter_activity,
                                cao.merging                                                                    as owner_merging,
                                cao.spilling                                                                   as owner_spilling,
                                cao.waiting_to_close                                                           as owner_waiting_to_close,
                                caw.wait_type collate database_default                                         as waiter_mode,
                                caw.waiter_type                                                                as waiter_waiter_type,
                                caw.owner_activity                                                             as waiter_owner_activity,
                                caw.waiter_activity                                                            as waiter_waiter_activity,
                                caw.merging                                                                    as waiter_merging,
                                caw.spilling                                                                   as waiter_spilling,
                                caw.waiting_to_close                                                           as waiter_waiting_to_close,
                                dp.deadlock_graph
                         from #deadlock_process as dp
                                  cross apply (select top 1 *
                                               from #deadlock_resource_parallel as drp
                                               where drp.owner_id = dp.id
                                                 and drp.wait_type = 'e_waitPipeNewRow'
                                               order by drp.event_date) as cao
                                  cross apply (select top 1 *
                                               from #deadlock_resource_parallel as drp
                                               where drp.owner_id = dp.id
                                                 and drp.wait_type = 'e_waitPipeGetRow'
                                               order by drp.event_date) as caw
                         where dp.victim_id is null
                           and dp.login_name is not null)
            insert
            into deadlocktbl (servername,
                              deadlock_type,
                              event_date,
                              database_name,
                              deadlock_group,
                              query,
                              object_names,
                              isolation_level,
                              owner_mode,
                              waiter_mode,
                              transaction_count,
                              login_name,
                              host_name,
                              client_app,
                              wait_time,
                              priority,
                              log_used,
                              last_tran_started,
                              last_batch_started,
                              last_batch_completed,
                              transaction_name,
                              owner_waiter_type,
                              owner_activity,
                              owner_waiter_activity,
                              owner_merging,
                              owner_spilling,
                              owner_waiting_to_close,
                              waiter_waiter_type,
                              waiter_owner_activity,
                              waiter_waiter_activity,
                              waiter_merging,
                              waiter_spilling,
                              waiter_waiting_to_close,
                              deadlock_graph)
            select @servername,
                   d.deadlock_type,
                   d.event_date,
                   DB_NAME(d.database_id)                                                as database_name,
                   'Deadlock #'
                       + CONVERT(nvarchar(10), d.en)
                       + ', Query #'
                       + case when d.qn = 0 then N'1' else CONVERT(nvarchar(10), d.qn) end
                       + case when d.is_victim = 1 then ' - VICTIM' else '' end
                                                                                         as deadlock_group,
                   CONVERT(xml, N'<inputbuf><![CDATA[' + d.inputbuf + N']]></inputbuf>') as query,
                   d.object_names,
                   d.isolation_level,
                   d.owner_mode,
                   d.waiter_mode,
                   d.transaction_count,
                   d.login_name,
                   d.host_name,
                   d.client_app,
                   d.wait_time,
                   d.priority,
                   d.log_used,
                   d.last_tran_started,
                   d.last_batch_started,
                   d.last_batch_completed,
                   d.transaction_name,
                /*These columns will be NULL for regular (non-parallel) deadlocks*/
                   d.owner_waiter_type,
                   d.owner_activity,
                   d.owner_waiter_activity,
                   d.owner_merging,
                   d.owner_spilling,
                   d.owner_waiting_to_close,
                   d.waiter_waiter_type,
                   d.waiter_owner_activity,
                   d.waiter_waiter_activity,
                   d.waiter_merging,
                   d.waiter_spilling,
                   d.waiter_waiting_to_close,
                   d.deadlock_graph
            from deadlocks as d
            where d.dn = 1
              and (is_victim = @victimsonly or @victimsonly = 0)
              and d.en < case when d.deadlock_type = N'Parallel Deadlock' then 2 else 2147483647 end
              and (DB_NAME(d.database_id) = @databasename or @databasename is null)
              and (d.event_date >= @startdate or @startdate is null)
              and (d.event_date < @enddate or @enddate is null)
              and (CONVERT(nvarchar(max), d.object_names) like '%' + @objectname + '%' or @objectname is null)
              and (d.client_app = @appname or @appname is null)
              and (d.host_name = @hostname or @hostname is null)
              and (d.login_name = @loginname or @loginname is null)
            order by d.event_date, is_victim desc
            option ( recompile );

            drop synonym deadlocktbl;
            --done insert into blitzlock table going to insert into findings table first create synonym.

            --	RAISERROR('att deadlock findings', 0, 1) WITH NOWAIT;


            set @d = CONVERT(varchar(40), GETDATE(), 109);
            raiserror ('Findings %s', 0, 1, @d) with nowait;

            insert into deadlockfindings (servername, check_id, database_name, object_name, finding_group, finding)
            select @servername, df.check_id, df.database_name, df.object_name, df.finding_group, df.finding
            from #deadlock_findings as df
            order by df.check_id
            option ( recompile );

            drop synonym deadlockfindings; --done with inserting.
        end
    else --Output to database is not set output to client app
        begin
            set @d = CONVERT(varchar(40), GETDATE(), 109);
            raiserror ('Results 1 %s', 0, 1, @d) with nowait;
            with deadlocks
                     as (select N'Regular Deadlock'                                                            as deadlock_type,
                                dp.event_date,
                                dp.id,
                                dp.victim_id,
                                dp.database_id,
                                dp.priority,
                                dp.log_used,
                                dp.wait_resource collate database_default                                      as wait_resource,
                                CONVERT(
                                    xml,
                                        STUFF((select distinct NCHAR(10)
                                                                   + N' <object>'
                                                                   + ISNULL(c.object_name, N'')
                                                                   +
                                                               N'</object> ' collate database_default as object_name
                                               from #deadlock_owner_waiter as c
                                               where (dp.id = c.owner_id
                                                   or dp.victim_id = c.waiter_id)
                                                 and CONVERT(date, dp.event_date) = CONVERT(date, c.event_date)
                                               for xml path(N''), type).value(N'.[1]', N'NVARCHAR(4000)'),
                                              1, 1,
                                              N''))                                                            as object_names,
                                dp.wait_time,
                                dp.transaction_name,
                                dp.last_tran_started,
                                dp.last_batch_started,
                                dp.last_batch_completed,
                                dp.lock_mode,
                                dp.transaction_count,
                                dp.client_app,
                                dp.host_name,
                                dp.login_name,
                                dp.isolation_level,
                                dp.process_xml.value('(//process/inputbuf/text())[1]',
                                                     'NVARCHAR(MAX)')                                          as inputbuf,
                                ROW_NUMBER() over ( partition by dp.event_date, dp.id order by dp.event_date ) as dn,
                                DENSE_RANK() over ( order by dp.event_date )                                   as en,
                                ROW_NUMBER() over ( partition by dp.event_date order by dp.event_date ) - 1    as qn,
                                dp.is_victim,
                                ISNULL(dp.owner_mode, '-')                                                     as owner_mode,
                                null                                                                           as owner_waiter_type,
                                null                                                                           as owner_activity,
                                null                                                                           as owner_waiter_activity,
                                null                                                                           as owner_merging,
                                null                                                                           as owner_spilling,
                                null                                                                           as owner_waiting_to_close,
                                ISNULL(dp.waiter_mode, '-')                                                    as waiter_mode,
                                null                                                                           as waiter_waiter_type,
                                null                                                                           as waiter_owner_activity,
                                null                                                                           as waiter_waiter_activity,
                                null                                                                           as waiter_merging,
                                null                                                                           as waiter_spilling,
                                null                                                                           as waiter_waiting_to_close,
                                dp.deadlock_graph
                         from #deadlock_process as dp
                         where dp.victim_id is not null

                         union all

                         select N'Parallel Deadlock'                                                           as deadlock_type,
                                dp.event_date,
                                dp.id,
                                dp.victim_id,
                                dp.database_id,
                                dp.priority,
                                dp.log_used,
                                dp.wait_resource collate database_default,
                                CONVERT(xml, N'parallel_deadlock' collate database_default)                    as object_names,
                                dp.wait_time,
                                dp.transaction_name,
                                dp.last_tran_started,
                                dp.last_batch_started,
                                dp.last_batch_completed,
                                dp.lock_mode,
                                dp.transaction_count,
                                dp.client_app,
                                dp.host_name,
                                dp.login_name,
                                dp.isolation_level,
                                dp.process_xml.value('(//process/inputbuf/text())[1]',
                                                     'NVARCHAR(MAX)')                                          as inputbuf,
                                ROW_NUMBER() over ( partition by dp.event_date, dp.id order by dp.event_date ) as dn,
                                DENSE_RANK() over ( order by dp.event_date )                                   as en,
                                ROW_NUMBER() over ( partition by dp.event_date order by dp.event_date ) - 1    as qn,
                                1                                                                              as is_victim,
                                cao.wait_type collate database_default                                         as owner_mode,
                                cao.waiter_type                                                                as owner_waiter_type,
                                cao.owner_activity                                                             as owner_activity,
                                cao.waiter_activity                                                            as owner_waiter_activity,
                                cao.merging                                                                    as owner_merging,
                                cao.spilling                                                                   as owner_spilling,
                                cao.waiting_to_close                                                           as owner_waiting_to_close,
                                caw.wait_type collate database_default                                         as waiter_mode,
                                caw.waiter_type                                                                as waiter_waiter_type,
                                caw.owner_activity                                                             as waiter_owner_activity,
                                caw.waiter_activity                                                            as waiter_waiter_activity,
                                caw.merging                                                                    as waiter_merging,
                                caw.spilling                                                                   as waiter_spilling,
                                caw.waiting_to_close                                                           as waiter_waiting_to_close,
                                dp.deadlock_graph
                         from #deadlock_process as dp
                                  outer apply (select top 1 *
                                               from #deadlock_resource_parallel as drp
                                               where drp.owner_id = dp.id
                                                 and drp.wait_type = 'e_waitPipeNewRow'
                                               order by drp.event_date) as cao
                                  outer apply (select top 1 *
                                               from #deadlock_resource_parallel as drp
                                               where drp.owner_id = dp.id
                                                 and drp.wait_type = 'e_waitPipeGetRow'
                                               order by drp.event_date) as caw
                         where dp.victim_id is null
                           and dp.login_name is not null
                )
            select d.deadlock_type,
                   d.event_date,
                   DB_NAME(d.database_id)                                                as database_name,
                   'Deadlock #'
                       + CONVERT(nvarchar(10), d.en)
                       + ', Query #'
                       + case when d.qn = 0 then N'1' else CONVERT(nvarchar(10), d.qn) end
                       + case when d.is_victim = 1 then ' - VICTIM' else '' end
                                                                                         as deadlock_group,
                   CONVERT(xml, N'<inputbuf><![CDATA[' + d.inputbuf + N']]></inputbuf>') as query,
                   d.object_names,
                   d.isolation_level,
                   d.owner_mode,
                   d.waiter_mode,
                   d.transaction_count,
                   d.login_name,
                   d.host_name,
                   d.client_app,
                   d.wait_time,
                   d.priority,
                   d.log_used,
                   d.last_tran_started,
                   d.last_batch_started,
                   d.last_batch_completed,
                   d.transaction_name,
                /*These columns will be NULL for regular (non-parallel) deadlocks*/
                   d.owner_waiter_type,
                   d.owner_activity,
                   d.owner_waiter_activity,
                   d.owner_merging,
                   d.owner_spilling,
                   d.owner_waiting_to_close,
                   d.waiter_waiter_type,
                   d.waiter_owner_activity,
                   d.waiter_waiter_activity,
                   d.waiter_merging,
                   d.waiter_spilling,
                   d.waiter_waiting_to_close,
                   d.deadlock_graph
            from deadlocks as d
            where d.dn = 1
              and (is_victim = @victimsonly or @victimsonly = 0)
              and d.en < case when d.deadlock_type = N'Parallel Deadlock' then 2 else 2147483647 end
              and (DB_NAME(d.database_id) = @databasename or @databasename is null)
              and (d.event_date >= @startdate or @startdate is null)
              and (d.event_date < @enddate or @enddate is null)
              and (CONVERT(nvarchar(max), d.object_names) like '%' + @objectname + '%' or @objectname is null)
              and (d.client_app = @appname or @appname is null)
              and (d.host_name = @hostname or @hostname is null)
              and (d.login_name = @loginname or @loginname is null)
            order by d.event_date, is_victim desc
            option ( recompile );

            set @d = CONVERT(varchar(40), GETDATE(), 109);
            raiserror ('Findings %s', 0, 1, @d) with nowait;
            select df.check_id, df.database_name, df.object_name, df.finding_group, df.finding
            from #deadlock_findings as df
            order by df.check_id
            option ( recompile );

            set @d = CONVERT(varchar(40), GETDATE(), 109);
            raiserror ('Done %s', 0, 1, @d) with nowait;
        end --done with output to client app.


    if @debug = 1
        begin

            select '#deadlock_data' as table_name, *
            from #deadlock_data as dd
            option ( recompile );

            select '#deadlock_resource' as table_name, *
            from #deadlock_resource as dr
            option ( recompile );

            select '#deadlock_resource_parallel' as table_name, *
            from #deadlock_resource_parallel as drp
            option ( recompile );

            select '#deadlock_owner_waiter' as table_name, *
            from #deadlock_owner_waiter as dow
            option ( recompile );

            select '#deadlock_process' as table_name, *
            from #deadlock_process as dp
            option ( recompile );

            select '#deadlock_stack' as table_name, *
            from #deadlock_stack as ds
            option ( recompile );

        end; -- End debug

end; --Final End

go
if OBJECT_ID('dbo.sp_BlitzWho') is null
    exec ('CREATE PROCEDURE dbo.sp_BlitzWho AS RETURN 0;')
go

alter procedure dbo.sp_blitzwho @help tinyint = 0,
                                @showsleepingspids tinyint = 0,
                                @expertmode bit = 0,
                                @debug bit = 0,
                                @outputdatabasename nvarchar(256) = null,
                                @outputschemaname nvarchar(256) = null,
                                @outputtablename nvarchar(256) = null,
                                @outputtableretentiondays tinyint = 3,
                                @minelapsedseconds int = 0,
                                @mincputime int = 0,
                                @minlogicalreads int = 0,
                                @minphysicalreads int = 0,
                                @minwrites int = 0,
                                @mintempdbmb int = 0,
                                @minrequestedmemorykb int = 0,
                                @minblockingseconds int = 0,
                                @checkdateoverride datetimeoffset = null,
                                @version varchar(30) = null output,
                                @versiondate datetime = null output,
                                @versioncheckmode bit = 0
as
begin
    set nocount on;
    set transaction isolation level read uncommitted;

    select @version = '7.97', @versiondate = '20200712';

    if (@versioncheckmode = 1)
        begin
            return;
        end;


    if @help = 1
        print '
sp_BlitzWho from http://FirstResponderKit.org

This script gives you a snapshot of everything currently executing on your SQL Server.

To learn more, visit http://FirstResponderKit.org where you can download new
versions for free, watch training videos on how it works, get more info on
the findings, contribute your own code, and more.

Known limitations of this version:
 - Only Microsoft-supported versions of SQL Server. Sorry, 2005 and 2000.
 - Outputting to table is only supported with SQL Server 2012 and higher.
 - If @OutputDatabaseName and @OutputSchemaName are populated, the database and
   schema must already exist. We will not create them, only the table.

MIT License

Copyright (c) 2020 Brent Ozar Unlimited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
';

/* Get the major and minor build numbers */
    declare @productversion nvarchar(128)
        ,@productversionmajor decimal(10, 2)
        ,@productversionminor decimal(10, 2)
        ,@platform nvarchar(8) /* Azure or NonAzure are acceptable */ = (select case when @@VERSION like '%Azure%' then N'Azure' else N'NonAzure' end as [Platform])
        ,@enhanceflag bit = 0
        ,@blockingcheck nvarchar(max)
        ,@stringtoselect nvarchar(max)
        ,@stringtoexecute nvarchar(max)
        ,@outputtablecleanupdate date
        ,@sessionwaits bit = 0
        ,@sessionwaitssql nvarchar(max) =
        N'LEFT JOIN ( SELECT DISTINCT
												wait.session_id ,
												( SELECT TOP  5 waitwait.wait_type + N'' (''
												     + CAST(MAX(waitwait.wait_time_ms) AS NVARCHAR(128))
												     + N'' ms), ''
												 FROM   sys.dm_exec_session_wait_stats AS waitwait
												 WHERE  waitwait.session_id = wait.session_id
												 GROUP BY  waitwait.wait_type
												 HAVING SUM(waitwait.wait_time_ms) > 5
												 ORDER BY 1
												 FOR
												 XML PATH('''') ) AS session_wait_info
										FROM sys.dm_exec_session_wait_stats AS wait ) AS wt2
						ON   s.session_id = wt2.session_id
						LEFT JOIN sys.dm_exec_query_stats AS session_stats
						ON   r.sql_handle = session_stats.sql_handle
								AND r.plan_handle = session_stats.plan_handle
						  AND r.statement_start_offset = session_stats.statement_start_offset
						  AND r.statement_end_offset = session_stats.statement_end_offset'
        ,@querystatsxmlselect nvarchar(max) = N' CAST(COALESCE(qs_live.query_plan, ''<?No live query plan available. To turn on live plans, see https://www.BrentOzar.com/go/liveplans ?>'') AS XML) AS live_query_plan , '
        ,@querystatsxmlsql nvarchar(max) = N'OUTER APPLY sys.dm_exec_query_statistics_xml(s.session_id) qs_live'
        ,@objectfullname nvarchar(2000);


    set @productversion = CAST(SERVERPROPERTY('ProductVersion') as nvarchar(128));
    select @productversionmajor = SUBSTRING(@productversion, 1, CHARINDEX('.', @productversion) + 1),
           @productversionminor = PARSENAME(CONVERT(varchar(32), @productversion), 2)
    if EXISTS(select *
              from sys.all_columns
              where object_id = OBJECT_ID('sys.dm_exec_query_statistics_xml') and name = 'query_plan')
        begin
            set @querystatsxmlselect =
                    N' CAST(COALESCE(qs_live.query_plan, ''<?No live query plan available. To turn on live plans, see https://www.BrentOzar.com/go/liveplans ?>'') AS XML) AS live_query_plan , ';
            set @querystatsxmlsql = N'OUTER APPLY sys.dm_exec_query_statistics_xml(s.session_id) qs_live';
        end
    else
        begin
            set @querystatsxmlselect = N' NULL AS live_query_plan , ';
            set @querystatsxmlsql = N' ';
        end

    select @outputdatabasename = QUOTENAME(@outputdatabasename),
           @outputschemaname = QUOTENAME(@outputschemaname),
           @outputtablename = QUOTENAME(@outputtablename);

    if @outputdatabasename is not null and @outputschemaname is not null and @outputtablename is not null
        and EXISTS(select *
                   from sys.databases
                   where QUOTENAME([name]) = @outputdatabasename)
        begin
            set @expertmode = 1;
            /* Force ExpertMode when we're logging to table */

            /* Create the table if it doesn't exist */
            set @stringtoexecute = N'USE '
                + @outputdatabasename
                + N'; IF EXISTS(SELECT * FROM '
                + @outputdatabasename
                + N'.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                + @outputschemaname
                + N''') AND NOT EXISTS (SELECT * FROM '
                + @outputdatabasename
                + N'.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
                + @outputschemaname + N''' AND QUOTENAME(TABLE_NAME) = '''
                + @outputtablename + N''') CREATE TABLE '
                + @outputschemaname + N'.'
                + @outputtablename
                + N'(';
            set @stringtoexecute = @stringtoexecute + N'
	ID INT IDENTITY(1,1) NOT NULL,
	ServerName NVARCHAR(128) NOT NULL,
	CheckDate DATETIMEOFFSET NOT NULL,
	[elapsed_time] [varchar](41) NULL,
	[session_id] [smallint] NOT NULL,
	[database_name] [nvarchar](128) NULL,
	[query_text] [nvarchar](max) NULL,
	[query_plan] [xml] NULL,
	[live_query_plan] [xml] NULL,
	[query_cost] [float] NULL,
	[status] [nvarchar](30) NOT NULL,
	[wait_info] [nvarchar](max) NULL,
	[top_session_waits] [nvarchar](max) NULL,
	[blocking_session_id] [smallint] NULL,
	[open_transaction_count] [int] NULL,
	[is_implicit_transaction] [int] NOT NULL,
	[nt_domain] [nvarchar](128) NULL,
	[host_name] [nvarchar](128) NULL,
	[login_name] [nvarchar](128) NOT NULL,
	[nt_user_name] [nvarchar](128) NULL,
	[program_name] [nvarchar](128) NULL,
	[fix_parameter_sniffing] [nvarchar](150) NULL,
	[client_interface_name] [nvarchar](32) NULL,
	[login_time] [datetime] NOT NULL,
	[start_time] [datetime] NULL,
	[request_time] [datetime] NULL,
	[request_cpu_time] [int] NULL,
	[request_logical_reads] [bigint] NULL,
	[request_writes] [bigint] NULL,
	[request_physical_reads] [bigint] NULL,
	[session_cpu] [int] NOT NULL,
	[session_logical_reads] [bigint] NOT NULL,
	[session_physical_reads] [bigint] NOT NULL,
	[session_writes] [bigint] NOT NULL,
	[tempdb_allocations_mb] [decimal](38, 2) NULL,
	[memory_usage] [int] NOT NULL,
	[estimated_completion_time] [bigint] NULL,
	[percent_complete] [real] NULL,
	[deadlock_priority] [int] NULL,
	[transaction_isolation_level] [varchar](33) NOT NULL,
	[degree_of_parallelism] [smallint] NULL,
	[last_dop] [bigint] NULL,
	[min_dop] [bigint] NULL,
	[max_dop] [bigint] NULL,
	[last_grant_kb] [bigint] NULL,
	[min_grant_kb] [bigint] NULL,
	[max_grant_kb] [bigint] NULL,
	[last_used_grant_kb] [bigint] NULL,
	[min_used_grant_kb] [bigint] NULL,
	[max_used_grant_kb] [bigint] NULL,
	[last_ideal_grant_kb] [bigint] NULL,
	[min_ideal_grant_kb] [bigint] NULL,
	[max_ideal_grant_kb] [bigint] NULL,
	[last_reserved_threads] [bigint] NULL,
	[min_reserved_threads] [bigint] NULL,
	[max_reserved_threads] [bigint] NULL,
	[last_used_threads] [bigint] NULL,
	[min_used_threads] [bigint] NULL,
	[max_used_threads] [bigint] NULL,
	[grant_time] [varchar](20) NULL,
	[requested_memory_kb] [bigint] NULL,
	[grant_memory_kb] [bigint] NULL,
	[is_request_granted] [varchar](39) NOT NULL,
	[required_memory_kb] [bigint] NULL,
	[query_memory_grant_used_memory_kb] [bigint] NULL,
	[ideal_memory_kb] [bigint] NULL,
	[is_small] [bit] NULL,
	[timeout_sec] [int] NULL,
	[resource_semaphore_id] [smallint] NULL,
	[wait_order] [varchar](20) NULL,
	[wait_time_ms] [varchar](20) NULL,
	[next_candidate_for_memory_grant] [varchar](3) NOT NULL,
	[target_memory_kb] [bigint] NULL,
	[max_target_memory_kb] [varchar](30) NULL,
	[total_memory_kb] [bigint] NULL,
	[available_memory_kb] [bigint] NULL,
	[granted_memory_kb] [bigint] NULL,
	[query_resource_semaphore_used_memory_kb] [bigint] NULL,
	[grantee_count] [int] NULL,
	[waiter_count] [int] NULL,
	[timeout_error_count] [bigint] NULL,
	[forced_grant_count] [varchar](30) NULL,
	[workload_group_name] [sysname] NULL,
	[resource_pool_name] [sysname] NULL,
	[context_info] [varchar](128) NULL,
	[query_hash] [binary](8) NULL,
	[query_plan_hash] [binary](8) NULL,
	[sql_handle] [varbinary] (64) NULL,
	[plan_handle] [varbinary] (64) NULL,
	[statement_start_offset] INT NULL,
	[statement_end_offset] INT NULL,
	JoinKey AS ServerName + CAST(CheckDate AS NVARCHAR(50)),
	PRIMARY KEY CLUSTERED (ID ASC));';
            if @debug = 1
                begin
                    print CONVERT(varchar(8000), SUBSTRING(@stringtoexecute, 0, 8000))
                    print CONVERT(varchar(8000), SUBSTRING(@stringtoexecute, 8000, 16000))
                end
            exec (@stringtoexecute);

            /* If the table doesn't have the new JoinKey computed column, add it. See Github #2162. */
            set @objectfullname = @outputdatabasename + N'.' + @outputschemaname + N'.' + @outputtablename;
            set @stringtoexecute = N'IF NOT EXISTS (SELECT * FROM ' + @outputdatabasename + N'.sys.all_columns
		WHERE object_id = (OBJECT_ID(''' + @objectfullname + N''')) AND name = ''JoinKey'')
		ALTER TABLE ' + @objectfullname + N' ADD JoinKey AS ServerName + CAST(CheckDate AS NVARCHAR(50));';
            exec (@stringtoexecute);

            /* Delete history older than @OutputTableRetentionDays */
            set @outputtablecleanupdate = CAST((DATEADD(day, -1 * @outputtableretentiondays, GETDATE())) as date);
            set @stringtoexecute = N' IF EXISTS(SELECT * FROM '
                + @outputdatabasename
                + N'.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
                + @outputschemaname + N''') DELETE '
                + @outputdatabasename + '.'
                + @outputschemaname + '.'
                + @outputtablename
                + N' WHERE ServerName = @SrvName AND CheckDate < @CheckDate;';
            if @debug = 1
                begin
                    print CONVERT(varchar(8000), SUBSTRING(@stringtoexecute, 0, 8000))
                    print CONVERT(varchar(8000), SUBSTRING(@stringtoexecute, 8000, 16000))
                end
            exec sp_executesql @stringtoexecute,
                 N'@SrvName NVARCHAR(128), @CheckDate date',
                 @@SERVERNAME, @outputtablecleanupdate;

        end

    select @blockingcheck = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

						DECLARE @blocked TABLE
								(
								    dbid SMALLINT NOT NULL,
								    last_batch DATETIME NOT NULL,
								    open_tran SMALLINT NOT NULL,
								    sql_handle BINARY(20) NOT NULL,
								    session_id SMALLINT NOT NULL,
								    blocking_session_id SMALLINT NOT NULL,
								    lastwaittype NCHAR(32) NOT NULL,
								    waittime BIGINT NOT NULL,
								    cpu INT NOT NULL,
								    physical_io BIGINT NOT NULL,
								    memusage INT NOT NULL
								);

						INSERT @blocked ( dbid, last_batch, open_tran, sql_handle, session_id, blocking_session_id, lastwaittype, waittime, cpu, physical_io, memusage )
						SELECT
							sys1.dbid, sys1.last_batch, sys1.open_tran, sys1.sql_handle,
							sys2.spid AS session_id, sys2.blocked AS blocking_session_id, sys2.lastwaittype, sys2.waittime, sys2.cpu, sys2.physical_io, sys2.memusage
						FROM sys.sysprocesses AS sys1
						JOIN sys.sysprocesses AS sys2
						ON sys1.spid = sys2.blocked;';

    if @productversionmajor > 9 and @productversionmajor < 11
        begin
            /* Think of the StringToExecute as starting with this, but we'll set this up later depending on whether we're doing an insert or a select:
    SELECT @StringToExecute = N'SELECT  GETDATE() AS run_date ,
    */
            set @stringtoexecute = N'COALESCE( CONVERT(VARCHAR(20), (ABS(r.total_elapsed_time) / 1000) / 86400) + '':'' + CONVERT(VARCHAR(20), (DATEADD(SECOND, (r.total_elapsed_time / 1000), 0) + DATEADD(MILLISECOND, (r.total_elapsed_time % 1000), 0)), 114), CONVERT(VARCHAR(20), DATEDIFF(SECOND, s.last_request_start_time, GETDATE()) / 86400) + '':'' + CONVERT(VARCHAR(20), DATEADD(SECOND, DATEDIFF(SECOND, s.last_request_start_time, GETDATE()), 0), 114) ) AS [elapsed_time] ,
			       s.session_id ,
						    COALESCE(DB_NAME(r.database_id), DB_NAME(blocked.dbid), ''N/A'') AS database_name,
			       ISNULL(SUBSTRING(dest.text,
			            ( query_stats.statement_start_offset / 2 ) + 1,
			            ( ( CASE query_stats.statement_end_offset
			               WHEN -1 THEN DATALENGTH(dest.text)
			               ELSE query_stats.statement_end_offset
			             END - query_stats.statement_start_offset )
			              / 2 ) + 1), dest.text) AS query_text ,
			       derp.query_plan ,
						    qmg.query_cost ,
						    s.status ,
			       COALESCE(wt.wait_info, RTRIM(blocked.lastwaittype) + '' ('' + CONVERT(VARCHAR(10),
						    blocked.waittime) + '')'' ) AS wait_info ,
						    CASE WHEN r.blocking_session_id <> 0 AND blocked.session_id IS NULL
							     THEN r.blocking_session_id
							     WHEN r.blocking_session_id <> 0 AND s.session_id <> blocked.blocking_session_id
							     THEN blocked.blocking_session_id
							    ELSE NULL
						    END AS blocking_session_id ,
			       COALESCE(r.open_transaction_count, blocked.open_tran) AS open_transaction_count ,
						    CASE WHEN EXISTS (  SELECT 1
               FROM sys.dm_tran_active_transactions AS tat
               JOIN sys.dm_tran_session_transactions AS tst
               ON tst.transaction_id = tat.transaction_id
               WHERE tat.name = ''implicit_transaction''
               AND s.session_id = tst.session_id
               )  THEN 1
            ELSE 0
          END AS is_implicit_transaction ,
					     s.nt_domain ,
			       s.host_name ,
			       s.login_name ,
			       s.nt_user_name ,'
            if @platform = 'NonAzure'
                begin
                    set @stringtoexecute +=
                        N'program_name = COALESCE((
					SELECT REPLACE(program_name,Substring(program_name,30,34),''"''+j.name+''"'')
					FROM msdb.dbo.sysjobs j WHERE Substring(program_name,32,32) = CONVERT(char(32),CAST(j.job_id AS binary(16)),2)
					),s.program_name)'
                end
            else
                begin
                    set @stringtoexecute += N's.program_name'
                end

            if @expertmode = 1
                begin
                    set @stringtoexecute +=
                        N',
						''DBCC FREEPROCCACHE ('' + CONVERT(NVARCHAR(128), r.plan_handle, 1) + '');'' AS fix_parameter_sniffing,
			   s.client_interface_name ,
			   s.login_time ,
			   r.start_time ,
			   qmg.request_time ,
						COALESCE(r.cpu_time, s.cpu_time) AS request_cpu_time,
			   COALESCE(r.logical_reads, s.logical_reads) AS request_logical_reads,
			   COALESCE(r.writes, s.writes) AS request_writes,
			   COALESCE(r.reads, s.reads) AS request_physical_reads ,
			   s.cpu_time AS session_cpu,
			   s.logical_reads AS session_logical_reads,
			   s.reads AS session_physical_reads ,
			   s.writes AS session_writes,
						tempdb_allocations.tempdb_allocations_mb,
			   s.memory_usage ,
			   r.estimated_completion_time ,
						r.percent_complete ,
			   r.deadlock_priority ,
			   CASE
			     WHEN s.transaction_isolation_level = 0 THEN ''Unspecified''
			     WHEN s.transaction_isolation_level = 1 THEN ''Read Uncommitted''
			     WHEN s.transaction_isolation_level = 2 AND EXISTS (SELECT 1 FROM sys.dm_tran_active_snapshot_database_transactions AS trn WHERE s.session_id = trn.session_id AND is_snapshot = 0 ) THEN ''Read Committed Snapshot Isolation''
						  WHEN s.transaction_isolation_level = 2 AND NOT EXISTS (SELECT 1 FROM sys.dm_tran_active_snapshot_database_transactions AS trn WHERE s.session_id = trn.session_id AND is_snapshot = 0 ) THEN ''Read Committed''
			     WHEN s.transaction_isolation_level = 3 THEN ''Repeatable Read''
			     WHEN s.transaction_isolation_level = 4 THEN ''Serializable''
			     WHEN s.transaction_isolation_level = 5 THEN ''Snapshot''
			     ELSE ''WHAT HAVE YOU DONE?''
			   END AS transaction_isolation_level ,
						qmg.dop AS degree_of_parallelism ,
			   COALESCE(CAST(qmg.grant_time AS VARCHAR(20)), ''N/A'') AS grant_time ,
			   qmg.requested_memory_kb ,
			   qmg.granted_memory_kb AS grant_memory_kb,
			   CASE WHEN qmg.grant_time IS NULL THEN ''N/A''
        WHEN qmg.requested_memory_kb < qmg.granted_memory_kb
			     THEN ''Query Granted Less Than Query Requested''
			     ELSE ''Memory Request Granted''
			   END AS is_request_granted ,
			   qmg.required_memory_kb ,
			   qmg.used_memory_kb AS query_memory_grant_used_memory_kb,
			   qmg.ideal_memory_kb ,
			   qmg.is_small ,
			   qmg.timeout_sec ,
			   qmg.resource_semaphore_id ,
			   COALESCE(CAST(qmg.wait_order AS VARCHAR(20)), ''N/A'') AS wait_order ,
			   COALESCE(CAST(qmg.wait_time_ms AS VARCHAR(20)),
			      ''N/A'') AS wait_time_ms ,
			   CASE qmg.is_next_candidate
			     WHEN 0 THEN ''No''
			     WHEN 1 THEN ''Yes''
			     ELSE ''N/A''
			   END AS next_candidate_for_memory_grant ,
			   qrs.target_memory_kb ,
			   COALESCE(CAST(qrs.max_target_memory_kb AS VARCHAR(20)),
			      ''Small Query Resource Semaphore'') AS max_target_memory_kb ,
			   qrs.total_memory_kb ,
			   qrs.available_memory_kb ,
			   qrs.granted_memory_kb ,
			   qrs.used_memory_kb AS query_resource_semaphore_used_memory_kb,
			   qrs.grantee_count ,
			   qrs.waiter_count ,
			   qrs.timeout_error_count ,
			   COALESCE(CAST(qrs.forced_grant_count AS VARCHAR(20)),
			      ''Small Query Resource Semaphore'') AS forced_grant_count,
						wg.name AS workload_group_name ,
						rp.name AS resource_pool_name,
 						CONVERT(VARCHAR(128), r.context_info)  AS context_info
						'
                end /* IF @ExpertMode = 1 */

            set @stringtoexecute +=
                    N'FROM sys.dm_exec_sessions AS s
			 LEFT JOIN sys.dm_exec_requests AS r
			 ON   r.session_id = s.session_id
			 LEFT JOIN ( SELECT DISTINCT
			      wait.session_id ,
			      ( SELECT waitwait.wait_type + N'' (''
			         + CAST(MAX(waitwait.wait_duration_ms) AS NVARCHAR(128))
			         + N'' ms) ''
			        FROM   sys.dm_os_waiting_tasks AS waitwait
			        WHERE  waitwait.session_id = wait.session_id
			        GROUP BY  waitwait.wait_type
			        ORDER BY  SUM(waitwait.wait_duration_ms) DESC
			      FOR
			        XML PATH('''') ) AS wait_info
			    FROM sys.dm_os_waiting_tasks AS wait ) AS wt
			 ON   s.session_id = wt.session_id
			 LEFT JOIN sys.dm_exec_query_stats AS query_stats
			 ON   r.sql_handle = query_stats.sql_handle
						AND r.plan_handle = query_stats.plan_handle
			   AND r.statement_start_offset = query_stats.statement_start_offset
			   AND r.statement_end_offset = query_stats.statement_end_offset
			 LEFT JOIN sys.dm_exec_query_memory_grants qmg
			 ON   r.session_id = qmg.session_id
						AND r.request_id = qmg.request_id
			 LEFT JOIN sys.dm_exec_query_resource_semaphores qrs
			 ON   qmg.resource_semaphore_id = qrs.resource_semaphore_id
					 AND qmg.pool_id = qrs.pool_id
				LEFT JOIN sys.resource_governor_workload_groups wg
				ON 		s.group_id = wg.group_id
				LEFT JOIN sys.resource_governor_resource_pools rp
				ON		wg.pool_id = rp.pool_id
				OUTER APPLY (
								SELECT TOP 1
								b.dbid, b.last_batch, b.open_tran, b.sql_handle,
								b.session_id, b.blocking_session_id, b.lastwaittype, b.waittime
								FROM @blocked b
								WHERE (s.session_id = b.session_id
										OR s.session_id = b.blocking_session_id)
							) AS blocked
				OUTER APPLY sys.dm_exec_sql_text(COALESCE(r.sql_handle, blocked.sql_handle)) AS dest
			 OUTER APPLY sys.dm_exec_query_plan(r.plan_handle) AS derp
				OUTER APPLY (
						SELECT CONVERT(DECIMAL(38,2), SUM( (((tsu.user_objects_alloc_page_count - user_objects_dealloc_page_count) * 8) / 1024.)) ) AS tempdb_allocations_mb
						FROM sys.dm_db_task_space_usage tsu
						WHERE tsu.request_id = r.request_id
						AND tsu.session_id = r.session_id
						AND tsu.session_id = s.session_id
				) as tempdb_allocations
			 WHERE s.session_id <> @@SPID
				AND s.host_name IS NOT NULL
				'
                    + case
                          when @showsleepingspids = 0 then
                              N' AND COALESCE(DB_NAME(r.database_id), DB_NAME(blocked.dbid)) IS NOT NULL'
                          when @showsleepingspids = 1 then
                              N' OR COALESCE(r.open_transaction_count, blocked.open_tran) >= 1'
                          else N'' end;
        end /* IF @ProductVersionMajor > 9 and @ProductVersionMajor < 11 */

    if @productversionmajor >= 11
        begin
            select @enhanceflag =
                   case
                       when @productversionmajor = 11 and @productversionminor >= 6020 then 1
                       when @productversionmajor = 12 and @productversionminor >= 5000 then 1
                       when @productversionmajor = 13 and @productversionminor >= 1601 then 1
                       when @productversionmajor > 13 then 1
                       else 0
                       end


            if OBJECT_ID('sys.dm_exec_session_wait_stats') is not null
                begin
                    set @sessionwaits = 1
                end

            /* Think of the StringToExecute as starting with this, but we'll set this up later depending on whether we're doing an insert or a select:
    SELECT @StringToExecute = N'SELECT  GETDATE() AS run_date ,
    */
            select @stringtoexecute = N'COALESCE( CONVERT(VARCHAR(20), (ABS(r.total_elapsed_time) / 1000) / 86400) + '':'' + CONVERT(VARCHAR(20), (DATEADD(SECOND, (r.total_elapsed_time / 1000), 0) + DATEADD(MILLISECOND, (r.total_elapsed_time % 1000), 0)), 114), CONVERT(VARCHAR(20), DATEDIFF(SECOND, s.last_request_start_time, GETDATE()) / 86400) + '':'' + CONVERT(VARCHAR(20), DATEADD(SECOND, DATEDIFF(SECOND, s.last_request_start_time, GETDATE()), 0), 114) ) AS [elapsed_time] ,
			       s.session_id ,
						    COALESCE(DB_NAME(r.database_id), DB_NAME(blocked.dbid), ''N/A'') AS database_name,
			       ISNULL(SUBSTRING(dest.text,
			            ( query_stats.statement_start_offset / 2 ) + 1,
			            ( ( CASE query_stats.statement_end_offset
			               WHEN -1 THEN DATALENGTH(dest.text)
			               ELSE query_stats.statement_end_offset
			             END - query_stats.statement_start_offset )
			              / 2 ) + 1), dest.text) AS query_text ,
			       derp.query_plan ,'
                + @querystatsxmlselect
                + '
			       qmg.query_cost ,
			       s.status ,
			       COALESCE(wt.wait_info, RTRIM(blocked.lastwaittype) + '' ('' + CONVERT(VARCHAR(10), blocked.waittime) + '')'' ) AS wait_info ,'
                +
                                      case @sessionwaits
                                          when 1
                                              then + N'SUBSTRING(wt2.session_wait_info, 0, LEN(wt2.session_wait_info) ) AS top_session_waits ,'
                                          else N' NULL AS top_session_waits ,'
                                          end
                +
                                      N'CASE WHEN r.blocking_session_id <> 0 AND blocked.session_id IS NULL
							       THEN r.blocking_session_id
							       WHEN r.blocking_session_id <> 0 AND s.session_id <> blocked.blocking_session_id
							       THEN blocked.blocking_session_id
							       ELSE NULL
						      END AS blocking_session_id,
			       COALESCE(r.open_transaction_count, blocked.open_tran) AS open_transaction_count ,
						    CASE WHEN EXISTS (  SELECT 1
               FROM sys.dm_tran_active_transactions AS tat
               JOIN sys.dm_tran_session_transactions AS tst
               ON tst.transaction_id = tat.transaction_id
               WHERE tat.name = ''implicit_transaction''
               AND s.session_id = tst.session_id
               )  THEN 1
            ELSE 0
          END AS is_implicit_transaction ,
					     s.nt_domain ,
			       s.host_name ,
			       s.login_name ,
			       s.nt_user_name ,'
            if @platform = 'NonAzure'
                begin
                    set @stringtoexecute +=
                        N'program_name = COALESCE((
					SELECT REPLACE(program_name,Substring(program_name,30,34),''"''+j.name+''"'')
					FROM msdb.dbo.sysjobs j WHERE Substring(program_name,32,32) = CONVERT(char(32),CAST(j.job_id AS binary(16)),2)
					),s.program_name)'
                end
            else
                begin
                    set @stringtoexecute += N's.program_name'
                end

            if @expertmode = 1 /* We show more columns in expert mode, so the SELECT gets longer */
                begin
                    set @stringtoexecute +=
                            N', ''DBCC FREEPROCCACHE ('' + CONVERT(NVARCHAR(128), r.plan_handle, 1) + '');'' AS fix_parameter_sniffing,
        s.client_interface_name ,
        s.login_time ,
        r.start_time ,
        qmg.request_time ,
		        COALESCE(r.cpu_time, s.cpu_time) AS request_cpu_time,
        COALESCE(r.logical_reads, s.logical_reads) AS request_logical_reads,
        COALESCE(r.writes, s.writes) AS request_writes,
        COALESCE(r.reads, s.reads) AS request_physical_reads ,
        s.cpu_time AS session_cpu,
        s.logical_reads AS session_logical_reads,
        s.reads AS session_physical_reads ,
        s.writes AS session_writes,
		        tempdb_allocations.tempdb_allocations_mb,
        s.memory_usage ,
        r.estimated_completion_time ,
		        r.percent_complete ,
        r.deadlock_priority ,
		        CASE
	        WHEN s.transaction_isolation_level = 0 THEN ''Unspecified''
	        WHEN s.transaction_isolation_level = 1 THEN ''Read Uncommitted''
	        WHEN s.transaction_isolation_level = 2 AND EXISTS (SELECT 1 FROM sys.dm_tran_active_snapshot_database_transactions AS trn WHERE s.session_id = trn.session_id AND is_snapshot = 0 ) THEN ''Read Committed Snapshot Isolation''
			        WHEN s.transaction_isolation_level = 2 AND NOT EXISTS (SELECT 1 FROM sys.dm_tran_active_snapshot_database_transactions AS trn WHERE s.session_id = trn.session_id AND is_snapshot = 0 ) THEN ''Read Committed''
	        WHEN s.transaction_isolation_level = 3 THEN ''Repeatable Read''
	        WHEN s.transaction_isolation_level = 4 THEN ''Serializable''
	        WHEN s.transaction_isolation_level = 5 THEN ''Snapshot''
	        ELSE ''WHAT HAVE YOU DONE?''
        END AS transaction_isolation_level ,
		        qmg.dop AS degree_of_parallelism ,						'
                            +
                            case @enhanceflag
                                when 1 then N'query_stats.last_dop,
        query_stats.min_dop,
        query_stats.max_dop,
        query_stats.last_grant_kb,
        query_stats.min_grant_kb,
        query_stats.max_grant_kb,
        query_stats.last_used_grant_kb,
        query_stats.min_used_grant_kb,
        query_stats.max_used_grant_kb,
        query_stats.last_ideal_grant_kb,
        query_stats.min_ideal_grant_kb,
        query_stats.max_ideal_grant_kb,
        query_stats.last_reserved_threads,
        query_stats.min_reserved_threads,
        query_stats.max_reserved_threads,
        query_stats.last_used_threads,
        query_stats.min_used_threads,
        query_stats.max_used_threads,'
                                else N' NULL AS last_dop,
        NULL AS min_dop,
        NULL AS max_dop,
        NULL AS last_grant_kb,
        NULL AS min_grant_kb,
        NULL AS max_grant_kb,
        NULL AS last_used_grant_kb,
        NULL AS min_used_grant_kb,
        NULL AS max_used_grant_kb,
        NULL AS last_ideal_grant_kb,
        NULL AS min_ideal_grant_kb,
        NULL AS max_ideal_grant_kb,
        NULL AS last_reserved_threads,
        NULL AS min_reserved_threads,
        NULL AS max_reserved_threads,
        NULL AS last_used_threads,
        NULL AS min_used_threads,
        NULL AS max_used_threads,'
                                end

                    set @stringtoexecute +=
                        N'
        COALESCE(CAST(qmg.grant_time AS VARCHAR(20)), ''Memory Not Granted'') AS grant_time ,
        qmg.requested_memory_kb ,
        qmg.granted_memory_kb AS grant_memory_kb,
        CASE WHEN qmg.grant_time IS NULL THEN ''N/A''
        WHEN qmg.requested_memory_kb < qmg.granted_memory_kb
	        THEN ''Query Granted Less Than Query Requested''
	        ELSE ''Memory Request Granted''
        END AS is_request_granted ,
        qmg.required_memory_kb ,
        qmg.used_memory_kb AS query_memory_grant_used_memory_kb,
        qmg.ideal_memory_kb ,
        qmg.is_small ,
        qmg.timeout_sec ,
        qmg.resource_semaphore_id ,
        COALESCE(CAST(qmg.wait_order AS VARCHAR(20)), ''N/A'') AS wait_order ,
        COALESCE(CAST(qmg.wait_time_ms AS VARCHAR(20)),
	        ''N/A'') AS wait_time_ms ,
        CASE qmg.is_next_candidate
	        WHEN 0 THEN ''No''
	        WHEN 1 THEN ''Yes''
	        ELSE ''N/A''
        END AS next_candidate_for_memory_grant ,
        qrs.target_memory_kb ,
        COALESCE(CAST(qrs.max_target_memory_kb AS VARCHAR(20)),
	        ''Small Query Resource Semaphore'') AS max_target_memory_kb ,
        qrs.total_memory_kb ,
        qrs.available_memory_kb ,
        qrs.granted_memory_kb ,
        qrs.used_memory_kb AS query_resource_semaphore_used_memory_kb,
        qrs.grantee_count ,
        qrs.waiter_count ,
        qrs.timeout_error_count ,
        COALESCE(CAST(qrs.forced_grant_count AS VARCHAR(20)),
        ''Small Query Resource Semaphore'') AS forced_grant_count,
        wg.name AS workload_group_name,
        rp.name AS resource_pool_name,
        CONVERT(VARCHAR(128), r.context_info)  AS context_info,
        r.query_hash, r.query_plan_hash, r.sql_handle, r.plan_handle, r.statement_start_offset, r.statement_end_offset '
                end /* IF @ExpertMode = 1 */

            set @stringtoexecute +=
                    N' FROM sys.dm_exec_sessions AS s
	    LEFT JOIN sys.dm_exec_requests AS r
					    ON   r.session_id = s.session_id
	    LEFT JOIN ( SELECT DISTINCT
						    wait.session_id ,
						    ( SELECT waitwait.wait_type + N'' (''
							    + CAST(MAX(waitwait.wait_duration_ms) AS NVARCHAR(128))
							    + N'' ms) ''
						    FROM   sys.dm_os_waiting_tasks AS waitwait
						    WHERE  waitwait.session_id = wait.session_id
						    GROUP BY  waitwait.wait_type
						    ORDER BY  SUM(waitwait.wait_duration_ms) DESC
						    FOR
						    XML PATH('''') ) AS wait_info
					    FROM sys.dm_os_waiting_tasks AS wait ) AS wt
					    ON   s.session_id = wt.session_id
	    LEFT JOIN sys.dm_exec_query_stats AS query_stats
	    ON   r.sql_handle = query_stats.sql_handle
			    AND r.plan_handle = query_stats.plan_handle
		    AND r.statement_start_offset = query_stats.statement_start_offset
		    AND r.statement_end_offset = query_stats.statement_end_offset
	    '
                    +
                    case @sessionwaits
                        when 1 then @sessionwaitssql
                        else N''
                        end
                    +
                    N'
	    LEFT JOIN sys.dm_exec_query_memory_grants qmg
	    ON   r.session_id = qmg.session_id
			    AND r.request_id = qmg.request_id
	    LEFT JOIN sys.dm_exec_query_resource_semaphores qrs
	    ON   qmg.resource_semaphore_id = qrs.resource_semaphore_id
			    AND qmg.pool_id = qrs.pool_id
	    LEFT JOIN sys.resource_governor_workload_groups wg
	    ON 		s.group_id = wg.group_id
	    LEFT JOIN sys.resource_governor_resource_pools rp
	    ON		wg.pool_id = rp.pool_id
	    OUTER APPLY (
			    SELECT TOP 1
			    b.dbid, b.last_batch, b.open_tran, b.sql_handle,
			    b.session_id, b.blocking_session_id, b.lastwaittype, b.waittime
			    FROM @blocked b
			    WHERE (s.session_id = b.session_id
					    OR s.session_id = b.blocking_session_id)
		    ) AS blocked
	    OUTER APPLY sys.dm_exec_sql_text(COALESCE(r.sql_handle, blocked.sql_handle)) AS dest
	    OUTER APPLY sys.dm_exec_query_plan(r.plan_handle) AS derp
	    OUTER APPLY (
			    SELECT CONVERT(DECIMAL(38,2), SUM( (((tsu.user_objects_alloc_page_count - user_objects_dealloc_page_count) * 8) / 1024.)) ) AS tempdb_allocations_mb
			    FROM sys.dm_db_task_space_usage tsu
			    WHERE tsu.request_id = r.request_id
			    AND tsu.session_id = r.session_id
			    AND tsu.session_id = s.session_id
	    ) as tempdb_allocations
	    '
                    + @querystatsxmlsql
                    +
                    N'
	    WHERE s.session_id <> @@SPID
	    AND s.host_name IS NOT NULL
	    '
                    + case
                          when @showsleepingspids = 0 then
                              N' AND COALESCE(DB_NAME(r.database_id), DB_NAME(blocked.dbid)) IS NOT NULL'
                          when @showsleepingspids = 1 then
                              N' OR COALESCE(r.open_transaction_count, blocked.open_tran) >= 1'
                          else N'' end;


        end /* IF @ProductVersionMajor >= 11  */

    if (@minelapsedseconds + @mincputime + @minlogicalreads + @minphysicalreads + @minwrites + @mintempdbmb +
        @minrequestedmemorykb + @minblockingseconds) > 0
        begin
            /* They're filtering for something, so set up a where clause that will let any (not all combined) of the min triggers work: */
            set @stringtoexecute += N' AND (1 = 0 ';
            if @minelapsedseconds > 0
                set @stringtoexecute += N' OR ABS(COALESCE(r.total_elapsed_time,0)) / 1000 >= ' +
                                        CAST(@minelapsedseconds as nvarchar(20));
            if @mincputime > 0
                set @stringtoexecute += N' OR COALESCE(r.cpu_time, s.cpu_time,0) / 1000 >= ' +
                                        CAST(@mincputime as nvarchar(20));
            if @minlogicalreads > 0
                set @stringtoexecute += N' OR COALESCE(r.logical_reads, s.logical_reads,0) >= ' +
                                        CAST(@minlogicalreads as nvarchar(20));
            if @minphysicalreads > 0
                set @stringtoexecute += N' OR COALESCE(s.reads,0) >= ' + CAST(@minphysicalreads as nvarchar(20));
            if @minwrites > 0
                set @stringtoexecute += N' OR COALESCE(r.writes, s.writes,0) >= ' + CAST(@minwrites as nvarchar(20));
            if @mintempdbmb > 0
                set @stringtoexecute += N' OR COALESCE(tempdb_allocations.tempdb_allocations_mb,0) >= ' +
                                        CAST(@mintempdbmb as nvarchar(20));
            if @minrequestedmemorykb > 0
                set @stringtoexecute += N' OR COALESCE(qmg.requested_memory_kb,0) >= ' +
                                        CAST(@minrequestedmemorykb as nvarchar(20));
            /* Blocking is a little different - we're going to return ALL of the queries if we meet the blocking threshold. */
            if @minblockingseconds > 0
                set @stringtoexecute += N' OR (SELECT SUM(waittime / 1000) FROM @blocked) >= ' +
                                        CAST(@minblockingseconds as nvarchar(20));
            set @stringtoexecute += N' ) ';
        end

    set @stringtoexecute +=
        N' ORDER BY 2 DESC
	';


    if @outputdatabasename is not null and @outputschemaname is not null and @outputtablename is not null
        and EXISTS(select *
                   from sys.databases
                   where QUOTENAME([name]) = @outputdatabasename)
        begin
            set @stringtoexecute = N'USE '
                + @outputdatabasename + N'; '
                + @blockingcheck +
                                   + ' INSERT INTO '
                + @outputschemaname + N'.'
                + @outputtablename
                + N'(ServerName
	,CheckDate
	,[elapsed_time]
	,[session_id]
	,[database_name]
	,[query_text]
	,[query_plan]'
                + case when @productversionmajor >= 11 then N',[live_query_plan]' else N'' end + N'
	,[query_cost]
	,[status]
	,[wait_info]'
                + case when @productversionmajor >= 11 then N',[top_session_waits]' else N'' end + N'
	,[blocking_session_id]
	,[open_transaction_count]
	,[is_implicit_transaction]
	,[nt_domain]
	,[host_name]
	,[login_name]
	,[nt_user_name]
	,[program_name]
	,[fix_parameter_sniffing]
	,[client_interface_name]
	,[login_time]
	,[start_time]
	,[request_time]
	,[request_cpu_time]
	,[request_logical_reads]
	,[request_writes]
	,[request_physical_reads]
	,[session_cpu]
	,[session_logical_reads]
	,[session_physical_reads]
	,[session_writes]
	,[tempdb_allocations_mb]
	,[memory_usage]
	,[estimated_completion_time]
	,[percent_complete]
	,[deadlock_priority]
	,[transaction_isolation_level]
	,[degree_of_parallelism]'
                + case
                      when @productversionmajor >= 11 then N'
	,[last_dop]
	,[min_dop]
	,[max_dop]
	,[last_grant_kb]
	,[min_grant_kb]
	,[max_grant_kb]
	,[last_used_grant_kb]
	,[min_used_grant_kb]
	,[max_used_grant_kb]
	,[last_ideal_grant_kb]
	,[min_ideal_grant_kb]
	,[max_ideal_grant_kb]
	,[last_reserved_threads]
	,[min_reserved_threads]
	,[max_reserved_threads]
	,[last_used_threads]
	,[min_used_threads]
	,[max_used_threads]'
                      else N'' end + N'
	,[grant_time]
	,[requested_memory_kb]
	,[grant_memory_kb]
	,[is_request_granted]
	,[required_memory_kb]
	,[query_memory_grant_used_memory_kb]
	,[ideal_memory_kb]
	,[is_small]
	,[timeout_sec]
	,[resource_semaphore_id]
	,[wait_order]
	,[wait_time_ms]
	,[next_candidate_for_memory_grant]
	,[target_memory_kb]
	,[max_target_memory_kb]
	,[total_memory_kb]
	,[available_memory_kb]
	,[granted_memory_kb]
	,[query_resource_semaphore_used_memory_kb]
	,[grantee_count]
	,[waiter_count]
	,[timeout_error_count]
	,[forced_grant_count]
	,[workload_group_name]
	,[resource_pool_name]
	,[context_info]'
                + case
                      when @productversionmajor >= 11 then N'
	,[query_hash]
	,[query_plan_hash]
	,[sql_handle]
	,[plan_handle]
	,[statement_start_offset]
	,[statement_end_offset]'
                      else N'' end + N'
)
	SELECT @@SERVERNAME, COALESCE(@CheckDateOverride, SYSDATETIMEOFFSET()) AS CheckDate , '
                + @stringtoexecute;
        end
    else
        set @stringtoexecute = @blockingcheck + N' SELECT  GETDATE() AS run_date , ' + @stringtoexecute;

/* If the server has > 50GB of memory, add a max grant hint to avoid getting a giant grant */
    if (@productversionmajor = 11 and @productversionminor >= 6020)
        or (@productversionmajor = 12 and @productversionminor >= 5000)
        or (@productversionmajor >= 13)
           and 50000000 < (select cntr_value
                           from sys.dm_os_performance_counters
                           where object_name like '%:Memory Manager%'
                             and counter_name like 'Target Server Memory (KB)%')
        begin
            set @stringtoexecute = @stringtoexecute + N' OPTION (MAX_GRANT_PERCENT = 1, RECOMPILE) ';
        end
    else
        begin
            set @stringtoexecute = @stringtoexecute + N' OPTION (RECOMPILE) ';
        end

/* Be good: */
    set @stringtoexecute = @stringtoexecute + N' ; ';


    if @debug = 1
        begin
            print CONVERT(varchar(8000), SUBSTRING(@stringtoexecute, 0, 8000))
            print CONVERT(varchar(8000), SUBSTRING(@stringtoexecute, 8000, 16000))
        end

    exec sp_executesql @stringtoexecute,
         N'@CheckDateOverride DATETIMEOFFSET',
         @checkdateoverride;

end
go

if (OBJECT_ID('dbo.SqlServerVersions') is null)
    begin

        create table dbo.sqlserverversions
        (
            majorversionnumber tinyint not null,
            minorversionnumber smallint not null,
            branch varchar(34) not null,
            [Url] varchar(99) not null,
            releasedate date not null,
            mainstreamsupportenddate date not null,
            extendedsupportenddate date not null,
            majorversionname varchar(19) not null,
            minorversionname varchar(67) not null,

            constraint pk_sqlserverversions primary key clustered
                (
                 majorversionnumber asc,
                 minorversionnumber asc,
                 releasedate asc
                    )
        );

    end;
go

delete
from dbo.sqlserverversions;

insert into dbo.sqlserverversions
(majorversionnumber, minorversionnumber, branch, [Url], releasedate, mainstreamsupportenddate, extendedsupportenddate,
 majorversionname, minorversionname)
values (15, 4043, 'CU5', 'https://support.microsoft.com/en-us/help/4548597', '2020-06-22', '2025-01-07', '2030-01-08',
        'SQL Server 2019', 'Cumulative Update 5 '),
       (15, 4033, 'CU4', 'https://support.microsoft.com/en-us/help/4548597', '2020-03-31', '2025-01-07', '2030-01-08',
        'SQL Server 2019', 'Cumulative Update 4 '),
       (15, 4023, 'CU3', 'https://support.microsoft.com/en-us/help/4538853', '2020-03-12', '2025-01-07', '2030-01-08',
        'SQL Server 2019', 'Cumulative Update 3 '),
       (15, 4013, 'CU2', 'https://support.microsoft.com/en-us/help/4536075', '2020-02-13', '2025-01-07', '2030-01-08',
        'SQL Server 2019', 'Cumulative Update 2 '),
       (15, 4003, 'CU1', 'https://support.microsoft.com/en-us/help/4527376', '2020-01-07', '2025-01-07', '2030-01-08',
        'SQL Server 2019', 'Cumulative Update 1 '),
       (15, 2070, 'GDR', 'https://support.microsoft.com/en-us/help/4517790', '2019-11-04', '2025-01-07', '2030-01-08',
        'SQL Server 2019', 'RTM GDR '),
       (15, 2000, 'RTM ', '', '2019-11-04', '2025-01-07', '2030-01-08', 'SQL Server 2019', 'RTM '),
       (14, 3335, 'RTM CU21', 'https://support.microsoft.com/en-us/help/4557397', '2020-07-01', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 21'),
       (14, 3294, 'RTM CU20', 'https://support.microsoft.com/en-us/help/4541283', '2020-04-07', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 20'),
       (14, 3257, 'RTM CU19', 'https://support.microsoft.com/en-us/help/4535007', '2020-02-05', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 19'),
       (14, 3257, 'RTM CU18', 'https://support.microsoft.com/en-us/help/4527377', '2019-12-09', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 18'),
       (14, 3238, 'RTM CU17', 'https://support.microsoft.com/en-us/help/4515579', '2019-10-08', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 17'),
       (14, 3228, 'RTM CU17', 'https://support.microsoft.com/en-us/help/4515579', '2019-10-08', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 17'),
       (14, 3223, 'RTM CU16', 'https://support.microsoft.com/en-us/help/4508218', '2019-08-01', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 16'),
       (14, 3162, 'RTM CU15', 'https://support.microsoft.com/en-us/help/4498951', '2019-05-24', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 15'),
       (14, 3076, 'RTM CU14', 'https://support.microsoft.com/en-us/help/4484710', '2019-03-25', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 14'),
       (14, 3048, 'RTM CU13', 'https://support.microsoft.com/en-us/help/4466404', '2018-12-18', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 13'),
       (14, 3045, 'RTM CU12', 'https://support.microsoft.com/en-us/help/4464082', '2018-10-24', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 12'),
       (14, 3038, 'RTM CU11', 'https://support.microsoft.com/en-us/help/4462262', '2018-09-20', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 11'),
       (14, 3037, 'RTM CU10', 'https://support.microsoft.com/en-us/help/4524334', '2018-08-27', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 10'),
       (14, 3030, 'RTM CU9', 'https://support.microsoft.com/en-us/help/4515435', '2018-07-18', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 9'),
       (14, 3029, 'RTM CU8', 'https://support.microsoft.com/en-us/help/4338363', '2018-06-21', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 8'),
       (14, 3026, 'RTM CU7', 'https://support.microsoft.com/en-us/help/4229789', '2018-05-23', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 7'),
       (14, 3025, 'RTM CU6', 'https://support.microsoft.com/en-us/help/4101464', '2018-04-17', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 6'),
       (14, 3023, 'RTM CU5', 'https://support.microsoft.com/en-us/help/4092643', '2018-03-20', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 5'),
       (14, 3022, 'RTM CU4', 'https://support.microsoft.com/en-us/help/4056498', '2018-02-20', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 4'),
       (14, 3015, 'RTM CU3', 'https://support.microsoft.com/en-us/help/4052987', '2018-01-04', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 3'),
       (14, 3008, 'RTM CU2', 'https://support.microsoft.com/en-us/help/4052574', '2017-11-28', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 2'),
       (14, 3006, 'RTM CU1', 'https://support.microsoft.com/en-us/help/4038634', '2017-10-24', '2022-10-11',
        '2027-10-12', 'SQL Server 2017', 'RTM Cumulative Update 1'),
       (14, 1000, 'RTM ', '', '2017-10-02', '2022-10-11', '2027-10-12', 'SQL Server 2017', 'RTM '),
       (13, 5820, 'SP2 CU13', 'https://support.microsoft.com/en-us/help/4549825', '2020-05-28', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 13'),
       (13, 5698, 'SP2 CU12', 'https://support.microsoft.com/en-us/help/4536648', '2020-02-25', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 12'),
       (13, 5492, 'SP2 CU11', 'https://support.microsoft.com/en-us/help/4527378', '2019-12-09', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 11'),
       (13, 5492, 'SP2 CU10', 'https://support.microsoft.com/en-us/help/4505830', '2019-10-08', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 10'),
       (13, 5479, 'SP2 CU9', 'https://support.microsoft.com/en-us/help/4505830', '2019-09-30', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 9'),
       (13, 5426, 'SP2 CU10', 'https://support.microsoft.com/en-us/help/4505830', '2019-10-08', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 10'),
       (13, 5426, 'SP2 CU9', 'https://support.microsoft.com/en-us/help/4505830', '2019-09-30', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 9'),
       (13, 5426, 'SP2 CU8', 'https://support.microsoft.com/en-us/help/4505830', '2019-07-31', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 8'),
       (13, 5337, 'SP2 CU7', 'https://support.microsoft.com/en-us/help/4495256', '2019-05-23', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 7'),
       (13, 5292, 'SP2 CU6', 'https://support.microsoft.com/en-us/help/4488536', '2019-03-19', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 6'),
       (13, 5264, 'SP2 CU5', 'https://support.microsoft.com/en-us/help/4475776', '2019-01-23', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 5'),
       (13, 5233, 'SP2 CU4', 'https://support.microsoft.com/en-us/help/4464106', '2018-11-13', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 4'),
       (13, 5216, 'SP2 CU3', 'https://support.microsoft.com/en-us/help/4458871', '2018-09-20', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 3'),
       (13, 5201, 'SP2 CU2 + Security Update', 'https://support.microsoft.com/en-us/help/4458621', '2018-08-21',
        '2021-07-13', '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 2 + Security Update'),
       (13, 5153, 'SP2 CU2', 'https://support.microsoft.com/en-us/help/4340355', '2018-07-16', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 2'),
       (13, 5149, 'SP2 CU1', 'https://support.microsoft.com/en-us/help/4135048', '2018-05-30', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 2 Cumulative Update 1'),
       (13, 5026, 'SP2 ', 'https://support.microsoft.com/en-us/help/4052908', '2018-04-24', '2021-07-13', '2026-07-14',
        'SQL Server 2016', 'Service Pack 2 '),
       (13, 4574, 'SP1 CU15', 'https://support.microsoft.com/en-us/help/4495257', '2019-05-16', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 15'),
       (13, 4560, 'SP1 CU14', 'https://support.microsoft.com/en-us/help/4488535', '2019-03-19', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 14'),
       (13, 4550, 'SP1 CU13', 'https://support.microsoft.com/en-us/help/4475775', '2019-01-23', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 13'),
       (13, 4541, 'SP1 CU12', 'https://support.microsoft.com/en-us/help/4464343', '2018-11-13', '2021-07-13',
        '2026-07-14', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 12'),
       (13, 4528, 'SP1 CU11', 'https://support.microsoft.com/en-us/help/4459676', '2018-09-17', '2019-07-09',
        '2019-07-09', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 11'),
       (13, 4514, 'SP1 CU10', 'https://support.microsoft.com/en-us/help/4341569', '2018-07-16', '2019-07-09',
        '2019-07-09', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 10'),
       (13, 4502, 'SP1 CU9', 'https://support.microsoft.com/en-us/help/4100997', '2018-05-30', '2019-07-09',
        '2019-07-09', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 9'),
       (13, 4474, 'SP1 CU8', 'https://support.microsoft.com/en-us/help/4077064', '2018-03-19', '2019-07-09',
        '2019-07-09', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 8'),
       (13, 4466, 'SP1 CU7', 'https://support.microsoft.com/en-us/help/4057119', '2018-01-04', '2019-07-09',
        '2019-07-09', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 7'),
       (13, 4457, 'SP1 CU6', 'https://support.microsoft.com/en-us/help/4037354', '2017-11-20', '2019-07-09',
        '2019-07-09', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 6'),
       (13, 4451, 'SP1 CU5', 'https://support.microsoft.com/en-us/help/4024305', '2017-09-18', '2019-07-09',
        '2019-07-09', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 5'),
       (13, 4446, 'SP1 CU4', 'https://support.microsoft.com/en-us/help/4024305', '2017-08-08', '2019-07-09',
        '2019-07-09', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 4'),
       (13, 4435, 'SP1 CU3', 'https://support.microsoft.com/en-us/help/4019916', '2017-05-15', '2019-07-09',
        '2019-07-09', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 3'),
       (13, 4422, 'SP1 CU2', 'https://support.microsoft.com/en-us/help/4013106', '2017-03-20', '2019-07-09',
        '2019-07-09', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 2'),
       (13, 4411, 'SP1 CU1', 'https://support.microsoft.com/en-us/help/3208177', '2017-01-17', '2019-07-09',
        '2019-07-09', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 1'),
       (13, 4224, 'SP1 CU10 + Security Update', 'https://support.microsoft.com/en-us/help/4458842', '2018-08-22',
        '2019-07-09', '2019-07-09', 'SQL Server 2016', 'Service Pack 1 Cumulative Update 10 + Security Update'),
       (13, 4001, 'SP1 ', 'https://support.microsoft.com/en-us/help/3182545 ', '2016-11-16', '2019-07-09', '2019-07-09',
        'SQL Server 2016', 'Service Pack 1 '),
       (13, 2216, 'RTM CU9', 'https://support.microsoft.com/en-us/help/4037357', '2017-11-20', '2018-01-09',
        '2018-01-09', 'SQL Server 2016', 'RTM Cumulative Update 9'),
       (13, 2213, 'RTM CU8', 'https://support.microsoft.com/en-us/help/4024304', '2017-09-18', '2018-01-09',
        '2018-01-09', 'SQL Server 2016', 'RTM Cumulative Update 8'),
       (13, 2210, 'RTM CU7', 'https://support.microsoft.com/en-us/help/4024304', '2017-08-08', '2018-01-09',
        '2018-01-09', 'SQL Server 2016', 'RTM Cumulative Update 7'),
       (13, 2204, 'RTM CU6', 'https://support.microsoft.com/en-us/help/4019914', '2017-05-15', '2018-01-09',
        '2018-01-09', 'SQL Server 2016', 'RTM Cumulative Update 6'),
       (13, 2197, 'RTM CU5', 'https://support.microsoft.com/en-us/help/4013105', '2017-03-20', '2018-01-09',
        '2018-01-09', 'SQL Server 2016', 'RTM Cumulative Update 5'),
       (13, 2193, 'RTM CU4', 'https://support.microsoft.com/en-us/help/3205052 ', '2017-01-17', '2018-01-09',
        '2018-01-09', 'SQL Server 2016', 'RTM Cumulative Update 4'),
       (13, 2186, 'RTM CU3', 'https://support.microsoft.com/en-us/help/3205413 ', '2016-11-16', '2018-01-09',
        '2018-01-09', 'SQL Server 2016', 'RTM Cumulative Update 3'),
       (13, 2164, 'RTM CU2', 'https://support.microsoft.com/en-us/help/3182270 ', '2016-09-22', '2018-01-09',
        '2018-01-09', 'SQL Server 2016', 'RTM Cumulative Update 2'),
       (13, 2149, 'RTM CU1', 'https://support.microsoft.com/en-us/help/3164674 ', '2016-07-25', '2018-01-09',
        '2018-01-09', 'SQL Server 2016', 'RTM Cumulative Update 1'),
       (13, 1601, 'RTM ', '', '2016-06-01', '2019-01-09', '2019-01-09', 'SQL Server 2016', 'RTM '),
       (12, 6329, 'SP3 CU4', 'https://support.microsoft.com/en-us/help/4500181', '2019-07-29', '2019-07-09',
        '2024-07-09', 'SQL Server 2014', 'Service Pack 3 Cumulative Update 4'),
       (12, 6259, 'SP3 CU3', 'https://support.microsoft.com/en-us/help/4491539', '2019-04-16', '2019-07-09',
        '2024-07-09', 'SQL Server 2014', 'Service Pack 3 Cumulative Update 3'),
       (12, 6214, 'SP3 CU2', 'https://support.microsoft.com/en-us/help/4482960', '2019-02-19', '2019-07-09',
        '2024-07-09', 'SQL Server 2014', 'Service Pack 3 Cumulative Update 2'),
       (12, 6205, 'SP3 CU1', 'https://support.microsoft.com/en-us/help/4470220', '2018-12-12', '2019-07-09',
        '2024-07-09', 'SQL Server 2014', 'Service Pack 3 Cumulative Update 1'),
       (12, 6024, 'SP3 ', 'https://support.microsoft.com/en-us/help/4022619', '2018-10-30', '2019-07-09', '2024-07-09',
        'SQL Server 2014', 'Service Pack 3 '),
       (12, 5687, 'SP2 CU18', 'https://support.microsoft.com/en-us/help/4500180', '2019-07-29', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 18'),
       (12, 5632, 'SP2 CU17', 'https://support.microsoft.com/en-us/help/4491540', '2019-04-16', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 17'),
       (12, 5626, 'SP2 CU16', 'https://support.microsoft.com/en-us/help/4482967', '2019-02-19', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 16'),
       (12, 5605, 'SP2 CU15', 'https://support.microsoft.com/en-us/help/4469137', '2018-12-12', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 15'),
       (12, 5600, 'SP2 CU14', 'https://support.microsoft.com/en-us/help/4459860', '2018-10-15', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 14'),
       (12, 5590, 'SP2 CU13', 'https://support.microsoft.com/en-us/help/4456287', '2018-08-27', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 13'),
       (12, 5589, 'SP2 CU12', 'https://support.microsoft.com/en-us/help/4130489', '2018-06-18', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 12'),
       (12, 5579, 'SP2 CU11', 'https://support.microsoft.com/en-us/help/4077063', '2018-03-19', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 11'),
       (12, 5571, 'SP2 CU10', 'https://support.microsoft.com/en-us/help/4052725', '2018-01-16', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 10'),
       (12, 5563, 'SP2 CU9', 'https://support.microsoft.com/en-us/help/4055557', '2017-12-18', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 9'),
       (12, 5557, 'SP2 CU8', 'https://support.microsoft.com/en-us/help/4037356', '2017-10-16', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 8'),
       (12, 5556, 'SP2 CU7', 'https://support.microsoft.com/en-us/help/4032541', '2017-08-28', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 7'),
       (12, 5553, 'SP2 CU6', 'https://support.microsoft.com/en-us/help/4019094', '2017-08-08', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 6'),
       (12, 5546, 'SP2 CU5', 'https://support.microsoft.com/en-us/help/4013098', '2017-04-17', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 5'),
       (12, 5540, 'SP2 CU4', 'https://support.microsoft.com/en-us/help/4010394', '2017-02-21', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 4'),
       (12, 5538, 'SP2 CU3', 'https://support.microsoft.com/en-us/help/3204388 ', '2016-12-19', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 3'),
       (12, 5522, 'SP2 CU2', 'https://support.microsoft.com/en-us/help/3188778 ', '2016-10-17', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 2'),
       (12, 5511, 'SP2 CU1', 'https://support.microsoft.com/en-us/help/3178925 ', '2016-08-25', '2020-01-14',
        '2020-01-14', 'SQL Server 2014', 'Service Pack 2 Cumulative Update 1'),
       (12, 5000, 'SP2 ', 'https://support.microsoft.com/en-us/help/3171021 ', '2016-07-11', '2020-01-14', '2020-01-14',
        'SQL Server 2014', 'Service Pack 2 '),
       (12, 4522, 'SP1 CU13', 'https://support.microsoft.com/en-us/help/4019099', '2017-08-08', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 13'),
       (12, 4511, 'SP1 CU12', 'https://support.microsoft.com/en-us/help/4017793', '2017-04-17', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 12'),
       (12, 4502, 'SP1 CU11', 'https://support.microsoft.com/en-us/help/4010392', '2017-02-21', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 11'),
       (12, 4491, 'SP1 CU10', 'https://support.microsoft.com/en-us/help/3204399 ', '2016-12-19', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 10'),
       (12, 4474, 'SP1 CU9', 'https://support.microsoft.com/en-us/help/3186964 ', '2016-10-17', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 9'),
       (12, 4468, 'SP1 CU8', 'https://support.microsoft.com/en-us/help/3174038 ', '2016-08-15', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 8'),
       (12, 4459, 'SP1 CU7', 'https://support.microsoft.com/en-us/help/3162659 ', '2016-06-20', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 7'),
       (12, 4457, 'SP1 CU6', 'https://support.microsoft.com/en-us/help/3167392 ', '2016-05-30', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 6'),
       (12, 4449, 'SP1 CU6', 'https://support.microsoft.com/en-us/help/3144524', '2016-04-18', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 6'),
       (12, 4438, 'SP1 CU5', 'https://support.microsoft.com/en-us/help/3130926', '2016-02-22', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 5'),
       (12, 4436, 'SP1 CU4', 'https://support.microsoft.com/en-us/help/3106660', '2015-12-21', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 4'),
       (12, 4427, 'SP1 CU3', 'https://support.microsoft.com/en-us/help/3094221', '2015-10-19', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 3'),
       (12, 4422, 'SP1 CU2', 'https://support.microsoft.com/en-us/help/3075950', '2015-08-17', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 2'),
       (12, 4416, 'SP1 CU1', 'https://support.microsoft.com/en-us/help/3067839', '2015-06-19', '2017-10-10',
        '2017-10-10', 'SQL Server 2014', 'Service Pack 1 Cumulative Update 1'),
       (12, 4213, 'SP1 MS15-058: GDR Security Update', 'https://support.microsoft.com/en-us/help/3070446', '2015-07-14',
        '2017-10-10', '2017-10-10', 'SQL Server 2014', 'Service Pack 1 MS15-058: GDR Security Update'),
       (12, 4100, 'SP1 ', 'https://support.microsoft.com/en-us/help/3058865', '2015-05-04', '2017-10-10', '2017-10-10',
        'SQL Server 2014', 'Service Pack 1 '),
       (12, 2569, 'RTM CU14', 'https://support.microsoft.com/en-us/help/3158271 ', '2016-06-20', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 14'),
       (12, 2568, 'RTM CU13', 'https://support.microsoft.com/en-us/help/3144517', '2016-04-18', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 13'),
       (12, 2564, 'RTM CU12', 'https://support.microsoft.com/en-us/help/3130923', '2016-02-22', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 12'),
       (12, 2560, 'RTM CU11', 'https://support.microsoft.com/en-us/help/3106659', '2015-12-21', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 11'),
       (12, 2556, 'RTM CU10', 'https://support.microsoft.com/en-us/help/3094220', '2015-10-19', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 10'),
       (12, 2553, 'RTM CU9', 'https://support.microsoft.com/en-us/help/3075949', '2015-08-17', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 9'),
       (12, 2548, 'RTM MS15-058: QFE Security Update', 'https://support.microsoft.com/en-us/help/3045323', '2015-07-14',
        '2016-07-12', '2016-07-12', 'SQL Server 2014', 'RTM MS15-058: QFE Security Update'),
       (12, 2546, 'RTM CU8', 'https://support.microsoft.com/en-us/help/3067836', '2015-06-19', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 8'),
       (12, 2495, 'RTM CU7', 'https://support.microsoft.com/en-us/help/3046038', '2015-04-20', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 7'),
       (12, 2480, 'RTM CU6', 'https://support.microsoft.com/en-us/help/3031047', '2015-02-16', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 6'),
       (12, 2456, 'RTM CU5', 'https://support.microsoft.com/en-us/help/3011055', '2014-12-17', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 5'),
       (12, 2430, 'RTM CU4', 'https://support.microsoft.com/en-us/help/2999197', '2014-10-21', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 4'),
       (12, 2402, 'RTM CU3', 'https://support.microsoft.com/en-us/help/2984923', '2014-08-18', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 3'),
       (12, 2381, 'RTM MS14-044: QFE Security Update', 'https://support.microsoft.com/en-us/help/2977316', '2014-08-12',
        '2016-07-12', '2016-07-12', 'SQL Server 2014', 'RTM MS14-044: QFE Security Update'),
       (12, 2370, 'RTM CU2', 'https://support.microsoft.com/en-us/help/2967546', '2014-06-27', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 2'),
       (12, 2342, 'RTM CU1', 'https://support.microsoft.com/en-us/help/2931693', '2014-04-21', '2016-07-12',
        '2016-07-12', 'SQL Server 2014', 'RTM Cumulative Update 1'),
       (12, 2269, 'RTM MS15-058: GDR Security Update ', 'https://support.microsoft.com/en-us/help/3045324',
        '2015-07-14', '2016-07-12', '2016-07-12', 'SQL Server 2014', 'RTM MS15-058: GDR Security Update '),
       (12, 2254, 'RTM MS14-044: GDR Security Update', 'https://support.microsoft.com/en-us/help/2977315', '2014-08-12',
        '2016-07-12', '2016-07-12', 'SQL Server 2014', 'RTM MS14-044: GDR Security Update'),
       (12, 2000, 'RTM ', '', '2014-04-01', '2016-07-12', '2016-07-12', 'SQL Server 2014', 'RTM '),
       (11, 7001, 'SP4 ', 'https://support.microsoft.com/en-us/help/4018073', '2017-10-02', '2017-07-11', '2022-07-12',
        'SQL Server 2012', 'Service Pack 4 '),
       (11, 6607, 'SP3 CU10', 'https://support.microsoft.com/en-us/help/4025925', '2017-08-08', '2018-10-09',
        '2018-10-09', 'SQL Server 2012', 'Service Pack 3 Cumulative Update 10'),
       (11, 6598, 'SP3 CU9', 'https://support.microsoft.com/en-us/help/4016762', '2017-05-15', '2018-10-09',
        '2018-10-09', 'SQL Server 2012', 'Service Pack 3 Cumulative Update 9'),
       (11, 6594, 'SP3 CU8', 'https://support.microsoft.com/en-us/help/3205051 ', '2017-03-20', '2018-10-09',
        '2018-10-09', 'SQL Server 2012', 'Service Pack 3 Cumulative Update 8'),
       (11, 6579, 'SP3 CU7', 'https://support.microsoft.com/en-us/help/3205051 ', '2017-01-17', '2018-10-09',
        '2018-10-09', 'SQL Server 2012', 'Service Pack 3 Cumulative Update 7'),
       (11, 6567, 'SP3 CU6', 'https://support.microsoft.com/en-us/help/3194992 ', '2016-11-17', '2018-10-09',
        '2018-10-09', 'SQL Server 2012', 'Service Pack 3 Cumulative Update 6'),
       (11, 6544, 'SP3 CU5', 'https://support.microsoft.com/en-us/help/3180915 ', '2016-09-19', '2018-10-09',
        '2018-10-09', 'SQL Server 2012', 'Service Pack 3 Cumulative Update 5'),
       (11, 6540, 'SP3 CU4', 'https://support.microsoft.com/en-us/help/3165264 ', '2016-07-18', '2018-10-09',
        '2018-10-09', 'SQL Server 2012', 'Service Pack 3 Cumulative Update 4'),
       (11, 6537, 'SP3 CU3', 'https://support.microsoft.com/en-us/help/3152635 ', '2016-05-16', '2018-10-09',
        '2018-10-09', 'SQL Server 2012', 'Service Pack 3 Cumulative Update 3'),
       (11, 6523, 'SP3 CU2', 'https://support.microsoft.com/en-us/help/3137746', '2016-03-21', '2018-10-09',
        '2018-10-09', 'SQL Server 2012', 'Service Pack 3 Cumulative Update 2'),
       (11, 6518, 'SP3 CU1', 'https://support.microsoft.com/en-us/help/3123299', '2016-01-19', '2018-10-09',
        '2018-10-09', 'SQL Server 2012', 'Service Pack 3 Cumulative Update 1'),
       (11, 6020, 'SP3 ', 'https://support.microsoft.com/en-us/help/3072779', '2015-11-20', '2018-10-09', '2018-10-09',
        'SQL Server 2012', 'Service Pack 3 '),
       (11, 5678, 'SP2 CU16', 'https://support.microsoft.com/en-us/help/3205416 ', '2016-11-17', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 16'),
       (11, 5676, 'SP2 CU15', 'https://support.microsoft.com/en-us/help/3205416 ', '2016-11-17', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 15'),
       (11, 5657, 'SP2 CU14', 'https://support.microsoft.com/en-us/help/3180914 ', '2016-09-19', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 14'),
       (11, 5655, 'SP2 CU13', 'https://support.microsoft.com/en-us/help/3165266 ', '2016-07-18', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 13'),
       (11, 5649, 'SP2 CU12', 'https://support.microsoft.com/en-us/help/3152637 ', '2016-05-16', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 12'),
       (11, 5646, 'SP2 CU11', 'https://support.microsoft.com/en-us/help/3137745', '2016-03-21', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 11'),
       (11, 5644, 'SP2 CU10', 'https://support.microsoft.com/en-us/help/3120313', '2016-01-19', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 10'),
       (11, 5641, 'SP2 CU9', 'https://support.microsoft.com/en-us/help/3098512', '2015-11-16', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 9'),
       (11, 5634, 'SP2 CU8', 'https://support.microsoft.com/en-us/help/3082561', '2015-09-21', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 8'),
       (11, 5623, 'SP2 CU7', 'https://support.microsoft.com/en-us/help/3072100', '2015-07-20', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 7'),
       (11, 5613, 'SP2 MS15-058: QFE Security Update', 'https://support.microsoft.com/en-us/help/3045319', '2015-07-14',
        '2017-01-10', '2017-01-10', 'SQL Server 2012', 'Service Pack 2 MS15-058: QFE Security Update'),
       (11, 5592, 'SP2 CU6', 'https://support.microsoft.com/en-us/help/3052468', '2015-05-18', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 6'),
       (11, 5582, 'SP2 CU5', 'https://support.microsoft.com/en-us/help/3037255', '2015-03-16', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 5'),
       (11, 5569, 'SP2 CU4', 'https://support.microsoft.com/en-us/help/3007556', '2015-01-19', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 4'),
       (11, 5556, 'SP2 CU3', 'https://support.microsoft.com/en-us/help/3002049', '2014-11-17', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 3'),
       (11, 5548, 'SP2 CU2', 'https://support.microsoft.com/en-us/help/2983175', '2014-09-15', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 2'),
       (11, 5532, 'SP2 CU1', 'https://support.microsoft.com/en-us/help/2976982', '2014-07-23', '2017-01-10',
        '2017-01-10', 'SQL Server 2012', 'Service Pack 2 Cumulative Update 1'),
       (11, 5343, 'SP2 MS15-058: GDR Security Update', 'https://support.microsoft.com/en-us/help/3045321', '2015-07-14',
        '2017-01-10', '2017-01-10', 'SQL Server 2012', 'Service Pack 2 MS15-058: GDR Security Update'),
       (11, 5058, 'SP2 ', 'https://support.microsoft.com/en-us/help/2958429', '2014-06-10', '2017-01-10', '2017-01-10',
        'SQL Server 2012', 'Service Pack 2 '),
       (11, 3513, 'SP1 MS15-058: QFE Security Update', 'https://support.microsoft.com/en-us/help/3045317', '2015-07-14',
        '2015-07-14', '2015-07-14', 'SQL Server 2012', 'Service Pack 1 MS15-058: QFE Security Update'),
       (11, 3482, 'SP1 CU13', 'https://support.microsoft.com/en-us/help/3002044', '2014-11-17', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 13'),
       (11, 3470, 'SP1 CU12', 'https://support.microsoft.com/en-us/help/2991533', '2014-09-15', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 12'),
       (11, 3460, 'SP1 MS14-044: QFE Security Update ', 'https://support.microsoft.com/en-us/help/2977325',
        '2014-08-12', '2015-07-14', '2015-07-14', 'SQL Server 2012', 'Service Pack 1 MS14-044: QFE Security Update '),
       (11, 3449, 'SP1 CU11', 'https://support.microsoft.com/en-us/help/2975396', '2014-07-21', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 11'),
       (11, 3431, 'SP1 CU10', 'https://support.microsoft.com/en-us/help/2954099', '2014-05-19', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 10'),
       (11, 3412, 'SP1 CU9', 'https://support.microsoft.com/en-us/help/2931078', '2014-03-17', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 9'),
       (11, 3401, 'SP1 CU8', 'https://support.microsoft.com/en-us/help/2917531', '2014-01-20', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 8'),
       (11, 3393, 'SP1 CU7', 'https://support.microsoft.com/en-us/help/2894115', '2013-11-18', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 7'),
       (11, 3381, 'SP1 CU6', 'https://support.microsoft.com/en-us/help/2874879', '2013-09-16', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 6'),
       (11, 3373, 'SP1 CU5', 'https://support.microsoft.com/en-us/help/2861107', '2013-07-15', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 5'),
       (11, 3368, 'SP1 CU4', 'https://support.microsoft.com/en-us/help/2833645', '2013-05-30', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 4'),
       (11, 3349, 'SP1 CU3', 'https://support.microsoft.com/en-us/help/2812412', '2013-03-18', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 3'),
       (11, 3339, 'SP1 CU2', 'https://support.microsoft.com/en-us/help/2790947', '2013-01-21', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 2'),
       (11, 3321, 'SP1 CU1', 'https://support.microsoft.com/en-us/help/2765331', '2012-11-20', '2015-07-14',
        '2015-07-14', 'SQL Server 2012', 'Service Pack 1 Cumulative Update 1'),
       (11, 3156, 'SP1 MS15-058: GDR Security Update', 'https://support.microsoft.com/en-us/help/3045318', '2015-07-14',
        '2015-07-14', '2015-07-14', 'SQL Server 2012', 'Service Pack 1 MS15-058: GDR Security Update'),
       (11, 3153, 'SP1 MS14-044: GDR Security Update', 'https://support.microsoft.com/en-us/help/2977326', '2014-08-12',
        '2015-07-14', '2015-07-14', 'SQL Server 2012', 'Service Pack 1 MS14-044: GDR Security Update'),
       (11, 3000, 'SP1 ', 'https://support.microsoft.com/en-us/help/2674319', '2012-11-07', '2015-07-14', '2015-07-14',
        'SQL Server 2012', 'Service Pack 1 '),
       (11, 2424, 'RTM CU11', 'https://support.microsoft.com/en-us/help/2908007', '2013-12-16', '2017-07-11',
        '2022-07-12', 'SQL Server 2012', 'RTM Cumulative Update 11'),
       (11, 2420, 'RTM CU10', 'https://support.microsoft.com/en-us/help/2891666', '2013-10-21', '2017-07-11',
        '2022-07-12', 'SQL Server 2012', 'RTM Cumulative Update 10'),
       (11, 2419, 'RTM CU9', 'https://support.microsoft.com/en-us/help/2867319', '2013-08-20', '2017-07-11',
        '2022-07-12', 'SQL Server 2012', 'RTM Cumulative Update 9'),
       (11, 2410, 'RTM CU8', 'https://support.microsoft.com/en-us/help/2844205', '2013-06-17', '2017-07-11',
        '2022-07-12', 'SQL Server 2012', 'RTM Cumulative Update 8'),
       (11, 2405, 'RTM CU7', 'https://support.microsoft.com/en-us/help/2823247', '2013-04-15', '2017-07-11',
        '2022-07-12', 'SQL Server 2012', 'RTM Cumulative Update 7'),
       (11, 2401, 'RTM CU6', 'https://support.microsoft.com/en-us/help/2728897', '2013-02-18', '2017-07-11',
        '2022-07-12', 'SQL Server 2012', 'RTM Cumulative Update 6'),
       (11, 2395, 'RTM CU5', 'https://support.microsoft.com/en-us/help/2777772', '2012-12-17', '2017-07-11',
        '2022-07-12', 'SQL Server 2012', 'RTM Cumulative Update 5'),
       (11, 2383, 'RTM CU4', 'https://support.microsoft.com/en-us/help/2758687', '2012-10-15', '2017-07-11',
        '2022-07-12', 'SQL Server 2012', 'RTM Cumulative Update 4'),
       (11, 2376, 'RTM MS12-070: QFE Security Update', 'https://support.microsoft.com/en-us/help/2716441', '2012-10-09',
        '2017-07-11', '2022-07-12', 'SQL Server 2012', 'RTM MS12-070: QFE Security Update'),
       (11, 2332, 'RTM CU3', 'https://support.microsoft.com/en-us/help/2723749', '2012-08-31', '2017-07-11',
        '2022-07-12', 'SQL Server 2012', 'RTM Cumulative Update 3'),
       (11, 2325, 'RTM CU2', 'https://support.microsoft.com/en-us/help/2703275', '2012-06-18', '2017-07-11',
        '2022-07-12', 'SQL Server 2012', 'RTM Cumulative Update 2'),
       (11, 2316, 'RTM CU1', 'https://support.microsoft.com/en-us/help/2679368', '2012-04-12', '2017-07-11',
        '2022-07-12', 'SQL Server 2012', 'RTM Cumulative Update 1'),
       (11, 2218, 'RTM MS12-070: GDR Security Update', 'https://support.microsoft.com/en-us/help/2716442', '2012-10-09',
        '2017-07-11', '2022-07-12', 'SQL Server 2012', 'RTM MS12-070: GDR Security Update'),
       (11, 2100, 'RTM ', '', '2012-03-06', '2017-07-11', '2022-07-12', 'SQL Server 2012', 'RTM '),
       (10, 6529, 'SP3 MS15-058: QFE Security Update', 'https://support.microsoft.com/en-us/help/3045314', '2015-07-14',
        '2014-07-08', '2019-07-09', 'SQL Server 2008 R2', 'Service Pack 3 MS15-058: QFE Security Update'),
       (10, 6220, 'SP3 MS15-058: QFE Security Update', 'https://support.microsoft.com/en-us/help/3045316', '2015-07-14',
        '2014-07-08', '2019-07-09', 'SQL Server 2008 R2', 'Service Pack 3 MS15-058: QFE Security Update'),
       (10, 6000, 'SP3 ', 'https://support.microsoft.com/en-us/help/2979597', '2014-09-26', '2014-07-08', '2019-07-09',
        'SQL Server 2008 R2', 'Service Pack 3 '),
       (10, 4339, 'SP2 MS15-058: QFE Security Update', 'https://support.microsoft.com/en-us/help/3045312', '2015-07-14',
        '2015-10-13', '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 MS15-058: QFE Security Update'),
       (10, 4321, 'SP2 MS14-044: QFE Security Update', 'https://support.microsoft.com/en-us/help/2977319', '2014-08-14',
        '2015-10-13', '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 MS14-044: QFE Security Update'),
       (10, 4319, 'SP2 CU13', 'https://support.microsoft.com/en-us/help/2967540', '2014-06-30', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 13'),
       (10, 4305, 'SP2 CU12', 'https://support.microsoft.com/en-us/help/2938478', '2014-04-21', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 12'),
       (10, 4302, 'SP2 CU11', 'https://support.microsoft.com/en-us/help/2926028', '2014-02-18', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 11'),
       (10, 4297, 'SP2 CU10', 'https://support.microsoft.com/en-us/help/2908087', '2013-12-17', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 10'),
       (10, 4295, 'SP2 CU9', 'https://support.microsoft.com/en-us/help/2887606', '2013-10-28', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 9'),
       (10, 4290, 'SP2 CU8', 'https://support.microsoft.com/en-us/help/2871401', '2013-08-22', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 8'),
       (10, 4285, 'SP2 CU7', 'https://support.microsoft.com/en-us/help/2844090', '2013-06-17', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 7'),
       (10, 4279, 'SP2 CU6', 'https://support.microsoft.com/en-us/help/2830140', '2013-04-15', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 6'),
       (10, 4276, 'SP2 CU5', 'https://support.microsoft.com/en-us/help/2797460', '2013-02-18', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 5'),
       (10, 4270, 'SP2 CU4', 'https://support.microsoft.com/en-us/help/2777358', '2012-12-17', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 4'),
       (10, 4266, 'SP2 CU3', 'https://support.microsoft.com/en-us/help/2754552', '2012-10-15', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 3'),
       (10, 4263, 'SP2 CU2', 'https://support.microsoft.com/en-us/help/2740411', '2012-08-31', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 2'),
       (10, 4260, 'SP2 CU1', 'https://support.microsoft.com/en-us/help/2720425', '2012-07-24', '2015-10-13',
        '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 Cumulative Update 1'),
       (10, 4042, 'SP2 MS15-058: GDR Security Update', 'https://support.microsoft.com/en-us/help/3045313', '2015-07-14',
        '2015-10-13', '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 MS15-058: GDR Security Update'),
       (10, 4033, 'SP2 MS14-044: GDR Security Update', 'https://support.microsoft.com/en-us/help/2977320', '2014-08-12',
        '2015-10-13', '2015-10-13', 'SQL Server 2008 R2', 'Service Pack 2 MS14-044: GDR Security Update'),
       (10, 4000, 'SP2 ', 'https://support.microsoft.com/en-us/help/2630458', '2012-07-26', '2015-10-13', '2015-10-13',
        'SQL Server 2008 R2', 'Service Pack 2 '),
       (10, 2881, 'SP1 CU14', 'https://support.microsoft.com/en-us/help/2868244', '2013-08-08', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 14'),
       (10, 2876, 'SP1 CU13', 'https://support.microsoft.com/en-us/help/2855792', '2013-06-17', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 13'),
       (10, 2874, 'SP1 CU12', 'https://support.microsoft.com/en-us/help/2828727', '2013-04-15', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 12'),
       (10, 2869, 'SP1 CU11', 'https://support.microsoft.com/en-us/help/2812683', '2013-02-18', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 11'),
       (10, 2868, 'SP1 CU10', 'https://support.microsoft.com/en-us/help/2783135', '2012-12-17', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 10'),
       (10, 2866, 'SP1 CU9', 'https://support.microsoft.com/en-us/help/2756574', '2012-10-15', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 9'),
       (10, 2861, 'SP1 MS12-070: QFE Security Update', 'https://support.microsoft.com/en-us/help/2716439', '2012-10-09',
        '2013-10-08', '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 MS12-070: QFE Security Update'),
       (10, 2822, 'SP1 CU8', 'https://support.microsoft.com/en-us/help/2723743', '2012-08-31', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 8'),
       (10, 2817, 'SP1 CU7', 'https://support.microsoft.com/en-us/help/2703282', '2012-06-18', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 7'),
       (10, 2811, 'SP1 CU6', 'https://support.microsoft.com/en-us/help/2679367', '2012-04-16', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 6'),
       (10, 2806, 'SP1 CU5', 'https://support.microsoft.com/en-us/help/2659694', '2012-02-22', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 5'),
       (10, 2796, 'SP1 CU4', 'https://support.microsoft.com/en-us/help/2633146', '2011-12-19', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 4'),
       (10, 2789, 'SP1 CU3', 'https://support.microsoft.com/en-us/help/2591748', '2011-10-17', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 3'),
       (10, 2772, 'SP1 CU2', 'https://support.microsoft.com/en-us/help/2567714', '2011-08-15', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 2'),
       (10, 2769, 'SP1 CU1', 'https://support.microsoft.com/en-us/help/2544793', '2011-07-18', '2013-10-08',
        '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 Cumulative Update 1'),
       (10, 2550, 'SP1 MS12-070: GDR Security Update', 'https://support.microsoft.com/en-us/help/2754849', '2012-10-09',
        '2013-10-08', '2013-10-08', 'SQL Server 2008 R2', 'Service Pack 1 MS12-070: GDR Security Update'),
       (10, 2500, 'SP1 ', 'https://support.microsoft.com/en-us/help/2528583', '2011-07-12', '2013-10-08', '2013-10-08',
        'SQL Server 2008 R2', 'Service Pack 1 '),
       (10, 1815, 'RTM CU13', 'https://support.microsoft.com/en-us/help/2679366', '2012-04-16', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 13'),
       (10, 1810, 'RTM CU12', 'https://support.microsoft.com/en-us/help/2659692', '2012-02-21', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 12'),
       (10, 1809, 'RTM CU11', 'https://support.microsoft.com/en-us/help/2633145', '2011-12-19', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 11'),
       (10, 1807, 'RTM CU10', 'https://support.microsoft.com/en-us/help/2591746', '2011-10-17', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 10'),
       (10, 1804, 'RTM CU9', 'https://support.microsoft.com/en-us/help/2567713', '2011-08-15', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 9'),
       (10, 1797, 'RTM CU8', 'https://support.microsoft.com/en-us/help/2534352', '2011-06-20', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 8'),
       (10, 1790, 'RTM MS11-049: QFE Security Update', 'https://support.microsoft.com/en-us/help/2494086', '2011-06-14',
        '2014-07-08', '2019-07-09', 'SQL Server 2008 R2', 'RTM MS11-049: QFE Security Update'),
       (10, 1777, 'RTM CU7', 'https://support.microsoft.com/en-us/help/2507770', '2011-04-18', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 7'),
       (10, 1765, 'RTM CU6', 'https://support.microsoft.com/en-us/help/2489376', '2011-02-21', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 6'),
       (10, 1753, 'RTM CU5', 'https://support.microsoft.com/en-us/help/2438347', '2010-12-20', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 5'),
       (10, 1746, 'RTM CU4', 'https://support.microsoft.com/en-us/help/2345451', '2010-10-18', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 4'),
       (10, 1734, 'RTM CU3', 'https://support.microsoft.com/en-us/help/2261464', '2010-08-16', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 3'),
       (10, 1720, 'RTM CU2', 'https://support.microsoft.com/en-us/help/2072493', '2010-06-21', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 2'),
       (10, 1702, 'RTM CU1', 'https://support.microsoft.com/en-us/help/981355', '2010-05-18', '2014-07-08',
        '2019-07-09', 'SQL Server 2008 R2', 'RTM Cumulative Update 1'),
       (10, 1617, 'RTM MS11-049: GDR Security Update', 'https://support.microsoft.com/en-us/help/2494088', '2011-06-14',
        '2014-07-08', '2019-07-09', 'SQL Server 2008 R2', 'RTM MS11-049: GDR Security Update'),
       (10, 1600, 'RTM ', '', '2010-05-10', '2014-07-08', '2019-07-09', 'SQL Server 2008 R2', 'RTM '),
       (10, 6535, 'SP3 MS15-058: QFE Security Update', 'https://support.microsoft.com/en-us/help/3045308', '2015-07-14',
        '2015-10-13', '2015-10-13', 'SQL Server 2008', 'Service Pack 3 MS15-058: QFE Security Update'),
       (10, 6241, 'SP3 MS15-058: GDR Security Update', 'https://support.microsoft.com/en-us/help/3045311', '2015-07-14',
        '2015-10-13', '2015-10-13', 'SQL Server 2008', 'Service Pack 3 MS15-058: GDR Security Update'),
       (10, 5890, 'SP3 MS15-058: QFE Security Update', 'https://support.microsoft.com/en-us/help/3045303', '2015-07-14',
        '2015-10-13', '2015-10-13', 'SQL Server 2008', 'Service Pack 3 MS15-058: QFE Security Update'),
       (10, 5869, 'SP3 MS14-044: QFE Security Update',
        'https://support.microsoft.com/en-us/help/2984340, https://support.microsoft.com/en-us/help/2977322',
        '2014-08-12', '2015-10-13', '2015-10-13', 'SQL Server 2008', 'Service Pack 3 MS14-044: QFE Security Update'),
       (10, 5861, 'SP3 CU17', 'https://support.microsoft.com/en-us/help/2958696', '2014-05-19', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 17'),
       (10, 5852, 'SP3 CU16', 'https://support.microsoft.com/en-us/help/2936421', '2014-03-17', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 16'),
       (10, 5850, 'SP3 CU15', 'https://support.microsoft.com/en-us/help/2923520', '2014-01-20', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 15'),
       (10, 5848, 'SP3 CU14', 'https://support.microsoft.com/en-us/help/2893410', '2013-11-18', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 14'),
       (10, 5846, 'SP3 CU13', 'https://support.microsoft.com/en-us/help/2880350', '2013-09-16', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 13'),
       (10, 5844, 'SP3 CU12', 'https://support.microsoft.com/en-us/help/2863205', '2013-07-15', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 12'),
       (10, 5840, 'SP3 CU11', 'https://support.microsoft.com/en-us/help/2834048', '2013-05-20', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 11'),
       (10, 5835, 'SP3 CU10', 'https://support.microsoft.com/en-us/help/2814783', '2013-03-18', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 10'),
       (10, 5829, 'SP3 CU9', 'https://support.microsoft.com/en-us/help/2799883', '2013-01-21', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 9'),
       (10, 5828, 'SP3 CU8', 'https://support.microsoft.com/en-us/help/2771833', '2012-11-19', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 8'),
       (10, 5826, 'SP3 MS12-070: QFE Security Update', 'https://support.microsoft.com/en-us/help/2716435', '2012-10-09',
        '2015-10-13', '2015-10-13', 'SQL Server 2008', 'Service Pack 3 MS12-070: QFE Security Update'),
       (10, 5794, 'SP3 CU7', 'https://support.microsoft.com/en-us/help/2738350', '2012-09-17', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 7'),
       (10, 5788, 'SP3 CU6', 'https://support.microsoft.com/en-us/help/2715953', '2012-07-16', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 6'),
       (10, 5785, 'SP3 CU5', 'https://support.microsoft.com/en-us/help/2696626', '2012-05-21', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 5'),
       (10, 5775, 'SP3 CU4', 'https://support.microsoft.com/en-us/help/2673383', '2012-03-19', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 4'),
       (10, 5770, 'SP3 CU3', 'https://support.microsoft.com/en-us/help/2648098', '2012-01-16', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 3'),
       (10, 5768, 'SP3 CU2', 'https://support.microsoft.com/en-us/help/2633143', '2011-11-21', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 2'),
       (10, 5766, 'SP3 CU1', 'https://support.microsoft.com/en-us/help/2617146', '2011-10-17', '2015-10-13',
        '2015-10-13', 'SQL Server 2008', 'Service Pack 3 Cumulative Update 1'),
       (10, 5538, 'SP3 MS15-058: GDR Security Update', 'https://support.microsoft.com/en-us/help/3045305', '2015-07-14',
        '2015-10-13', '2015-10-13', 'SQL Server 2008', 'Service Pack 3 MS15-058: GDR Security Update'),
       (10, 5520, 'SP3 MS14-044: GDR Security Update', 'https://support.microsoft.com/en-us/help/2977321', '2014-08-12',
        '2015-10-13', '2015-10-13', 'SQL Server 2008', 'Service Pack 3 MS14-044: GDR Security Update'),
       (10, 5512, 'SP3 MS12-070: GDR Security Update', 'https://support.microsoft.com/en-us/help/2716436', '2012-10-09',
        '2015-10-13', '2015-10-13', 'SQL Server 2008', 'Service Pack 3 MS12-070: GDR Security Update'),
       (10, 5500, 'SP3 ', 'https://support.microsoft.com/en-us/help/2546951', '2011-10-06', '2015-10-13', '2015-10-13',
        'SQL Server 2008', 'Service Pack 3 '),
       (10, 4371, 'SP2 MS12-070: QFE Security Update', 'https://support.microsoft.com/en-us/help/2716433', '2012-10-09',
        '2012-10-09', '2012-10-09', 'SQL Server 2008', 'Service Pack 2 MS12-070: QFE Security Update'),
       (10, 4333, 'SP2 CU11', 'https://support.microsoft.com/en-us/help/2715951', '2012-07-16', '2012-10-09',
        '2012-10-09', 'SQL Server 2008', 'Service Pack 2 Cumulative Update 11'),
       (10, 4332, 'SP2 CU10', 'https://support.microsoft.com/en-us/help/2696625', '2012-05-21', '2012-10-09',
        '2012-10-09', 'SQL Server 2008', 'Service Pack 2 Cumulative Update 10'),
       (10, 4330, 'SP2 CU9', 'https://support.microsoft.com/en-us/help/2673382', '2012-03-19', '2012-10-09',
        '2012-10-09', 'SQL Server 2008', 'Service Pack 2 Cumulative Update 9'),
       (10, 4326, 'SP2 CU8', 'https://support.microsoft.com/en-us/help/2648096', '2012-01-16', '2012-10-09',
        '2012-10-09', 'SQL Server 2008', 'Service Pack 2 Cumulative Update 8'),
       (10, 4323, 'SP2 CU7', 'https://support.microsoft.com/en-us/help/2617148', '2011-11-21', '2012-10-09',
        '2012-10-09', 'SQL Server 2008', 'Service Pack 2 Cumulative Update 7'),
       (10, 4321, 'SP2 CU6', 'https://support.microsoft.com/en-us/help/2582285', '2011-09-19', '2012-10-09',
        '2012-10-09', 'SQL Server 2008', 'Service Pack 2 Cumulative Update 6'),
       (10, 4316, 'SP2 CU5', 'https://support.microsoft.com/en-us/help/2555408', '2011-07-18', '2012-10-09',
        '2012-10-09', 'SQL Server 2008', 'Service Pack 2 Cumulative Update 5'),
       (10, 4311, 'SP2 MS11-049: QFE Security Update', 'https://support.microsoft.com/en-us/help/2494094', '2011-06-14',
        '2012-10-09', '2012-10-09', 'SQL Server 2008', 'Service Pack 2 MS11-049: QFE Security Update'),
       (10, 4285, 'SP2 CU4', 'https://support.microsoft.com/en-us/help/2527180', '2011-05-16', '2012-10-09',
        '2012-10-09', 'SQL Server 2008', 'Service Pack 2 Cumulative Update 4'),
       (10, 4279, 'SP2 CU3', 'https://support.microsoft.com/en-us/help/2498535', '2011-03-17', '2012-10-09',
        '2012-10-09', 'SQL Server 2008', 'Service Pack 2 Cumulative Update 3'),
       (10, 4272, 'SP2 CU2', 'https://support.microsoft.com/en-us/help/2467239', '2011-01-17', '2012-10-09',
        '2012-10-09', 'SQL Server 2008', 'Service Pack 2 Cumulative Update 2'),
       (10, 4266, 'SP2 CU1', 'https://support.microsoft.com/en-us/help/2289254', '2010-11-15', '2012-10-09',
        '2012-10-09', 'SQL Server 2008', 'Service Pack 2 Cumulative Update 1'),
       (10, 4067, 'SP2 MS12-070: GDR Security Update', 'https://support.microsoft.com/en-us/help/2716434', '2012-10-09',
        '2012-10-09', '2012-10-09', 'SQL Server 2008', 'Service Pack 2 MS12-070: GDR Security Update'),
       (10, 4064, 'SP2 MS11-049: GDR Security Update', 'https://support.microsoft.com/en-us/help/2494089', '2011-06-14',
        '2012-10-09', '2012-10-09', 'SQL Server 2008', 'Service Pack 2 MS11-049: GDR Security Update'),
       (10, 4000, 'SP2 ', 'https://support.microsoft.com/en-us/help/2285068', '2010-09-29', '2012-10-09', '2012-10-09',
        'SQL Server 2008', 'Service Pack 2 '),
       (10, 2850, 'SP1 CU16', 'https://support.microsoft.com/en-us/help/2582282', '2011-09-19', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 16'),
       (10, 2847, 'SP1 CU15', 'https://support.microsoft.com/en-us/help/2555406', '2011-07-18', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 15'),
       (10, 2841, 'SP1 MS11-049: QFE Security Update', 'https://support.microsoft.com/en-us/help/2494100', '2011-06-14',
        '2011-10-11', '2011-10-11', 'SQL Server 2008', 'Service Pack 1 MS11-049: QFE Security Update'),
       (10, 2821, 'SP1 CU14', 'https://support.microsoft.com/en-us/help/2527187', '2011-05-16', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 14'),
       (10, 2816, 'SP1 CU13', 'https://support.microsoft.com/en-us/help/2497673', '2011-03-17', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 13'),
       (10, 2808, 'SP1 CU12', 'https://support.microsoft.com/en-us/help/2467236', '2011-01-17', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 12'),
       (10, 2804, 'SP1 CU11', 'https://support.microsoft.com/en-us/help/2413738', '2010-11-15', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 11'),
       (10, 2799, 'SP1 CU10', 'https://support.microsoft.com/en-us/help/2279604', '2010-09-20', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 10'),
       (10, 2789, 'SP1 CU9', 'https://support.microsoft.com/en-us/help/2083921', '2010-07-19', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 9'),
       (10, 2775, 'SP1 CU8', 'https://support.microsoft.com/en-us/help/981702', '2010-05-17', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 8'),
       (10, 2766, 'SP1 CU7', 'https://support.microsoft.com/en-us/help/979065', '2010-03-26', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 7'),
       (10, 2757, 'SP1 CU6', 'https://support.microsoft.com/en-us/help/977443', '2010-01-18', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 6'),
       (10, 2746, 'SP1 CU5', 'https://support.microsoft.com/en-us/help/975977', '2009-11-16', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 5'),
       (10, 2734, 'SP1 CU4', 'https://support.microsoft.com/en-us/help/973602', '2009-09-21', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 4'),
       (10, 2723, 'SP1 CU3', 'https://support.microsoft.com/en-us/help/971491', '2009-07-20', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 3'),
       (10, 2714, 'SP1 CU2', 'https://support.microsoft.com/en-us/help/970315', '2009-05-18', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 2'),
       (10, 2710, 'SP1 CU1', 'https://support.microsoft.com/en-us/help/969099', '2009-04-16', '2011-10-11',
        '2011-10-11', 'SQL Server 2008', 'Service Pack 1 Cumulative Update 1'),
       (10, 2573, 'SP1 MS11-049: GDR Security update', 'https://support.microsoft.com/en-us/help/2494096', '2011-06-14',
        '2011-10-11', '2011-10-11', 'SQL Server 2008', 'Service Pack 1 MS11-049: GDR Security update'),
       (10, 2531, 'SP1 ', '', '2009-04-01', '2011-10-11', '2011-10-11', 'SQL Server 2008', 'Service Pack 1 '),
       (10, 1835, 'RTM CU10', 'https://support.microsoft.com/en-us/help/979064', '2010-03-15', '2014-07-08',
        '2019-07-09', 'SQL Server 2008', 'RTM Cumulative Update 10'),
       (10, 1828, 'RTM CU9', 'https://support.microsoft.com/en-us/help/977444', '2010-01-18', '2014-07-08',
        '2019-07-09', 'SQL Server 2008', 'RTM Cumulative Update 9'),
       (10, 1823, 'RTM CU8', 'https://support.microsoft.com/en-us/help/975976', '2009-11-16', '2014-07-08',
        '2019-07-09', 'SQL Server 2008', 'RTM Cumulative Update 8'),
       (10, 1818, 'RTM CU7', 'https://support.microsoft.com/en-us/help/973601', '2009-09-21', '2014-07-08',
        '2019-07-09', 'SQL Server 2008', 'RTM Cumulative Update 7'),
       (10, 1812, 'RTM CU6', 'https://support.microsoft.com/en-us/help/971490', '2009-07-20', '2014-07-08',
        '2019-07-09', 'SQL Server 2008', 'RTM Cumulative Update 6'),
       (10, 1806, 'RTM CU5', 'https://support.microsoft.com/en-us/help/969531', '2009-05-18', '2014-07-08',
        '2019-07-09', 'SQL Server 2008', 'RTM Cumulative Update 5'),
       (10, 1798, 'RTM CU4', 'https://support.microsoft.com/en-us/help/963036', '2009-03-16', '2014-07-08',
        '2019-07-09', 'SQL Server 2008', 'RTM Cumulative Update 4'),
       (10, 1787, 'RTM CU3', 'https://support.microsoft.com/en-us/help/960484', '2009-01-19', '2014-07-08',
        '2019-07-09', 'SQL Server 2008', 'RTM Cumulative Update 3'),
       (10, 1779, 'RTM CU2', 'https://support.microsoft.com/en-us/help/958186', '2008-11-19', '2014-07-08',
        '2019-07-09', 'SQL Server 2008', 'RTM Cumulative Update 2'),
       (10, 1763, 'RTM CU1', 'https://support.microsoft.com/en-us/help/956717', '2008-09-22', '2014-07-08',
        '2019-07-09', 'SQL Server 2008', 'RTM Cumulative Update 1'),
       (10, 1600, 'RTM ', '', '2008-08-06', '2014-07-08', '2019-07-09', 'SQL Server 2008', 'RTM ');
go
